/*!
 * LMV v7.96.0
 *
 * Copyright 2024 Autodesk, Inc.
 * All rights reserved.
 *
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 *
 * Autodesk Viewer SDK Usage Limitations:
 *
 * The Autodesk Viewer SDK JavaScript must be delivered from an
 * Autodesk-hosted URL.
 */
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/
(() => { // webpackBootstrap
    /******/ // runtime can't be in strict mode because a global variable is assign and maybe created.
    /******/
    var __webpack_modules__ = ({

        /***/
        "./extensions/VisualClusters/AnimController.js":
            /*!*****************************************************!*\
              !*** ./extensions/VisualClusters/AnimController.js ***!
              \*****************************************************/
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AnimController)\n/* harmony export */ });\n/* harmony import */ var _AnimState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimState.js */ \"./extensions/VisualClusters/AnimState.js\");\n//\n// Controls animations between different animation states.\n//\n\n\n\n\n// An AnimController contains multiple scene animation states and can smoothly interpolate between those. Each state defines the positions for several objects.\n//\n// Example: Transition from \"original shape positions\" to \"shapes are grouped by categories\".\nclass AnimController {\n\n  constructor(viewer) {\n\n    // Describes animation state at the current time.\n    this.currentState = new _AnimState_js__WEBPACK_IMPORTED_MODULE_0__.SceneAnimState();\n\n    // Different states that we can interpolate between - indexed by stateName.\n    this.states = {}; // string => SceneAnimState\n\n    // Animation state at the point when the last animation had started\n    this.startState = new _AnimState_js__WEBPACK_IMPORTED_MODULE_0__.SceneAnimState();\n\n    // {Viewer3D}\n    this.viewer = viewer;\n\n    // Used to interrupt running in-progress animations\n    this.animControl = null;\n  }\n\n  // Start animation to a target state.\n  //\n  // @param {string} [stateName] - A previously registered stateName or null. Null returns to original shape positions.\n  //\n  // @returns {AnimControl} Control in-progress animation..\n  //                          control.stop(): to interrupt it.\n  //                          control.isRunning(): to check whether it is in progress.\n  animateTo() {let stateName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;let animTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2.0;\n\n    // Make sure that we don't run any previous animation concurrently\n    this.stopAnim();\n\n    const endState = this.states[stateName];\n\n    const onTimer = (t) => {\n\n      // Ensure that motion speed is changed smoothly\n      t = Autodesk.Viewing.Private.smootherStep(t);\n\n      this.currentState.lerp(this.startState, endState, t);\n      this.currentState.apply(this.viewer);\n    };\n\n    // Freeze current SceneAnimState and keep it as start for interpolation\n    this.startState.copyFrom(this.currentState);\n\n    return Autodesk.Viewing.Private.fadeValue(0, 1, animTime, onTimer, () => this.onAnimEnded());\n  }\n\n  // Immediately stop current animation at its current state. No-op if no animation is running\n  stopAnim() {\n    if (this.animControl && this.animControl.isRunning) {\n      this.animControl.stop();\n      this.animControl = null;\n    }\n  }\n\n  // Register new SceneState that we can animate to\n  registerState(stateName, sceneState) {\n    this.states[stateName] = sceneState;\n\n    // Make sure that currentState addresses all objects that are modified by the new SceneAnimState.\n    this.currentState.createObjectAnimStates(sceneState);\n  }\n\n  // Immediately apply a given animation state\n  setState(stateName) {\n    let state = this.states[stateName];\n    if (state) {\n      this.currentState.copyFrom(state);\n    } else {\n      // Recover shape transforms\n      this.currentState.resetTransforms();\n    }\n    this.currentState.apply(this.viewer);\n  }\n\n  onAnimEnded() {\n    //this should trigger ANIM_ENDED event\n    this.viewer.dispatchEvent({ type: Autodesk.Viewing.ANIM_ENDED });\n  }\n\n  // Ensures that no animation is active and all anim transform is being cleared for all fragments that we modified before.\n  reset() {\n    this.stopAnim();\n    this.currentState.resetTransforms();\n    this.currentState.apply(this.viewer);\n\n    // Drop all states to free some memory\n    this.currentState = new _AnimState_js__WEBPACK_IMPORTED_MODULE_0__.SceneAnimState();\n    this.states = {};\n    this.startState = new _AnimState_js__WEBPACK_IMPORTED_MODULE_0__.SceneAnimState();\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leHRlbnNpb25zL1Zpc3VhbENsdXN0ZXJzL0FuaW1Db250cm9sbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVnRDs7O0FBR2hEO0FBQ0E7QUFDQTtBQUNlLE1BQU1DLGNBQWMsQ0FBQzs7RUFFaENDLFdBQVdBLENBQUNDLE1BQU0sRUFBRTs7SUFFaEI7SUFDQSxJQUFJLENBQUNDLFlBQVksR0FBRyxJQUFJSix5REFBYyxDQUFDLENBQUM7O0lBRXhDO0lBQ0EsSUFBSSxDQUFDSyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7SUFFbEI7SUFDQSxJQUFJLENBQUNDLFVBQVUsR0FBRyxJQUFJTix5REFBYyxDQUFDLENBQUM7O0lBRXRDO0lBQ0EsSUFBSSxDQUFDRyxNQUFNLEdBQUdBLE1BQU07O0lBRXBCO0lBQ0EsSUFBSSxDQUFDSSxXQUFXLEdBQUcsSUFBSTtFQUMzQjs7RUFFQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBQyxTQUFTQSxDQUFBLEVBQW1DLEtBQWxDQyxTQUFTLEdBQUFDLFNBQUEsQ0FBQUMsTUFBQSxRQUFBRCxTQUFBLFFBQUFFLFNBQUEsR0FBQUYsU0FBQSxNQUFHLElBQUksS0FBRUcsUUFBUSxHQUFBSCxTQUFBLENBQUFDLE1BQUEsUUFBQUQsU0FBQSxRQUFBRSxTQUFBLEdBQUFGLFNBQUEsTUFBRyxHQUFHOztJQUV0QztJQUNBLElBQUksQ0FBQ0ksUUFBUSxDQUFDLENBQUM7O0lBRWYsTUFBTUMsUUFBUSxHQUFHLElBQUksQ0FBQ1YsTUFBTSxDQUFDSSxTQUFTLENBQUM7O0lBRXZDLE1BQU1PLE9BQU8sR0FBR0EsQ0FBQUMsQ0FBQyxLQUFJOztNQUVqQjtNQUNBQSxDQUFDLEdBQUdDLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDQyxPQUFPLENBQUNDLFlBQVksQ0FBQ0osQ0FBQyxDQUFDOztNQUU1QyxJQUFJLENBQUNiLFlBQVksQ0FBQ2tCLElBQUksQ0FBQyxJQUFJLENBQUNoQixVQUFVLEVBQUVTLFFBQVEsRUFBRUUsQ0FBQyxDQUFDO01BQ3BELElBQUksQ0FBQ2IsWUFBWSxDQUFDbUIsS0FBSyxDQUFDLElBQUksQ0FBQ3BCLE1BQU0sQ0FBQztJQUN4QyxDQUFDOztJQUVEO0lBQ0EsSUFBSSxDQUFDRyxVQUFVLENBQUNrQixRQUFRLENBQUMsSUFBSSxDQUFDcEIsWUFBWSxDQUFDOztJQUUzQyxPQUFPYyxRQUFRLENBQUNDLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDSyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRVosUUFBUSxFQUFFRyxPQUFPLEVBQUUsTUFBTSxJQUFJLENBQUNVLFdBQVcsQ0FBQyxDQUFDLENBQUM7RUFDaEc7O0VBRUE7RUFDQVosUUFBUUEsQ0FBQSxFQUFHO0lBQ1AsSUFBSSxJQUFJLENBQUNQLFdBQVcsSUFBSSxJQUFJLENBQUNBLFdBQVcsQ0FBQ29CLFNBQVMsRUFBRTtNQUNoRCxJQUFJLENBQUNwQixXQUFXLENBQUNxQixJQUFJLENBQUMsQ0FBQztNQUN2QixJQUFJLENBQUNyQixXQUFXLEdBQUcsSUFBSTtJQUMzQjtFQUNKOztFQUVBO0VBQ0FzQixhQUFhQSxDQUFDcEIsU0FBUyxFQUFFcUIsVUFBVSxFQUFFO0lBQ2pDLElBQUksQ0FBQ3pCLE1BQU0sQ0FBQ0ksU0FBUyxDQUFDLEdBQUdxQixVQUFVOztJQUVuQztJQUNBLElBQUksQ0FBQzFCLFlBQVksQ0FBQzJCLHNCQUFzQixDQUFDRCxVQUFVLENBQUM7RUFDeEQ7O0VBRUE7RUFDQUUsUUFBUUEsQ0FBQ3ZCLFNBQVMsRUFBRTtJQUNoQixJQUFJd0IsS0FBSyxHQUFHLElBQUksQ0FBQzVCLE1BQU0sQ0FBQ0ksU0FBUyxDQUFDO0lBQ2xDLElBQUl3QixLQUFLLEVBQUU7TUFDUCxJQUFJLENBQUM3QixZQUFZLENBQUNvQixRQUFRLENBQUNTLEtBQUssQ0FBQztJQUNyQyxDQUFDLE1BQU07TUFDSDtNQUNBLElBQUksQ0FBQzdCLFlBQVksQ0FBQzhCLGVBQWUsQ0FBQyxDQUFDO0lBQ3ZDO0lBQ0EsSUFBSSxDQUFDOUIsWUFBWSxDQUFDbUIsS0FBSyxDQUFDLElBQUksQ0FBQ3BCLE1BQU0sQ0FBQztFQUN4Qzs7RUFFQXVCLFdBQVdBLENBQUEsRUFBRztJQUNWO0lBQ0EsSUFBSSxDQUFDdkIsTUFBTSxDQUFDZ0MsYUFBYSxDQUFDLEVBQUVDLElBQUksRUFBRWxCLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDa0IsVUFBVSxDQUFDLENBQUMsQ0FBQztFQUNwRTs7RUFFQTtFQUNBQyxLQUFLQSxDQUFBLEVBQUc7SUFDSixJQUFJLENBQUN4QixRQUFRLENBQUMsQ0FBQztJQUNmLElBQUksQ0FBQ1YsWUFBWSxDQUFDOEIsZUFBZSxDQUFDLENBQUM7SUFDbkMsSUFBSSxDQUFDOUIsWUFBWSxDQUFDbUIsS0FBSyxDQUFDLElBQUksQ0FBQ3BCLE1BQU0sQ0FBQzs7SUFFcEM7SUFDQSxJQUFJLENBQUNDLFlBQVksR0FBRyxJQUFJSix5REFBYyxDQUFDLENBQUM7SUFDeEMsSUFBSSxDQUFDSyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ2hCLElBQUksQ0FBQ0MsVUFBVSxHQUFHLElBQUlOLHlEQUFjLENBQUMsQ0FBQztFQUMxQztBQUNKLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdXRvZGVzay5FeHRlbnNpb25zLy4vZXh0ZW5zaW9ucy9WaXN1YWxDbHVzdGVycy9BbmltQ29udHJvbGxlci5qcz9jZjRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vXG4vLyBDb250cm9scyBhbmltYXRpb25zIGJldHdlZW4gZGlmZmVyZW50IGFuaW1hdGlvbiBzdGF0ZXMuXG4vL1xuXG5pbXBvcnQgeyBTY2VuZUFuaW1TdGF0ZSB9IGZyb20gJy4vQW5pbVN0YXRlLmpzJztcblxuXG4vLyBBbiBBbmltQ29udHJvbGxlciBjb250YWlucyBtdWx0aXBsZSBzY2VuZSBhbmltYXRpb24gc3RhdGVzIGFuZCBjYW4gc21vb3RobHkgaW50ZXJwb2xhdGUgYmV0d2VlbiB0aG9zZS4gRWFjaCBzdGF0ZSBkZWZpbmVzIHRoZSBwb3NpdGlvbnMgZm9yIHNldmVyYWwgb2JqZWN0cy5cbi8vXG4vLyBFeGFtcGxlOiBUcmFuc2l0aW9uIGZyb20gXCJvcmlnaW5hbCBzaGFwZSBwb3NpdGlvbnNcIiB0byBcInNoYXBlcyBhcmUgZ3JvdXBlZCBieSBjYXRlZ29yaWVzXCIuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltQ29udHJvbGxlciB7XG5cbiAgICBjb25zdHJ1Y3Rvcih2aWV3ZXIpIHtcblxuICAgICAgICAvLyBEZXNjcmliZXMgYW5pbWF0aW9uIHN0YXRlIGF0IHRoZSBjdXJyZW50IHRpbWUuXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gbmV3IFNjZW5lQW5pbVN0YXRlKCk7XG5cbiAgICAgICAgLy8gRGlmZmVyZW50IHN0YXRlcyB0aGF0IHdlIGNhbiBpbnRlcnBvbGF0ZSBiZXR3ZWVuIC0gaW5kZXhlZCBieSBzdGF0ZU5hbWUuXG4gICAgICAgIHRoaXMuc3RhdGVzID0ge307IC8vIHN0cmluZyA9PiBTY2VuZUFuaW1TdGF0ZVxuXG4gICAgICAgIC8vIEFuaW1hdGlvbiBzdGF0ZSBhdCB0aGUgcG9pbnQgd2hlbiB0aGUgbGFzdCBhbmltYXRpb24gaGFkIHN0YXJ0ZWRcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlID0gbmV3IFNjZW5lQW5pbVN0YXRlKCk7XG5cbiAgICAgICAgLy8ge1ZpZXdlcjNEfVxuICAgICAgICB0aGlzLnZpZXdlciA9IHZpZXdlcjtcblxuICAgICAgICAvLyBVc2VkIHRvIGludGVycnVwdCBydW5uaW5nIGluLXByb2dyZXNzIGFuaW1hdGlvbnNcbiAgICAgICAgdGhpcy5hbmltQ29udHJvbCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgYW5pbWF0aW9uIHRvIGEgdGFyZ2V0IHN0YXRlLlxuICAgIC8vXG4gICAgLy8gQHBhcmFtIHtzdHJpbmd9IFtzdGF0ZU5hbWVdIC0gQSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgc3RhdGVOYW1lIG9yIG51bGwuIE51bGwgcmV0dXJucyB0byBvcmlnaW5hbCBzaGFwZSBwb3NpdGlvbnMuXG4gICAgLy9cbiAgICAvLyBAcmV0dXJucyB7QW5pbUNvbnRyb2x9IENvbnRyb2wgaW4tcHJvZ3Jlc3MgYW5pbWF0aW9uLi5cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbC5zdG9wKCk6IHRvIGludGVycnVwdCBpdC5cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbC5pc1J1bm5pbmcoKTogdG8gY2hlY2sgd2hldGhlciBpdCBpcyBpbiBwcm9ncmVzcy5cbiAgICBhbmltYXRlVG8oc3RhdGVOYW1lID0gbnVsbCwgYW5pbVRpbWUgPSAyLjApIHtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBydW4gYW55IHByZXZpb3VzIGFuaW1hdGlvbiBjb25jdXJyZW50bHlcbiAgICAgICAgdGhpcy5zdG9wQW5pbSgpO1xuXG4gICAgICAgIGNvbnN0IGVuZFN0YXRlID0gdGhpcy5zdGF0ZXNbc3RhdGVOYW1lXTtcblxuICAgICAgICBjb25zdCBvblRpbWVyID0gdCA9PiB7XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IG1vdGlvbiBzcGVlZCBpcyBjaGFuZ2VkIHNtb290aGx5XG4gICAgICAgICAgICB0ID0gQXV0b2Rlc2suVmlld2luZy5Qcml2YXRlLnNtb290aGVyU3RlcCh0KTtcblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUubGVycCh0aGlzLnN0YXJ0U3RhdGUsIGVuZFN0YXRlLCB0KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRlLmFwcGx5KHRoaXMudmlld2VyKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBGcmVlemUgY3VycmVudCBTY2VuZUFuaW1TdGF0ZSBhbmQga2VlcCBpdCBhcyBzdGFydCBmb3IgaW50ZXJwb2xhdGlvblxuICAgICAgICB0aGlzLnN0YXJ0U3RhdGUuY29weUZyb20odGhpcy5jdXJyZW50U3RhdGUpO1xuXG4gICAgICAgIHJldHVybiBBdXRvZGVzay5WaWV3aW5nLlByaXZhdGUuZmFkZVZhbHVlKDAsIDEsIGFuaW1UaW1lLCBvblRpbWVyLCAoKSA9PiB0aGlzLm9uQW5pbUVuZGVkKCkpO1xuICAgIH1cblxuICAgIC8vIEltbWVkaWF0ZWx5IHN0b3AgY3VycmVudCBhbmltYXRpb24gYXQgaXRzIGN1cnJlbnQgc3RhdGUuIE5vLW9wIGlmIG5vIGFuaW1hdGlvbiBpcyBydW5uaW5nXG4gICAgc3RvcEFuaW0oKSB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1Db250cm9sICYmIHRoaXMuYW5pbUNvbnRyb2wuaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1Db250cm9sLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuYW5pbUNvbnRyb2wgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVnaXN0ZXIgbmV3IFNjZW5lU3RhdGUgdGhhdCB3ZSBjYW4gYW5pbWF0ZSB0b1xuICAgIHJlZ2lzdGVyU3RhdGUoc3RhdGVOYW1lLCBzY2VuZVN0YXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGVzW3N0YXRlTmFtZV0gPSBzY2VuZVN0YXRlO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGN1cnJlbnRTdGF0ZSBhZGRyZXNzZXMgYWxsIG9iamVjdHMgdGhhdCBhcmUgbW9kaWZpZWQgYnkgdGhlIG5ldyBTY2VuZUFuaW1TdGF0ZS5cbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUuY3JlYXRlT2JqZWN0QW5pbVN0YXRlcyhzY2VuZVN0YXRlKTtcbiAgICB9XG5cbiAgICAvLyBJbW1lZGlhdGVseSBhcHBseSBhIGdpdmVuIGFuaW1hdGlvbiBzdGF0ZVxuICAgIHNldFN0YXRlKHN0YXRlTmFtZSkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnN0YXRlc1tzdGF0ZU5hbWVdO1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRlLmNvcHlGcm9tKHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlY292ZXIgc2hhcGUgdHJhbnNmb3Jtc1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUucmVzZXRUcmFuc2Zvcm1zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUuYXBwbHkodGhpcy52aWV3ZXIpO1xuICAgIH1cblxuICAgIG9uQW5pbUVuZGVkKCkge1xuICAgICAgICAvL3RoaXMgc2hvdWxkIHRyaWdnZXIgQU5JTV9FTkRFRCBldmVudFxuICAgICAgICB0aGlzLnZpZXdlci5kaXNwYXRjaEV2ZW50KHsgdHlwZTogQXV0b2Rlc2suVmlld2luZy5BTklNX0VOREVEIH0pO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZXMgdGhhdCBubyBhbmltYXRpb24gaXMgYWN0aXZlIGFuZCBhbGwgYW5pbSB0cmFuc2Zvcm0gaXMgYmVpbmcgY2xlYXJlZCBmb3IgYWxsIGZyYWdtZW50cyB0aGF0IHdlIG1vZGlmaWVkIGJlZm9yZS5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zdG9wQW5pbSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZS5yZXNldFRyYW5zZm9ybXMoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUuYXBwbHkodGhpcy52aWV3ZXIpO1xuXG4gICAgICAgIC8vIERyb3AgYWxsIHN0YXRlcyB0byBmcmVlIHNvbWUgbWVtb3J5XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gbmV3IFNjZW5lQW5pbVN0YXRlKCk7XG4gICAgICAgIHRoaXMuc3RhdGVzID0ge307XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IG5ldyBTY2VuZUFuaW1TdGF0ZSgpO1xuICAgIH1cbn07XG4iXSwibmFtZXMiOlsiU2NlbmVBbmltU3RhdGUiLCJBbmltQ29udHJvbGxlciIsImNvbnN0cnVjdG9yIiwidmlld2VyIiwiY3VycmVudFN0YXRlIiwic3RhdGVzIiwic3RhcnRTdGF0ZSIsImFuaW1Db250cm9sIiwiYW5pbWF0ZVRvIiwic3RhdGVOYW1lIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiYW5pbVRpbWUiLCJzdG9wQW5pbSIsImVuZFN0YXRlIiwib25UaW1lciIsInQiLCJBdXRvZGVzayIsIlZpZXdpbmciLCJQcml2YXRlIiwic21vb3RoZXJTdGVwIiwibGVycCIsImFwcGx5IiwiY29weUZyb20iLCJmYWRlVmFsdWUiLCJvbkFuaW1FbmRlZCIsImlzUnVubmluZyIsInN0b3AiLCJyZWdpc3RlclN0YXRlIiwic2NlbmVTdGF0ZSIsImNyZWF0ZU9iamVjdEFuaW1TdGF0ZXMiLCJzZXRTdGF0ZSIsInN0YXRlIiwicmVzZXRUcmFuc2Zvcm1zIiwiZGlzcGF0Y2hFdmVudCIsInR5cGUiLCJBTklNX0VOREVEIiwicmVzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./extensions/VisualClusters/AnimController.js\n");

                /***/
            }),

        /***/
        "./extensions/VisualClusters/AnimState.js":
            /*!************************************************!*\
              !*** ./extensions/VisualClusters/AnimState.js ***!
              \************************************************/
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ModelAnimState: () => (/* binding */ ModelAnimState),\n/* harmony export */   ObjectAnimState: () => (/* binding */ ObjectAnimState),\n/* harmony export */   SceneAnimState: () => (/* binding */ SceneAnimState)\n/* harmony export */ });\n// Contains classes to control the animation state of animation for objects of one or more models.\n\nconst tmpMatrix = new THREE.Matrix4();\nconst tmpVec1 = new THREE.Vector3();\n\n// Get translation offset that is needed to make the given\n// point center of the rotation.\n//  @param {Quaternion} rotation\n//  @param {Vector3}    center\n//  @param {Vecotr3}    [optionalTarget]\n//  @returns {THREE.Vector3}\nconst getRotationOffset = (rotation, center, optionalTarget) => {\n\n  const result = optionalTarget || new THREE.Vector3();\n\n  // get rotation as matrix\n  let rotMatrix = tmpMatrix.makeRotationFromQuaternion(rotation);\n\n  // Compute where center would be moved when just applying rotation alone\n  const p = center.clone().applyMatrix4(rotMatrix);\n\n  // Return correction offset to bring center back at its original position\n  return result.copy(center).sub(p);\n};\n\n// Describes an animation transform to be applied to single object. \n// Note that placement is relative to original position, i.e., identity means shape appears at original position.\nclass ObjectAnimState {\n\n  constructor(dbId) {\n\n    // id of the object being animated\n    this.dbId = dbId;\n\n    // translation\n    this.move = new THREE.Vector3(0, 0, 0);\n\n    // scale\n    this.scale = new THREE.Vector3(1, 1, 1);\n\n    // rotation (as Quaternion)\n    //\n    // Note: Note that fragment animTransforms always rotate around the world origin, \n    //       because the original matrix is applied first.\n    this.rot = new THREE.Quaternion();\n\n    // By default, fragment rotations in LMV rotate around the world-origin.\n    this.rotCenter = new THREE.Vector3(0, 0, 0);\n  }\n\n  apply(model) {\n\n    const fragList = model.getFragmentList();\n    const it = model.getInstanceTree();\n\n    // Apply additional correction offset when rotating around a center != origin.\n    // Note that rotations set by updateAnimTransform always rotate around world origin.\n    const move = getRotationOffset(this.rot, this.rotCenter, tmpVec1).add(this.move);\n\n    // Update fragment animation transforms\n    it.enumNodeFragments(this.dbId, (fragId) => {\n      fragList.updateAnimTransform(fragId, this.scale, this.rot, move);\n    });\n  }\n\n  // Set this placement by interpolating between a start and end placement\n  //  @param {ItemPlacement} start, end - If null, we assume identity transform.\n  //  @param {number}        t          - interpolation param in [0,1]\n  lerp(start, end, t) {\n\n    // use identiy transform if start or end is missing\n    start = start || ObjectAnimState.Identity;\n    end = end || ObjectAnimState.Identity;\n\n    // Interpolate move/scale/rotation\n    this.move.lerpVectors(start.move, end.move, t);\n    this.scale.lerpVectors(start.scale, end.scale, t);\n    this.rotCenter.lerpVectors(start.rotCenter, end.rotCenter, t);\n    this.rot.slerpQuaternions(start.rot, end.rot, t);\n  }\n\n  copyFrom(src) {\n    this.dbId = src.dbId;\n    this.move.copy(src.move);\n    this.scale.copy(src.scale);\n    this.rot.copy(src.rot);\n    this.rotCenter.copy(src.rotCenter);\n  }\n\n  resetTransform() {\n    this.move.set(0, 0, 0);\n    this.scale.set(1, 1, 1);\n    this.rot.set(0, 0, 0, 1); // = identity Quaternion\n    this.rotCenter.set(0, 0, 0);\n  }\n\n  // Set rotation center. \n  // @param {Vector3} center\n  // @param {bool}    ajdustMove - If true, the move vector is changed so that the effect of the AnimState keeps the same.\n  setRotationCenter(newCenter, adjustMove) {\n\n    // Adjust translation offset to keep position\n    if (adjustMove) {\n\n      // Compute the shift that the shape position would do without move adjustment.\n      // This could be optimized by avoiding double-computation of the rotation matrix.\n      const oldOffset = getRotationOffset(this.rot, this.rotCenter);\n      const newOffset = getRotationOffset(this.rot, newCenter);\n\n      // Modify translation to eliminate the position shift\n      this.move.add(oldOffset).sub(newOffset);\n    }\n\n    // Change rotationCenter\n    this.rotCenter.copy(newCenter);\n  }\n}\n\n// Represents the original state of an object when no anim transform is applied.\nObjectAnimState.Identity = new ObjectAnimState(-1);\n\n// Describes animation transforms for a set of objects within the same RenderModel\nclass ModelAnimState {\n\n  constructor(model) {\n\n    this.model = model;\n\n    // Indexed by dbId.\n    this.animStates = []; // ObjectAnimState[]\n  }\n\n  apply() {\n    for (var dbId in this.animStates) {\n      this.animStates[dbId].apply(this.model);\n    }\n\n    // Make sure that hierarchical bboxes are updated\n    this.model.visibleBoundsDirty = true;\n  }\n\n  // Finds or creates an animState for the given dbId.\n  //  @param {number}          dbId\n  //  @param {ObjectAnimState} animState\n  setAnimState(dbId, animState) {\n    this.animStates[dbId] = animState;\n  }\n\n  getAnimState(dbId) {let createIfMissing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    let animState = this.animStates[dbId];\n\n    // Create new one if needed\n    if (!animState && createIfMissing) {\n      animState = new ObjectAnimState(dbId);\n      this.setAnimState(dbId, animState);\n    }\n\n    return animState;\n  }\n\n  // Adds new ObjectAnimStates for all dbIds in srcState.\n  //\n  // This is important if you use this to interpolate between other ModelStates and want to make sure that this ModelState\n  // affects all dbIds that are affected either by startState or endState.\n  //\n  // @param {ModelAnimState} srcState\n  createObjctAnimStates(srcState) {\n    for (let key in srcState.animStates) {\n\n      // Note that key is the dbId as string. \n      // => Use the integer variant from srcState instead.\n      const dbId = srcState.animStates[key].dbId;\n\n      // Make sure that we have an ObjectAnimState for this dbId\n      this.getAnimState(dbId, true);\n    }\n  }\n\n  // Prepares this ModelState to interpolate between two others:\n  // For this, we make sure that this ModelState affects all dbIds that are modified by either start or end.\n  prepareLerp(start, end) {\n    this.createObjectAnimStates(start);\n    this.createObjectAnimStates(end);\n  }\n\n  // Updates all ObjectAnimStates by interpolating between a start and end anim state.\n  //\n  // Note: This only affects the existing ObjectAnimStates within this ModelAnimState.\n  //       It does NOT create new AnimStates. See prepareLerp()\n  // \n  //  @param {ModelAnimState} start, end - may be null (= original state)\n  //  @param {number}         t          - interpolation param in [0,1]\n  lerp(start, end, t) {\n    for (let dbId in this.animStates) {\n      const objStart = start && start.animStates[dbId];\n      const objEnd = end && end.animStates[dbId];\n      this.animStates[dbId].lerp(objStart, objEnd, t);\n    }\n  }\n\n  copyFrom(src) {\n\n    this.model = src.model;\n\n    // Make sure that we set the same ObjectAnimStates as src.\n    // Avoid re-allocations if possible.\n    for (let dbId in src.animStates) {\n      // get or create state\n      const srcObj = src.animStates[dbId];\n      const dstObj = this.getAnimState(dbId, true);\n      dstObj.copyFrom(srcObj);\n    }\n\n    // Clean all object animStates that src doesn't have\n    for (let dbId in this.animStates) {\n      if (!src.animStates[dbId]) {\n        delete this.animStates[dbId];\n      }\n    }\n  }\n\n  // Reset anim transforms for all fragments that were modified by this state\n  resetTransforms() {\n    for (let dbId in this.animStates) {\n      this.animStates[dbId].resetTransform();\n    }\n  }\n}\n\n// Describes animations for several objects within a scene composed from multiple models.\nclass SceneAnimState {\n\n  constructor(models) {\n\n    // ModelAnimState[] - indexed by modelId\n    this.animStates = [];\n\n    // Create a model placement for each model, indexed by modelId\n    models && models.forEach((m) => this.animStates[m.id] = new ModelAnimState(m));\n  }\n\n  apply(viewer) {\n    // Apply all model anim states\n    for (let modelId in this.animStates) {\n      this.animStates[modelId].apply();\n    }\n\n    // Force re-render\n    viewer.impl.invalidate(true, true, true);\n  }\n\n  // Set animation state for a single object\n  // Note that modelId must be the id of one of the models used for construction\n  setAnimState(modelId, dbId, animState) {\n    this.animStates[modelId].setAnimState(dbId, animState);\n  }\n\n  // Adds new ObjectAnimStates for all dbIds in srcState.\n  // see ModelAnimState.createObjectAnimStates for details.\n  //\n  // @param {ModelAnimState} srcState\n  createObjectAnimStates(srcState) {\n    for (let modelId in srcState.animStates) {\n      // get src ModelAnimState\n      const src = srcState.animStates[modelId];\n\n      // Get or create target ModelState for this model\n      let dst = this.animStates[modelId];\n      if (!dst) {\n        dst = new ModelAnimState(src.model);\n        this.animStates[modelId] = dst;\n      }\n\n      // Make sure that this ModelState operates on the same dbIds as src\n      dst.createObjctAnimStates(src);\n    }\n  }\n\n  // Prepares this SceneAnimState to interpolate between two others:\n  // For this, we make sure that this SceneAnimState affects all dbIds that are modified by either start or end.\n  //  @param {SceneAnimState} start, end\n  prepareLerp(start, end) {\n    this.createObjctAnimStates(start);\n    this.createObjctAnimStates(end);\n  }\n\n  // Set this placement by interpolating between a start and end placement\n  // Note:\n  //  - All placements must refer to the same list of models\n  //  - For each model, all placements must enlist the same dbIds\n  // \n  //  @param {ScenePlacement} start, end\n  //  @param {number}         t          - interpolation param in [0,1]\n  lerp(start, end, t) {\n    for (let modelId in this.animStates) {\n      const modelStart = start && start.animStates[modelId];\n      const modelEnd = end && end.animStates[modelId];\n      this.animStates[modelId].lerp(modelStart, modelEnd, t);\n    }\n  }\n\n  // Makes this SceneState equal to the src state.\n  copyFrom(srcState) {\n\n    for (let modelId in srcState.animStates) {\n      const src = srcState.animStates[modelId];\n      let dst = this.animStates[modelId];\n\n      // In case we don't have a ModelState for this model, create one\n      if (!dst) {\n        dst = new ModelAnimState(src.model);\n        this.animStates[modelId] = dst;\n      }\n\n      dst.copyFrom(src);\n    }\n\n    // Erase any modelState that src doesn't have\n    for (let modelId in this.animStates) {\n      if (!srcState.animStates[modelId]) {\n        delete this.animStates[modelId];\n      }\n    }\n  }\n\n  // Reset anim transforms for all fragments that were modified by this state\n  resetTransforms() {\n    for (let modelId in this.animStates) {\n      this.animStates[modelId].resetTransforms();\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leHRlbnNpb25zL1Zpc3VhbENsdXN0ZXJzL0FuaW1TdGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7QUFFQSxNQUFNQSxTQUFTLEdBQUcsSUFBSUMsS0FBSyxDQUFDQyxPQUFPLENBQUMsQ0FBQztBQUNyQyxNQUFNQyxPQUFPLEdBQUcsSUFBSUYsS0FBSyxDQUFDRyxPQUFPLENBQUMsQ0FBQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsaUJBQWlCLEdBQUdBLENBQUNDLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxjQUFjLEtBQUs7O0VBRTVELE1BQU1DLE1BQU0sR0FBR0QsY0FBYyxJQUFJLElBQUlQLEtBQUssQ0FBQ0csT0FBTyxDQUFDLENBQUM7O0VBRXBEO0VBQ0EsSUFBSU0sU0FBUyxHQUFHVixTQUFTLENBQUNXLDBCQUEwQixDQUFDTCxRQUFRLENBQUM7O0VBRTlEO0VBQ0EsTUFBTU0sQ0FBQyxHQUFHTCxNQUFNLENBQUNNLEtBQUssQ0FBQyxDQUFDLENBQUNDLFlBQVksQ0FBQ0osU0FBUyxDQUFDOztFQUVoRDtFQUNBLE9BQU9ELE1BQU0sQ0FBQ00sSUFBSSxDQUFDUixNQUFNLENBQUMsQ0FBQ1MsR0FBRyxDQUFDSixDQUFDLENBQUM7QUFDckMsQ0FBQzs7QUFFRDtBQUNBO0FBQ08sTUFBTUssZUFBZSxDQUFDOztFQUV6QkMsV0FBV0EsQ0FBQ0MsSUFBSSxFQUFFOztJQUVkO0lBQ0EsSUFBSSxDQUFDQSxJQUFJLEdBQUdBLElBQUk7O0lBRWhCO0lBQ0EsSUFBSSxDQUFDQyxJQUFJLEdBQUcsSUFBSW5CLEtBQUssQ0FBQ0csT0FBTyxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDOztJQUVwQztJQUNBLElBQUksQ0FBQ2lCLEtBQUssR0FBRyxJQUFJcEIsS0FBSyxDQUFDRyxPQUFPLENBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUM7O0lBRXJDO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsSUFB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QUFDOztNQUVwQztNQUNBLElBQUksQ0FBQ0csR0FBRyxFQUFFO1FBQ05BLEdBQUcsR0FBRyxJQUFJN0IsY0FBYyxDQUFDUixHQUFHLENBQUNqQixLQUFLLENBQUM7UUFDbkMsSUFBSSxDQUFDMEIsVUFBVSxDQUFDeUIsT0FBTyxDQUFDLEdBQUdHLEdBQUc7TUFDbEM7O01BRUFBLEdBQUcsQ0FBQ3RDLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDO0lBQ3JCOztJQUVBO0lBQ0EsS0FBSyxJQUFJa0MsT0FBTyxJQUFJLElBQUksQ0FBQ3pCLFVBQVUsRUFBRTtNQUNqQyxJQUFJLENBQUNVLFFBQVEsQ0FBQ1YsVUFBVSxDQUFDeUIsT0FBTyxDQUFDLEVBQUU7UUFDL0IsT0FBTyxJQUFJLENBQUN6QixVQUFVLENBQUN5QixPQUFPLENBQUM7TUFDbkM7SUFDSjtFQUNKOztFQUVBO0VBQ0FQLGVBQWVBLENBQUEsRUFBRztJQUNkLEtBQUssSUFBSU8sT0FBTyxJQUFJLElBQUksQ0FBQ3pCLFVBQVUsRUFBRTtNQUNqQyxJQUFJLENBQUNBLFVBQVUsQ0FBQ3lCLE9BQU8sQ0FBQyxDQUFDUCxlQUFlLENBQUMsQ0FBQztJQUM5QztFQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdXRvZGVzay5FeHRlbnNpb25zLy4vZXh0ZW5zaW9ucy9WaXN1YWxDbHVzdGVycy9BbmltU3RhdGUuanM/NjYwMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb250YWlucyBjbGFzc2VzIHRvIGNvbnRyb2wgdGhlIGFuaW1hdGlvbiBzdGF0ZSBvZiBhbmltYXRpb24gZm9yIG9iamVjdHMgb2Ygb25lIG9yIG1vcmUgbW9kZWxzLlxuXG5jb25zdCB0bXBNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuY29uc3QgdG1wVmVjMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbi8vIEdldCB0cmFuc2xhdGlvbiBvZmZzZXQgdGhhdCBpcyBuZWVkZWQgdG8gbWFrZSB0aGUgZ2l2ZW5cbi8vIHBvaW50IGNlbnRlciBvZiB0aGUgcm90YXRpb24uXG4vLyAgQHBhcmFtIHtRdWF0ZXJuaW9ufSByb3RhdGlvblxuLy8gIEBwYXJhbSB7VmVjdG9yM30gICAgY2VudGVyXG4vLyAgQHBhcmFtIHtWZWNvdHIzfSAgICBbb3B0aW9uYWxUYXJnZXRdXG4vLyAgQHJldHVybnMge1RIUkVFLlZlY3RvcjN9XG5jb25zdCBnZXRSb3RhdGlvbk9mZnNldCA9IChyb3RhdGlvbiwgY2VudGVyLCBvcHRpb25hbFRhcmdldCkgPT4ge1xuXG4gICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBcbiAgICAvLyBnZXQgcm90YXRpb24gYXMgbWF0cml4XG4gICAgbGV0IHJvdE1hdHJpeCA9IHRtcE1hdHJpeC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihyb3RhdGlvbik7XG4gICAgXG4gICAgLy8gQ29tcHV0ZSB3aGVyZSBjZW50ZXIgd291bGQgYmUgbW92ZWQgd2hlbiBqdXN0IGFwcGx5aW5nIHJvdGF0aW9uIGFsb25lXG4gICAgY29uc3QgcCA9IGNlbnRlci5jbG9uZSgpLmFwcGx5TWF0cml4NChyb3RNYXRyaXgpO1xuXG4gICAgLy8gUmV0dXJuIGNvcnJlY3Rpb24gb2Zmc2V0IHRvIGJyaW5nIGNlbnRlciBiYWNrIGF0IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuICAgIHJldHVybiByZXN1bHQuY29weShjZW50ZXIpLnN1YihwKTtcbn07XG5cbi8vIERlc2NyaWJlcyBhbiBhbmltYXRpb24gdHJhbnNmb3JtIHRvIGJlIGFwcGxpZWQgdG8gc2luZ2xlIG9iamVjdC4gXG4vLyBOb3RlIHRoYXQgcGxhY2VtZW50IGlzIHJlbGF0aXZlIHRvIG9yaWdpbmFsIHBvc2l0aW9uLCBpLmUuLCBpZGVudGl0eSBtZWFucyBzaGFwZSBhcHBlYXJzIGF0IG9yaWdpbmFsIHBvc2l0aW9uLlxuZXhwb3J0IGNsYXNzIE9iamVjdEFuaW1TdGF0ZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihkYklkKSB7XG5cbiAgICAgICAgLy8gaWQgb2YgdGhlIG9iamVjdCBiZWluZyBhbmltYXRlZFxuICAgICAgICB0aGlzLmRiSWQgPSBkYklkO1xuXG4gICAgICAgIC8vIHRyYW5zbGF0aW9uXG4gICAgICAgIHRoaXMubW92ZSA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsMCwwKTtcblxuICAgICAgICAvLyBzY2FsZVxuICAgICAgICB0aGlzLnNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoMSwxLDEpO1xuXG4gICAgICAgIC8vIHJvdGF0aW9uIChhcyBRdWF0ZXJuaW9uKVxuICAgICAgICAvL1xuICAgICAgICAvLyBOb3RlOiBOb3RlIHRoYXQgZnJhZ21lbnQgYW5pbVRyYW5zZm9ybXMgYWx3YXlzIHJvdGF0ZSBhcm91bmQgdGhlIHdvcmxkIG9yaWdpbiwgXG4gICAgICAgIC8vICAgICAgIGJlY2F1c2UgdGhlIG9yaWdpbmFsIG1hdHJpeCBpcyBhcHBsaWVkIGZpcnN0LlxuICAgICAgICB0aGlzLnJvdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgZnJhZ21lbnQgcm90YXRpb25zIGluIExNViByb3RhdGUgYXJvdW5kIHRoZSB3b3JsZC1vcmlnaW4uXG4gICAgICAgIHRoaXMucm90Q2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwwLDApO1xuICAgIH1cblxuICAgIGFwcGx5KG1vZGVsKSB7XG5cbiAgICAgICAgY29uc3QgZnJhZ0xpc3QgPSBtb2RlbC5nZXRGcmFnbWVudExpc3QoKTtcbiAgICAgICAgY29uc3QgaXQgPSBtb2RlbC5nZXRJbnN0YW5jZVRyZWUoKTtcblxuICAgICAgICAvLyBBcHBseSBhZGRpdGlvbmFsIGNvcnJlY3Rpb24gb2Zmc2V0IHdoZW4gcm90YXRpbmcgYXJvdW5kIGEgY2VudGVyICE9IG9yaWdpbi5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHJvdGF0aW9ucyBzZXQgYnkgdXBkYXRlQW5pbVRyYW5zZm9ybSBhbHdheXMgcm90YXRlIGFyb3VuZCB3b3JsZCBvcmlnaW4uXG4gICAgICAgIGNvbnN0IG1vdmUgPSBnZXRSb3RhdGlvbk9mZnNldCh0aGlzLnJvdCwgdGhpcy5yb3RDZW50ZXIsIHRtcFZlYzEpLmFkZCh0aGlzLm1vdmUpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBmcmFnbWVudCBhbmltYXRpb24gdHJhbnNmb3Jtc1xuICAgICAgICBpdC5lbnVtTm9kZUZyYWdtZW50cyh0aGlzLmRiSWQsIGZyYWdJZCA9PiB7XG4gICAgICAgICAgICBmcmFnTGlzdC51cGRhdGVBbmltVHJhbnNmb3JtKGZyYWdJZCwgdGhpcy5zY2FsZSwgdGhpcy5yb3QsIG1vdmUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhpcyBwbGFjZW1lbnQgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIGEgc3RhcnQgYW5kIGVuZCBwbGFjZW1lbnRcbiAgICAvLyAgQHBhcmFtIHtJdGVtUGxhY2VtZW50fSBzdGFydCwgZW5kIC0gSWYgbnVsbCwgd2UgYXNzdW1lIGlkZW50aXR5IHRyYW5zZm9ybS5cbiAgICAvLyAgQHBhcmFtIHtudW1iZXJ9ICAgICAgICB0ICAgICAgICAgIC0gaW50ZXJwb2xhdGlvbiBwYXJhbSBpbiBbMCwxXVxuICAgIGxlcnAoc3RhcnQsIGVuZCwgdCkge1xuICAgICAgICBcbiAgICAgICAgLy8gdXNlIGlkZW50aXkgdHJhbnNmb3JtIGlmIHN0YXJ0IG9yIGVuZCBpcyBtaXNzaW5nXG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgfHwgT2JqZWN0QW5pbVN0YXRlLklkZW50aXR5O1xuICAgICAgICBlbmQgICA9IGVuZCAgIHx8IE9iamVjdEFuaW1TdGF0ZS5JZGVudGl0eTtcblxuICAgICAgICAvLyBJbnRlcnBvbGF0ZSBtb3ZlL3NjYWxlL3JvdGF0aW9uXG4gICAgICAgIHRoaXMubW92ZS5sZXJwVmVjdG9ycyhzdGFydC5tb3ZlLCBlbmQubW92ZSwgdCk7XG4gICAgICAgIHRoaXMuc2NhbGUubGVycFZlY3RvcnMoc3RhcnQuc2NhbGUsIGVuZC5zY2FsZSwgdCk7XG4gICAgICAgIHRoaXMucm90Q2VudGVyLmxlcnBWZWN0b3JzKHN0YXJ0LnJvdENlbnRlciwgZW5kLnJvdENlbnRlciwgdCk7XG4gICAgICAgIHRoaXMucm90LnNsZXJwUXVhdGVybmlvbnMoc3RhcnQucm90LCBlbmQucm90LCB0KTtcbiAgICB9XG5cbiAgICBjb3B5RnJvbShzcmMpIHtcbiAgICAgICAgdGhpcy5kYklkID0gc3JjLmRiSWQ7XG4gICAgICAgIHRoaXMubW92ZS5jb3B5KHNyYy5tb3ZlKTtcbiAgICAgICAgdGhpcy5zY2FsZS5jb3B5KHNyYy5zY2FsZSk7XG4gICAgICAgIHRoaXMucm90LmNvcHkoc3JjLnJvdCk7XG4gICAgICAgIHRoaXMucm90Q2VudGVyLmNvcHkoc3JjLnJvdENlbnRlcik7XG4gICAgfVxuXG4gICAgcmVzZXRUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHRoaXMubW92ZS5zZXQoMCwwLDApO1xuICAgICAgICB0aGlzLnNjYWxlLnNldCgxLDEsMSk7XG4gICAgICAgIHRoaXMucm90LnNldCgwLDAsMCwxKTsgLy8gPSBpZGVudGl0eSBRdWF0ZXJuaW9uXG4gICAgICAgIHRoaXMucm90Q2VudGVyLnNldCgwLDAsMCk7XG4gICAgfVxuXG4gICAgLy8gU2V0IHJvdGF0aW9uIGNlbnRlci4gXG4gICAgLy8gQHBhcmFtIHtWZWN0b3IzfSBjZW50ZXJcbiAgICAvLyBAcGFyYW0ge2Jvb2x9ICAgIGFqZHVzdE1vdmUgLSBJZiB0cnVlLCB0aGUgbW92ZSB2ZWN0b3IgaXMgY2hhbmdlZCBzbyB0aGF0IHRoZSBlZmZlY3Qgb2YgdGhlIEFuaW1TdGF0ZSBrZWVwcyB0aGUgc2FtZS5cbiAgICBzZXRSb3RhdGlvbkNlbnRlcihuZXdDZW50ZXIsIGFkanVzdE1vdmUpIHtcblxuICAgICAgICAvLyBBZGp1c3QgdHJhbnNsYXRpb24gb2Zmc2V0IHRvIGtlZXAgcG9zaXRpb25cbiAgICAgICAgaWYgKGFkanVzdE1vdmUpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgc2hpZnQgdGhhdCB0aGUgc2hhcGUgcG9zaXRpb24gd291bGQgZG8gd2l0aG91dCBtb3ZlIGFkanVzdG1lbnQuXG4gICAgICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIG9wdGltaXplZCBieSBhdm9pZGluZyBkb3VibGUtY29tcHV0YXRpb24gb2YgdGhlIHJvdGF0aW9uIG1hdHJpeC5cbiAgICAgICAgICAgIGNvbnN0IG9sZE9mZnNldCA9IGdldFJvdGF0aW9uT2Zmc2V0KHRoaXMucm90LCB0aGlzLnJvdENlbnRlcik7XG4gICAgICAgICAgICBjb25zdCBuZXdPZmZzZXQgPSBnZXRSb3RhdGlvbk9mZnNldCh0aGlzLnJvdCwgbmV3Q2VudGVyKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTW9kaWZ5IHRyYW5zbGF0aW9uIHRvIGVsaW1pbmF0ZSB0aGUgcG9zaXRpb24gc2hpZnRcbiAgICAgICAgICAgIHRoaXMubW92ZS5hZGQob2xkT2Zmc2V0KS5zdWIobmV3T2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoYW5nZSByb3RhdGlvbkNlbnRlclxuICAgICAgICB0aGlzLnJvdENlbnRlci5jb3B5KG5ld0NlbnRlcik7XG4gICAgfVxufVxuXG4vLyBSZXByZXNlbnRzIHRoZSBvcmlnaW5hbCBzdGF0ZSBvZiBhbiBvYmplY3Qgd2hlbiBubyBhbmltIHRyYW5zZm9ybSBpcyBhcHBsaWVkLlxuT2JqZWN0QW5pbVN0YXRlLklkZW50aXR5ID0gbmV3IE9iamVjdEFuaW1TdGF0ZSgtMSk7XG5cbi8vIERlc2NyaWJlcyBhbmltYXRpb24gdHJhbnNmb3JtcyBmb3IgYSBzZXQgb2Ygb2JqZWN0cyB3aXRoaW4gdGhlIHNhbWUgUmVuZGVyTW9kZWxcbmV4cG9ydCBjbGFzcyBNb2RlbEFuaW1TdGF0ZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcblxuICAgICAgICAvLyBJbmRleGVkIGJ5IGRiSWQuXG4gICAgICAgIHRoaXMuYW5pbVN0YXRlcyA9IFtdOyAvLyBPYmplY3RBbmltU3RhdGVbXVxuICAgIH1cblxuICAgIGFwcGx5KCkge1xuICAgICAgICBmb3IgKHZhciBkYklkIGluIHRoaXMuYW5pbVN0YXRlcykge1xuICAgICAgICAgICAgdGhpcy5hbmltU3RhdGVzW2RiSWRdLmFwcGx5KHRoaXMubW9kZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgaGllcmFyY2hpY2FsIGJib3hlcyBhcmUgdXBkYXRlZFxuICAgICAgICB0aGlzLm1vZGVsLnZpc2libGVCb3VuZHNEaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmluZHMgb3IgY3JlYXRlcyBhbiBhbmltU3RhdGUgZm9yIHRoZSBnaXZlbiBkYklkLlxuICAgIC8vICBAcGFyYW0ge251bWJlcn0gICAgICAgICAgZGJJZFxuICAgIC8vICBAcGFyYW0ge09iamVjdEFuaW1TdGF0ZX0gYW5pbVN0YXRlXG4gICAgc2V0QW5pbVN0YXRlKGRiSWQsIGFuaW1TdGF0ZSkge1xuICAgICAgICB0aGlzLmFuaW1TdGF0ZXNbZGJJZF0gPSBhbmltU3RhdGU7XG4gICAgfVxuXG4gICAgZ2V0QW5pbVN0YXRlKGRiSWQsIGNyZWF0ZUlmTWlzc2luZyA9IGZhbHNlKSB7XG5cbiAgICAgICAgbGV0IGFuaW1TdGF0ZSA9IHRoaXMuYW5pbVN0YXRlc1tkYklkXTtcblxuICAgICAgICAvLyBDcmVhdGUgbmV3IG9uZSBpZiBuZWVkZWRcbiAgICAgICAgaWYgKCFhbmltU3RhdGUgJiYgY3JlYXRlSWZNaXNzaW5nKSB7XG4gICAgICAgICAgICBhbmltU3RhdGUgPSBuZXcgT2JqZWN0QW5pbVN0YXRlKGRiSWQpO1xuICAgICAgICAgICAgdGhpcy5zZXRBbmltU3RhdGUoZGJJZCwgYW5pbVN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbmltU3RhdGU7XG4gICAgfVxuXG4gICAgLy8gQWRkcyBuZXcgT2JqZWN0QW5pbVN0YXRlcyBmb3IgYWxsIGRiSWRzIGluIHNyY1N0YXRlLlxuICAgIC8vXG4gICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgaWYgeW91IHVzZSB0aGlzIHRvIGludGVycG9sYXRlIGJldHdlZW4gb3RoZXIgTW9kZWxTdGF0ZXMgYW5kIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgdGhpcyBNb2RlbFN0YXRlXG4gICAgLy8gYWZmZWN0cyBhbGwgZGJJZHMgdGhhdCBhcmUgYWZmZWN0ZWQgZWl0aGVyIGJ5IHN0YXJ0U3RhdGUgb3IgZW5kU3RhdGUuXG4gICAgLy9cbiAgICAvLyBAcGFyYW0ge01vZGVsQW5pbVN0YXRlfSBzcmNTdGF0ZVxuICAgIGNyZWF0ZU9iamN0QW5pbVN0YXRlcyhzcmNTdGF0ZSkge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gc3JjU3RhdGUuYW5pbVN0YXRlcykge1xuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQga2V5IGlzIHRoZSBkYklkIGFzIHN0cmluZy4gXG4gICAgICAgICAgICAvLyA9PiBVc2UgdGhlIGludGVnZXIgdmFyaWFudCBmcm9tIHNyY1N0YXRlIGluc3RlYWQuXG4gICAgICAgICAgICBjb25zdCBkYklkID0gc3JjU3RhdGUuYW5pbVN0YXRlc1trZXldLmRiSWQ7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYW4gT2JqZWN0QW5pbVN0YXRlIGZvciB0aGlzIGRiSWRcbiAgICAgICAgICAgIHRoaXMuZ2V0QW5pbVN0YXRlKGRiSWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJlcGFyZXMgdGhpcyBNb2RlbFN0YXRlIHRvIGludGVycG9sYXRlIGJldHdlZW4gdHdvIG90aGVyczpcbiAgICAvLyBGb3IgdGhpcywgd2UgbWFrZSBzdXJlIHRoYXQgdGhpcyBNb2RlbFN0YXRlIGFmZmVjdHMgYWxsIGRiSWRzIHRoYXQgYXJlIG1vZGlmaWVkIGJ5IGVpdGhlciBzdGFydCBvciBlbmQuXG4gICAgcHJlcGFyZUxlcnAoc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLmNyZWF0ZU9iamVjdEFuaW1TdGF0ZXMoc3RhcnQpO1xuICAgICAgICB0aGlzLmNyZWF0ZU9iamVjdEFuaW1TdGF0ZXMoZW5kKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGVzIGFsbCBPYmplY3RBbmltU3RhdGVzIGJ5IGludGVycG9sYXRpbmcgYmV0d2VlbiBhIHN0YXJ0IGFuZCBlbmQgYW5pbSBzdGF0ZS5cbiAgICAvL1xuICAgIC8vIE5vdGU6IFRoaXMgb25seSBhZmZlY3RzIHRoZSBleGlzdGluZyBPYmplY3RBbmltU3RhdGVzIHdpdGhpbiB0aGlzIE1vZGVsQW5pbVN0YXRlLlxuICAgIC8vICAgICAgIEl0IGRvZXMgTk9UIGNyZWF0ZSBuZXcgQW5pbVN0YXRlcy4gU2VlIHByZXBhcmVMZXJwKClcbiAgICAvLyBcbiAgICAvLyAgQHBhcmFtIHtNb2RlbEFuaW1TdGF0ZX0gc3RhcnQsIGVuZCAtIG1heSBiZSBudWxsICg9IG9yaWdpbmFsIHN0YXRlKVxuICAgIC8vICBAcGFyYW0ge251bWJlcn0gICAgICAgICB0ICAgICAgICAgIC0gaW50ZXJwb2xhdGlvbiBwYXJhbSBpbiBbMCwxXVxuICAgIGxlcnAoc3RhcnQsIGVuZCwgdCkge1xuICAgICAgICBmb3IgKGxldCBkYklkIGluIHRoaXMuYW5pbVN0YXRlcykge1xuICAgICAgICAgICAgY29uc3Qgb2JqU3RhcnQgPSBzdGFydCAmJiBzdGFydC5hbmltU3RhdGVzW2RiSWRdO1xuICAgICAgICAgICAgY29uc3Qgb2JqRW5kICAgPSBlbmQgICAmJiBlbmQuYW5pbVN0YXRlc1tkYklkXTtcbiAgICAgICAgICAgIHRoaXMuYW5pbVN0YXRlc1tkYklkXS5sZXJwKG9ialN0YXJ0LCBvYmpFbmQsIHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29weUZyb20oc3JjKSB7XG5cbiAgICAgICAgdGhpcy5tb2RlbCA9IHNyYy5tb2RlbDtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBzZXQgdGhlIHNhbWUgT2JqZWN0QW5pbVN0YXRlcyBhcyBzcmMuXG4gICAgICAgIC8vIEF2b2lkIHJlLWFsbG9jYXRpb25zIGlmIHBvc3NpYmxlLlxuICAgICAgICBmb3IgKGxldCBkYklkIGluIHNyYy5hbmltU3RhdGVzKSB7XG4gICAgICAgICAgICAvLyBnZXQgb3IgY3JlYXRlIHN0YXRlXG4gICAgICAgICAgICBjb25zdCBzcmNPYmogPSBzcmMuYW5pbVN0YXRlc1tkYklkXTtcbiAgICAgICAgICAgIGNvbnN0IGRzdE9iaiA9IHRoaXMuZ2V0QW5pbVN0YXRlKGRiSWQsIHRydWUpO1xuICAgICAgICAgICAgZHN0T2JqLmNvcHlGcm9tKHNyY09iaik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhbiBhbGwgb2JqZWN0IGFuaW1TdGF0ZXMgdGhhdCBzcmMgZG9lc24ndCBoYXZlXG4gICAgICAgIGZvciAobGV0IGRiSWQgaW4gdGhpcy5hbmltU3RhdGVzKSB7XG4gICAgICAgICAgICBpZiAoIXNyYy5hbmltU3RhdGVzW2RiSWRdKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuYW5pbVN0YXRlc1tkYklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlc2V0IGFuaW0gdHJhbnNmb3JtcyBmb3IgYWxsIGZyYWdtZW50cyB0aGF0IHdlcmUgbW9kaWZpZWQgYnkgdGhpcyBzdGF0ZVxuICAgIHJlc2V0VHJhbnNmb3JtcygpIHtcbiAgICAgICAgZm9yIChsZXQgZGJJZCBpbiB0aGlzLmFuaW1TdGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbVN0YXRlc1tkYklkXS5yZXNldFRyYW5zZm9ybSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBEZXNjcmliZXMgYW5pbWF0aW9ucyBmb3Igc2V2ZXJhbCBvYmplY3RzIHdpdGhpbiBhIHNjZW5lIGNvbXBvc2VkIGZyb20gbXVsdGlwbGUgbW9kZWxzLlxuZXhwb3J0IGNsYXNzIFNjZW5lQW5pbVN0YXRlIHtcblxuICAgIGNvbnN0cnVjdG9yKG1vZGVscykge1xuICAgICAgICBcbiAgICAgICAgLy8gTW9kZWxBbmltU3RhdGVbXSAtIGluZGV4ZWQgYnkgbW9kZWxJZFxuICAgICAgICB0aGlzLmFuaW1TdGF0ZXMgPSBbXTtcblxuICAgICAgICAvLyBDcmVhdGUgYSBtb2RlbCBwbGFjZW1lbnQgZm9yIGVhY2ggbW9kZWwsIGluZGV4ZWQgYnkgbW9kZWxJZFxuICAgICAgICBtb2RlbHMgJiYgbW9kZWxzLmZvckVhY2gobSA9PiB0aGlzLmFuaW1TdGF0ZXNbbS5pZF0gPSBuZXcgTW9kZWxBbmltU3RhdGUobSkpO1xuICAgIH1cblxuICAgIGFwcGx5KHZpZXdlcikge1xuICAgICAgICAvLyBBcHBseSBhbGwgbW9kZWwgYW5pbSBzdGF0ZXNcbiAgICAgICAgZm9yIChsZXQgbW9kZWxJZCBpbiB0aGlzLmFuaW1TdGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbVN0YXRlc1ttb2RlbElkXS5hcHBseSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yY2UgcmUtcmVuZGVyXG4gICAgICAgIHZpZXdlci5pbXBsLmludmFsaWRhdGUodHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gU2V0IGFuaW1hdGlvbiBzdGF0ZSBmb3IgYSBzaW5nbGUgb2JqZWN0XG4gICAgLy8gTm90ZSB0aGF0IG1vZGVsSWQgbXVzdCBiZSB0aGUgaWQgb2Ygb25lIG9mIHRoZSBtb2RlbHMgdXNlZCBmb3IgY29uc3RydWN0aW9uXG4gICAgc2V0QW5pbVN0YXRlKG1vZGVsSWQsIGRiSWQsIGFuaW1TdGF0ZSkge1xuICAgICAgICB0aGlzLmFuaW1TdGF0ZXNbbW9kZWxJZF0uc2V0QW5pbVN0YXRlKGRiSWQsIGFuaW1TdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gQWRkcyBuZXcgT2JqZWN0QW5pbVN0YXRlcyBmb3IgYWxsIGRiSWRzIGluIHNyY1N0YXRlLlxuICAgIC8vIHNlZSBNb2RlbEFuaW1TdGF0ZS5jcmVhdGVPYmplY3RBbmltU3RhdGVzIGZvciBkZXRhaWxzLlxuICAgIC8vXG4gICAgLy8gQHBhcmFtIHtNb2RlbEFuaW1TdGF0ZX0gc3JjU3RhdGVcbiAgICBjcmVhdGVPYmplY3RBbmltU3RhdGVzKHNyY1N0YXRlKSB7XG4gICAgICAgIGZvciAobGV0IG1vZGVsSWQgaW4gc3JjU3RhdGUuYW5pbVN0YXRlcykge1xuICAgICAgICAgICAgLy8gZ2V0IHNyYyBNb2RlbEFuaW1TdGF0ZVxuICAgICAgICAgICAgY29uc3Qgc3JjID0gc3JjU3RhdGUuYW5pbVN0YXRlc1ttb2RlbElkXTtcblxuICAgICAgICAgICAgLy8gR2V0IG9yIGNyZWF0ZSB0YXJnZXQgTW9kZWxTdGF0ZSBmb3IgdGhpcyBtb2RlbFxuICAgICAgICAgICAgbGV0IGRzdCA9IHRoaXMuYW5pbVN0YXRlc1ttb2RlbElkXTtcbiAgICAgICAgICAgIGlmICghZHN0KSB7XG4gICAgICAgICAgICAgICAgZHN0ID0gbmV3IE1vZGVsQW5pbVN0YXRlKHNyYy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltU3RhdGVzW21vZGVsSWRdID0gZHN0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGlzIE1vZGVsU3RhdGUgb3BlcmF0ZXMgb24gdGhlIHNhbWUgZGJJZHMgYXMgc3JjXG4gICAgICAgICAgICBkc3QuY3JlYXRlT2JqY3RBbmltU3RhdGVzKHNyYyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlcyB0aGlzIFNjZW5lQW5pbVN0YXRlIHRvIGludGVycG9sYXRlIGJldHdlZW4gdHdvIG90aGVyczpcbiAgICAvLyBGb3IgdGhpcywgd2UgbWFrZSBzdXJlIHRoYXQgdGhpcyBTY2VuZUFuaW1TdGF0ZSBhZmZlY3RzIGFsbCBkYklkcyB0aGF0IGFyZSBtb2RpZmllZCBieSBlaXRoZXIgc3RhcnQgb3IgZW5kLlxuICAgIC8vICBAcGFyYW0ge1NjZW5lQW5pbVN0YXRlfSBzdGFydCwgZW5kXG4gICAgcHJlcGFyZUxlcnAoc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLmNyZWF0ZU9iamN0QW5pbVN0YXRlcyhzdGFydCk7XG4gICAgICAgIHRoaXMuY3JlYXRlT2JqY3RBbmltU3RhdGVzKGVuZCk7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoaXMgcGxhY2VtZW50IGJ5IGludGVycG9sYXRpbmcgYmV0d2VlbiBhIHN0YXJ0IGFuZCBlbmQgcGxhY2VtZW50XG4gICAgLy8gTm90ZTpcbiAgICAvLyAgLSBBbGwgcGxhY2VtZW50cyBtdXN0IHJlZmVyIHRvIHRoZSBzYW1lIGxpc3Qgb2YgbW9kZWxzXG4gICAgLy8gIC0gRm9yIGVhY2ggbW9kZWwsIGFsbCBwbGFjZW1lbnRzIG11c3QgZW5saXN0IHRoZSBzYW1lIGRiSWRzXG4gICAgLy8gXG4gICAgLy8gIEBwYXJhbSB7U2NlbmVQbGFjZW1lbnR9IHN0YXJ0LCBlbmRcbiAgICAvLyAgQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgdCAgICAgICAgICAtIGludGVycG9sYXRpb24gcGFyYW0gaW4gWzAsMV1cbiAgICBsZXJwKHN0YXJ0LCBlbmQsIHQpIHtcbiAgICAgICAgZm9yIChsZXQgbW9kZWxJZCBpbiB0aGlzLmFuaW1TdGF0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsU3RhcnQgPSBzdGFydCAmJiBzdGFydC5hbmltU3RhdGVzW21vZGVsSWRdO1xuICAgICAgICAgICAgY29uc3QgbW9kZWxFbmQgICA9IGVuZCAgICYmIGVuZC5hbmltU3RhdGVzW21vZGVsSWRdO1xuICAgICAgICAgICAgdGhpcy5hbmltU3RhdGVzW21vZGVsSWRdLmxlcnAobW9kZWxTdGFydCwgbW9kZWxFbmQsIHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFrZXMgdGhpcyBTY2VuZVN0YXRlIGVxdWFsIHRvIHRoZSBzcmMgc3RhdGUuXG4gICAgY29weUZyb20oc3JjU3RhdGUpIHtcblxuICAgICAgICBmb3IgKGxldCBtb2RlbElkIGluIHNyY1N0YXRlLmFuaW1TdGF0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9IHNyY1N0YXRlLmFuaW1TdGF0ZXNbbW9kZWxJZF07XG4gICAgICAgICAgICBsZXQgICBkc3QgPSB0aGlzLmFuaW1TdGF0ZXNbbW9kZWxJZF07XG5cbiAgICAgICAgICAgIC8vIEluIGNhc2Ugd2UgZG9uJ3QgaGF2ZSBhIE1vZGVsU3RhdGUgZm9yIHRoaXMgbW9kZWwsIGNyZWF0ZSBvbmVcbiAgICAgICAgICAgIGlmICghZHN0KSB7XG4gICAgICAgICAgICAgICAgZHN0ID0gbmV3IE1vZGVsQW5pbVN0YXRlKHNyYy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltU3RhdGVzW21vZGVsSWRdID0gZHN0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkc3QuY29weUZyb20oc3JjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVyYXNlIGFueSBtb2RlbFN0YXRlIHRoYXQgc3JjIGRvZXNuJ3QgaGF2ZVxuICAgICAgICBmb3IgKGxldCBtb2RlbElkIGluIHRoaXMuYW5pbVN0YXRlcykge1xuICAgICAgICAgICAgaWYgKCFzcmNTdGF0ZS5hbmltU3RhdGVzW21vZGVsSWRdKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuYW5pbVN0YXRlc1ttb2RlbElkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlc2V0IGFuaW0gdHJhbnNmb3JtcyBmb3IgYWxsIGZyYWdtZW50cyB0aGF0IHdlcmUgbW9kaWZpZWQgYnkgdGhpcyBzdGF0ZVxuICAgIHJlc2V0VHJhbnNmb3JtcygpIHtcbiAgICAgICAgZm9yIChsZXQgbW9kZWxJZCBpbiB0aGlzLmFuaW1TdGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbVN0YXRlc1ttb2RlbElkXS5yZXNldFRyYW5zZm9ybXMoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuIl0sIm5hbWVzIjpbInRtcE1hdHJpeCIsIlRIUkVFIiwiTWF0cml4NCIsInRtcFZlYzEiLCJWZWN0b3IzIiwiZ2V0Um90YXRpb25PZmZzZXQiLCJyb3RhdGlvbiIsImNlbnRlciIsIm9wdGlvbmFsVGFyZ2V0IiwicmVzdWx0Iiwicm90TWF0cml4IiwibWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24iLCJwIiwiY2xvbmUiLCJhcHBseU1hdHJpeDQiLCJjb3B5Iiwic3ViIiwiT2JqZWN0QW5pbVN0YXRlIiwiY29uc3RydWN0b3IiLCJkYklkIiwibW92ZSIsInNjYWxlIiwicm90IiwiUXVhdGVybmlvbiIsInJvdENlbnRlciIsImFwcGx5IiwibW9kZWwiLCJmcmFnTGlzdCIsImdldEZyYWdtZW50TGlzdCIsIml0IiwiZ2V0SW5zdGFuY2VUcmVlIiwiYWRkIiwiZW51bU5vZGVGcmFnbWVudHMiLCJmcmFnSWQiLCJ1cGRhdGVBbmltVHJhbnNmb3JtIiwibGVycCIsInN0YXJ0IiwiZW5kIiwidCIsIklkZW50aXR5IiwibGVycFZlY3RvcnMiLCJzbGVycFF1YXRlcm5pb25zIiwiY29weUZyb20iLCJzcmMiLCJyZXNldFRyYW5zZm9ybSIsInNldCIsInNldFJvdGF0aW9uQ2VudGVyIiwibmV3Q2VudGVyIiwiYWRqdXN0TW92ZSIsIm9sZE9mZnNldCIsIm5ld09mZnNldCIsIk1vZGVsQW5pbVN0YXRlIiwiYW5pbVN0YXRlcyIsInZpc2libGVCb3VuZHNEaXJ0eSIsInNldEFuaW1TdGF0ZSIsImFuaW1TdGF0ZSIsImdldEFuaW1TdGF0ZSIsImNyZWF0ZUlmTWlzc2luZyIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImNyZWF0ZU9iamN0QW5pbVN0YXRlcyIsInNyY1N0YXRlIiwia2V5IiwicHJlcGFyZUxlcnAiLCJjcmVhdGVPYmplY3RBbmltU3RhdGVzIiwib2JqU3RhcnQiLCJvYmpFbmQiLCJzcmNPYmoiLCJkc3RPYmoiLCJyZXNldFRyYW5zZm9ybXMiLCJTY2VuZUFuaW1TdGF0ZSIsIm1vZGVscyIsImZvckVhY2giLCJtIiwiaWQiLCJ2aWV3ZXIiLCJtb2RlbElkIiwiaW1wbCIsImludmFsaWRhdGUiLCJkc3QiLCJtb2RlbFN0YXJ0IiwibW9kZWxFbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./extensions/VisualClusters/AnimState.js\n");

                /***/
            }),

        /***/
        "./extensions/VisualClusters/Cluster.js":
            /*!**********************************************!*\
              !*** ./extensions/VisualClusters/Cluster.js ***!
              \**********************************************/
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cluster: () => (/* binding */ Cluster),\n/* harmony export */   buildClustersFromAttribute: () => (/* binding */ buildClustersFromAttribute),\n/* harmony export */   createShapeId: () => (/* binding */ createShapeId),\n/* harmony export */   hasVisibleFragments: () => (/* binding */ hasVisibleFragments)\n/* harmony export */ });\n\n// A ShapeID references a single object within a multi-models scene. \nconst createShapeId = (modelId, dbId) => {\n  return {\n    modelId,\n    dbId\n  };\n};\n\n// A Cluster is a group of objects that is supposed to be positions close to each other.\nclass Cluster {\n\n  constructor(name) {\n\n    // string\n    this.name = name;\n\n    // ShapeID[]\n    this.shapeIds = [];\n  }\n}\n\n// Checks if all fragments of a given dbId are hidden. If so, we exclude it from layout algorithm, because it would just produce empty space.\nconst hasVisibleFragments = (model, dbId) => {\n\n  const it = model.getInstanceTree();\n  const fragList = model.getFragmentList();\n  const visFlags = model.myData.fragments.visibilityFlags;\n\n  // Update fragment animation transforms\n  let allHidden = true;\n  it.enumNodeFragments(dbId, (fragId) => {\n\n    // For OTG models, the visFlags tell us which fragments have been skipped by OtgLoader. This applies for Revit Room geometry.\n    // For Svf, these flags may not exist, because they are deleted after loading. However, SvfLoader then sets the corresponding fragments to invisible.\n    const skipped = visFlags && visFlags[fragId] === Autodesk.Viewing.Private.MeshFlags.MESH_NOTLOADED;\n    const hidden = !fragList.isFragVisible(fragId);\n\n    if (!skipped && !hidden) {\n      // We found a visible fragment\n      allHidden = false;\n\n      // No need to continue traversal\n      return true;\n    }\n  });\n  return !allHidden;\n};\n\n// Remove duplicates from array\n//  @param {[]} a\n//  @returns {[]} Deduplicated copy.\nconst uniq = (a) => {\n  return Array.from(new Set(a));\n};\n\n// Creates a set of clusters based on the values of a certain propertyDB attribute.\n// Note that you have to wait for an async propDB call to finish.\n//\n// By default, we only categorize leaf objects. This requires that all leaf objects contain the attribute to search for.\n// The searchParents option enables to allow parent nodes as well:\n//      i.e. we search all levels of the model tree and consider inner nodes as a single object if they contain\n//           the search attribute.\n//\n//  @param {Model[]}   models\n//  @param {string}    attribName\n//  @param {boolean}   searchParents\n//  @returns {Promise} When done, it resolves to a {Cluster[]}, where each element is...\n//                       - named by an attribute value \n//                       - containing all ShapeIds that match that value\nconst buildClustersFromAttribute = async function (models) {let attribName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Category';let searchAncestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  // Collects result\n  const clustersByName = {};\n\n  // For each model, we run an async propDB worker query\n  const promises = [];\n\n  for (let i = 0; i < models.length; i++) {\n\n    let model = models[i];\n    const tree = model.getData().instanceTree;\n    let dbIds;\n\n    if (searchAncestors) {\n      // Use all the dbIds in the model\n      const ids = Object.keys(tree.nodeAccess.dbIdToIndex);\n      dbIds = ids.map((item) => parseInt(item, 10));\n    } else {\n      // get all dbIds with visual representation\n      dbIds = model.myData.fragments.fragId2dbId;\n\n      // Exclude all dbIds that only contain hidden fragments (like room geometries)\n      dbIds = dbIds.filter((dbId) => hasVisibleFragments(model, dbId));\n\n      // Remove duplicates. Note that this is necessary, because dbIds with multiple fragments will\n      // occur several times in fragId2dbId.\n      dbIds = uniq(dbIds);\n    }\n\n    const options = {\n      ignoreHidden: false,\n      propFilter: [attribName]\n    };\n\n    promises.push(new Promise((resolve, reject) => {\n\n      // Process dbIds. result is an array of item,\n      // each containing the props for a single dbId\n      const onDone = (result) => {\n        for (let i = 0; i < result.length; i++) {\n\n          // item contains props of a single db object\n          const item = result[i];\n\n          // get category of this db item  \n          const category = item.properties[0].displayValue;\n\n          // get or create cluster for this category\n          let cluster = clustersByName[category];\n          if (!cluster) {\n            cluster = new Cluster(category);\n            clustersByName[category] = cluster;\n          }\n\n          if (searchAncestors) {\n            // Append IDs of visible children\n            tree.enumNodeChildren(item.dbId, (child) => {\n              if (hasVisibleFragments(model, child)) {\n                cluster.shapeIds.push(createShapeId(model.id, child));\n              }\n            }, true);\n          } else {\n            // Append current dbId to this cluster\n            cluster.shapeIds.push(createShapeId(model.id, item.dbId));\n          }\n        }\n        resolve();\n      };\n\n      model.getBulkProperties2(dbIds, options, onDone);\n    }));\n  }\n\n  await Promise.all(promises);\n\n  // Flatten to an array\n  let clusters = Object.values(clustersByName);\n\n  return clusters;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FJLElBQUksQ0FBQzJCLGdCQUFnQixDQUFDakIsSUFBSSxDQUFDbkQsSUFBSSxFQUFFLENBQUFxRSxLQUFLLEtBQUk7Y0FDdEMsSUFBSWhFLG1CQUFtQixDQUFDQyxLQUFLLEVBQUUrRCxLQUFLLENBQUMsRUFBRTtnQkFDbkNGLE9BQU8sQ0FBQy9ELFFBQVEsQ0FBQ3NELElBQUksQ0FBQzVELGFBQWEsQ0FBQ1EsS0FBSyxDQUFDZ0UsRUFBRSxFQUFFRCxLQUFLLENBQUMsQ0FBQztjQUN6RDtZQUNKLENBQUMsRUFBRSxJQUFJLENBQUM7VUFDWixDQUFDLE1BQU07WUFDSDtZQUNBRixPQUFPLENBQUMvRCxRQUFRLENBQUNzRCxJQUFJLENBQUM1RCxhQUFhLENBQUNRLEtBQUssQ0FBQ2dFLEVBQUUsRUFBRW5CLElBQUksQ0FBQ25ELElBQUksQ0FBQyxDQUFDO1VBQzdEO1FBQ0o7UUFDQTRELE9BQU8sQ0FBQyxDQUFDO01BQ2IsQ0FBQzs7TUFFRHRELEtBQUssQ0FBQ2lFLGtCQUFrQixDQUFDM0IsS0FBSyxFQUFFVyxPQUFPLEVBQUVPLE1BQU0sQ0FBQztJQUNwRCxDQUFDLENBQUMsQ0FBQztFQUNQOztFQUVBLE1BQU1ILE9BQU8sQ0FBQ2EsR0FBRyxDQUFDakMsUUFBUSxDQUFDOztFQUUzQjtFQUNBLElBQUlrQyxRQUFRLEdBQUczQixNQUFNLENBQUM0QixNQUFNLENBQUNwQyxjQUFjLENBQUM7O0VBRTVDLE9BQU9tQyxRQUFRO0FBQ25CLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdXRvZGVzay5FeHRlbnNpb25zLy4vZXh0ZW5zaW9ucy9WaXN1YWxDbHVzdGVycy9DbHVzdGVyLmpzPzRhYjUiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBBIFNoYXBlSUQgcmVmZXJlbmNlcyBhIHNpbmdsZSBvYmplY3Qgd2l0aGluIGEgbXVsdGktbW9kZWxzIHNjZW5lLiBcbmNvbnN0IGNyZWF0ZVNoYXBlSWQgPSAobW9kZWxJZCwgZGJJZCkgPT4ge1xuICAgIHJldHVybiB7IFxuICAgICAgICBtb2RlbElkLCBcbiAgICAgICAgZGJJZCBcbiAgICB9O1xufTtcblxuLy8gQSBDbHVzdGVyIGlzIGEgZ3JvdXAgb2Ygb2JqZWN0cyB0aGF0IGlzIHN1cHBvc2VkIHRvIGJlIHBvc2l0aW9ucyBjbG9zZSB0byBlYWNoIG90aGVyLlxuY2xhc3MgQ2x1c3RlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG5cbiAgICAgICAgLy8gc3RyaW5nXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgLy8gU2hhcGVJRFtdXG4gICAgICAgIHRoaXMuc2hhcGVJZHMgPSBbXTtcbiAgICB9XG59XG5cbi8vIENoZWNrcyBpZiBhbGwgZnJhZ21lbnRzIG9mIGEgZ2l2ZW4gZGJJZCBhcmUgaGlkZGVuLiBJZiBzbywgd2UgZXhjbHVkZSBpdCBmcm9tIGxheW91dCBhbGdvcml0aG0sIGJlY2F1c2UgaXQgd291bGQganVzdCBwcm9kdWNlIGVtcHR5IHNwYWNlLlxuY29uc3QgaGFzVmlzaWJsZUZyYWdtZW50cyA9IChtb2RlbCwgZGJJZCkgPT4ge1xuXG4gICAgY29uc3QgaXQgPSBtb2RlbC5nZXRJbnN0YW5jZVRyZWUoKTtcbiAgICBjb25zdCBmcmFnTGlzdCA9IG1vZGVsLmdldEZyYWdtZW50TGlzdCgpO1xuICAgIGNvbnN0IHZpc0ZsYWdzID0gbW9kZWwubXlEYXRhLmZyYWdtZW50cy52aXNpYmlsaXR5RmxhZ3M7XG5cbiAgICAvLyBVcGRhdGUgZnJhZ21lbnQgYW5pbWF0aW9uIHRyYW5zZm9ybXNcbiAgICBsZXQgYWxsSGlkZGVuID0gdHJ1ZTtcbiAgICBpdC5lbnVtTm9kZUZyYWdtZW50cyhkYklkLCBmcmFnSWQgPT4ge1xuXG4gICAgICAgIC8vIEZvciBPVEcgbW9kZWxzLCB0aGUgdmlzRmxhZ3MgdGVsbCB1cyB3aGljaCBmcmFnbWVudHMgaGF2ZSBiZWVuIHNraXBwZWQgYnkgT3RnTG9hZGVyLiBUaGlzIGFwcGxpZXMgZm9yIFJldml0IFJvb20gZ2VvbWV0cnkuXG4gICAgICAgIC8vIEZvciBTdmYsIHRoZXNlIGZsYWdzIG1heSBub3QgZXhpc3QsIGJlY2F1c2UgdGhleSBhcmUgZGVsZXRlZCBhZnRlciBsb2FkaW5nLiBIb3dldmVyLCBTdmZMb2FkZXIgdGhlbiBzZXRzIHRoZSBjb3JyZXNwb25kaW5nIGZyYWdtZW50cyB0byBpbnZpc2libGUuXG4gICAgICAgIGNvbnN0IHNraXBwZWQgPSB2aXNGbGFncyAmJiAodmlzRmxhZ3NbZnJhZ0lkXSA9PT0gQXV0b2Rlc2suVmlld2luZy5Qcml2YXRlLk1lc2hGbGFncy5NRVNIX05PVExPQURFRCk7XG4gICAgICAgIGNvbnN0IGhpZGRlbiA9ICFmcmFnTGlzdC5pc0ZyYWdWaXNpYmxlKGZyYWdJZCk7XG5cbiAgICAgICAgaWYgKCFza2lwcGVkICYmICFoaWRkZW4pIHtcbiAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgdmlzaWJsZSBmcmFnbWVudFxuICAgICAgICAgICAgYWxsSGlkZGVuID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gY29udGludWUgdHJhdmVyc2FsXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuICFhbGxIaWRkZW47XG59O1xuXG4vLyBSZW1vdmUgZHVwbGljYXRlcyBmcm9tIGFycmF5XG4vLyAgQHBhcmFtIHtbXX0gYVxuLy8gIEByZXR1cm5zIHtbXX0gRGVkdXBsaWNhdGVkIGNvcHkuXG5jb25zdCB1bmlxID0gKGEpID0+IHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGEpKTtcbn07XG5cbi8vIENyZWF0ZXMgYSBzZXQgb2YgY2x1c3RlcnMgYmFzZWQgb24gdGhlIHZhbHVlcyBvZiBhIGNlcnRhaW4gcHJvcGVydHlEQiBhdHRyaWJ1dGUuXG4vLyBOb3RlIHRoYXQgeW91IGhhdmUgdG8gd2FpdCBmb3IgYW4gYXN5bmMgcHJvcERCIGNhbGwgdG8gZmluaXNoLlxuLy9cbi8vIEJ5IGRlZmF1bHQsIHdlIG9ubHkgY2F0ZWdvcml6ZSBsZWFmIG9iamVjdHMuIFRoaXMgcmVxdWlyZXMgdGhhdCBhbGwgbGVhZiBvYmplY3RzIGNvbnRhaW4gdGhlIGF0dHJpYnV0ZSB0byBzZWFyY2ggZm9yLlxuLy8gVGhlIHNlYXJjaFBhcmVudHMgb3B0aW9uIGVuYWJsZXMgdG8gYWxsb3cgcGFyZW50IG5vZGVzIGFzIHdlbGw6XG4vLyAgICAgIGkuZS4gd2Ugc2VhcmNoIGFsbCBsZXZlbHMgb2YgdGhlIG1vZGVsIHRyZWUgYW5kIGNvbnNpZGVyIGlubmVyIG5vZGVzIGFzIGEgc2luZ2xlIG9iamVjdCBpZiB0aGV5IGNvbnRhaW5cbi8vICAgICAgICAgICB0aGUgc2VhcmNoIGF0dHJpYnV0ZS5cbi8vXG4vLyAgQHBhcmFtIHtNb2RlbFtdfSAgIG1vZGVsc1xuLy8gIEBwYXJhbSB7c3RyaW5nfSAgICBhdHRyaWJOYW1lXG4vLyAgQHBhcmFtIHtib29sZWFufSAgIHNlYXJjaFBhcmVudHNcbi8vICBAcmV0dXJucyB7UHJvbWlzZX0gV2hlbiBkb25lLCBpdCByZXNvbHZlcyB0byBhIHtDbHVzdGVyW119LCB3aGVyZSBlYWNoIGVsZW1lbnQgaXMuLi5cbi8vICAgICAgICAgICAgICAgICAgICAgICAtIG5hbWVkIGJ5IGFuIGF0dHJpYnV0ZSB2YWx1ZSBcbi8vICAgICAgICAgICAgICAgICAgICAgICAtIGNvbnRhaW5pbmcgYWxsIFNoYXBlSWRzIHRoYXQgbWF0Y2ggdGhhdCB2YWx1ZVxuY29uc3QgYnVpbGRDbHVzdGVyc0Zyb21BdHRyaWJ1dGUgPSBhc3luYyAobW9kZWxzLCBhdHRyaWJOYW1lID0gJ0NhdGVnb3J5Jywgc2VhcmNoQW5jZXN0b3JzID0gZmFsc2UpID0+IHtcblxuICAgIC8vIENvbGxlY3RzIHJlc3VsdFxuICAgIGNvbnN0IGNsdXN0ZXJzQnlOYW1lID0ge307XG5cbiAgICAvLyBGb3IgZWFjaCBtb2RlbCwgd2UgcnVuIGFuIGFzeW5jIHByb3BEQiB3b3JrZXIgcXVlcnlcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaT0wOyBpPG1vZGVscy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIGxldCBtb2RlbCA9IG1vZGVsc1tpXTtcbiAgICAgICAgY29uc3QgdHJlZSA9IG1vZGVsLmdldERhdGEoKS5pbnN0YW5jZVRyZWU7XG4gICAgICAgIGxldCBkYklkcztcblxuICAgICAgICBpZiAoc2VhcmNoQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICAvLyBVc2UgYWxsIHRoZSBkYklkcyBpbiB0aGUgbW9kZWxcbiAgICAgICAgICAgIGNvbnN0IGlkcyA9IE9iamVjdC5rZXlzKHRyZWUubm9kZUFjY2Vzcy5kYklkVG9JbmRleCk7XG4gICAgICAgICAgICBkYklkcyA9IGlkcy5tYXAoaXRlbSA9PiBwYXJzZUludChpdGVtLCAxMCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZ2V0IGFsbCBkYklkcyB3aXRoIHZpc3VhbCByZXByZXNlbnRhdGlvblxuICAgICAgICAgICAgZGJJZHMgPSBtb2RlbC5teURhdGEuZnJhZ21lbnRzLmZyYWdJZDJkYklkO1xuXG4gICAgICAgICAgICAvLyBFeGNsdWRlIGFsbCBkYklkcyB0aGF0IG9ubHkgY29udGFpbiBoaWRkZW4gZnJhZ21lbnRzIChsaWtlIHJvb20gZ2VvbWV0cmllcylcbiAgICAgICAgICAgIGRiSWRzID0gZGJJZHMuZmlsdGVyKGRiSWQgPT4gaGFzVmlzaWJsZUZyYWdtZW50cyhtb2RlbCwgZGJJZCkpO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgZHVwbGljYXRlcy4gTm90ZSB0aGF0IHRoaXMgaXMgbmVjZXNzYXJ5LCBiZWNhdXNlIGRiSWRzIHdpdGggbXVsdGlwbGUgZnJhZ21lbnRzIHdpbGxcbiAgICAgICAgICAgIC8vIG9jY3VyIHNldmVyYWwgdGltZXMgaW4gZnJhZ0lkMmRiSWQuXG4gICAgICAgICAgICBkYklkcyA9IHVuaXEoZGJJZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGlnbm9yZUhpZGRlbjogZmFsc2UsXG4gICAgICAgICAgICBwcm9wRmlsdGVyOiBbYXR0cmliTmFtZV1cbiAgICAgICAgfTtcblxuICAgICAgICBwcm9taXNlcy5wdXNoKG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAgICAgLy8gUHJvY2VzcyBkYklkcy4gcmVzdWx0IGlzIGFuIGFycmF5IG9mIGl0ZW0sXG4gICAgICAgICAgICAvLyBlYWNoIGNvbnRhaW5pbmcgdGhlIHByb3BzIGZvciBhIHNpbmdsZSBkYklkXG4gICAgICAgICAgICBjb25zdCBvbkRvbmUgPSAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPHJlc3VsdC5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gY29udGFpbnMgcHJvcHMgb2YgYSBzaW5nbGUgZGIgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSByZXN1bHRbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGNhdGVnb3J5IG9mIHRoaXMgZGIgaXRlbSAgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gaXRlbS5wcm9wZXJ0aWVzWzBdLmRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgb3IgY3JlYXRlIGNsdXN0ZXIgZm9yIHRoaXMgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNsdXN0ZXIgPSBjbHVzdGVyc0J5TmFtZVtjYXRlZ29yeV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2x1c3Rlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2x1c3RlciA9IG5ldyBDbHVzdGVyKGNhdGVnb3J5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJzQnlOYW1lW2NhdGVnb3J5XSA9IGNsdXN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgSURzIG9mIHZpc2libGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWUuZW51bU5vZGVDaGlsZHJlbihpdGVtLmRiSWQsIGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzVmlzaWJsZUZyYWdtZW50cyhtb2RlbCwgY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXIuc2hhcGVJZHMucHVzaChjcmVhdGVTaGFwZUlkKG1vZGVsLmlkLCBjaGlsZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIGN1cnJlbnQgZGJJZCB0byB0aGlzIGNsdXN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXIuc2hhcGVJZHMucHVzaChjcmVhdGVTaGFwZUlkKG1vZGVsLmlkLCBpdGVtLmRiSWQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBtb2RlbC5nZXRCdWxrUHJvcGVydGllczIoZGJJZHMsIG9wdGlvbnMsIG9uRG9uZSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAvLyBGbGF0dGVuIHRvIGFuIGFycmF5XG4gICAgbGV0IGNsdXN0ZXJzID0gT2JqZWN0LnZhbHVlcyhjbHVzdGVyc0J5TmFtZSk7XG5cbiAgICByZXR1cm4gY2x1c3RlcnM7XG59O1xuXG5leHBvcnQge1xuICAgIGJ1aWxkQ2x1c3RlcnNGcm9tQXR0cmlidXRlLFxuICAgIENsdXN0ZXIsXG4gICAgY3JlYXRlU2hhcGVJZCxcbiAgICBoYXNWaXNpYmxlRnJhZ21lbnRzXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlU2hhcGVJZCIsIm1vZGVsSWQiLCJkYklkIiwiQ2x1c3RlciIsImNvbnN0cnVjdG9yIiwibmFtZSIsInNoYXBlSWRzIiwiaGFzVmlzaWJsZUZyYWdtZW50cyIsIm1vZGVsIiwiaXQiLCJnZXRJbnN0YW5jZVRyZWUiLCJmcmFnTGlzdCIsImdldEZyYWdtZW50TGlzdCIsInZpc0ZsYWdzIiwibXlEYXRhIiwiZnJhZ21lbnRzIiwidmlzaWJpbGl0eUZsYWdzIiwiYWxsSGlkZGVuIiwiZW51bU5vZGVGcmFnbWVudHMiLCJmcmFnSWQiLCJza2lwcGVkIiwiQXV0b2Rlc2siLCJWaWV3aW5nIiwiUHJpdmF0ZSIsIk1lc2hGbGFncyIsIk1FU0hfTk9UTE9BREVEIiwiaGlkZGVuIiwiaXNGcmFnVmlzaWJsZSIsInVuaXEiLCJhIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwiYnVpbGRDbHVzdGVyc0Zyb21BdHRyaWJ1dGUiLCJtb2RlbHMiLCJhdHRyaWJOYW1lIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwic2VhcmNoQW5jZXN0b3JzIiwiY2x1c3RlcnNCeU5hbWUiLCJwcm9taXNlcyIsImkiLCJ0cmVlIiwiZ2V0RGF0YSIsImluc3RhbmNlVHJlZSIsImRiSWRzIiwiaWRzIiwiT2JqZWN0Iiwia2V5cyIsIm5vZGVBY2Nlc3MiLCJkYklkVG9JbmRleCIsIm1hcCIsIml0ZW0iLCJwYXJzZUludCIsImZyYWdJZDJkYklkIiwiZmlsdGVyIiwib3B0aW9ucyIsImlnbm9yZUhpZGRlbiIsInByb3BGaWx0ZXIiLCJwdXNoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJvbkRvbmUiLCJyZXN1bHQiLCJjYXRlZ29yeSIsInByb3BlcnRpZXMiLCJkaXNwbGF5VmFsdWUiLCJjbHVzdGVyIiwiZW51bU5vZGVDaGlsZHJlbiIsImNoaWxkIiwiaWQiLCJnZXRCdWxrUHJvcGVydGllczIiLCJhbGwiLCJjbHVzdGVycyIsInZhbHVlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./extensions/VisualClusters/Cluster.js\n");

                /***/
            }),

        /***/
        "./extensions/VisualClusters/ClusterGizmo.js":
            /*!***************************************************!*\
              !*** ./extensions/VisualClusters/ClusterGizmo.js ***!
              \***************************************************/
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClusterGizmo: () => (/* binding */ ClusterGizmo),\n/* harmony export */   ClusterGizmoController: () => (/* binding */ ClusterGizmoController)\n/* harmony export */ });\n\n// Disable packed normals for now, because it sometimes causes wrong values in the normal-depth-buffer (not clear why).\n// The number of cluster boxes is small anyway, so using unpacked is okay here.\nconst UsePackedNormals = false;\n\nconst avp = Autodesk.Viewing.Private;\n\n// Creates a quad with xy in [-0.5, 0.5] and z=0. Normal is +z\nconst createUnitQuadGeom = () => {\n\n  const l = -0.5;\n  const h = +0.5;\n\n  // vertex positions (3-floats per vertex)\n  const positions = Float32Array.from([\n  l, l, 0,\n  l, h, 0,\n  h, l, 0,\n  h, h, 0]\n  );\n\n  // index buffer for triangles\n  const indices = Uint16Array.from([0, 3, 1, 0, 2, 3]);\n\n  // index buffer for edges\n  const iblines = Uint16Array.from([0, 1, 1, 3, 3, 2, 2, 0]);\n\n  // create interleaved vertex buffer\n  const vertexCount = 4;\n  const vbstride = UsePackedNormals ? 4 : 6; // float32 values per vertex\n  const vb = new Float32Array(vertexCount * vbstride);\n\n  // write positions to interleaved buffer\n  for (let i = 0; i < vertexCount; i++) {\n    const srcOffset = 3 * i;\n    const dstOffset = vbstride * i;\n    vb[dstOffset] = positions[srcOffset];\n    vb[dstOffset + 1] = positions[srcOffset + 1];\n    vb[dstOffset + 2] = positions[srcOffset + 2];\n  }\n\n  if (UsePackedNormals) {\n    // encode (0,0,1) as packed Uint16 normal\n    const toUint16 = 0xFFFF; // for upscaling from [0,1]-floats to Uint16-scale\n    const nx = 0.5 * toUint16;\n    const ny = 1.0 * toUint16;\n\n    // The first 3 floats per vertex are used by positions. \n    // Counting in Uint16 values, this makes 6.\n    const normalOffset = 6;\n\n    // write normals to interleaved buffer\n    const vbUint16 = new Uint16Array(vb.buffer);\n    const vbUint16Stride = vbstride * 2; // 2 Uint16 per float32\n    for (let i = 0; i < vertexCount; i++) {\n      const dstOffset = vbUint16Stride * i + normalOffset;\n      vbUint16[dstOffset] = nx;\n      vbUint16[dstOffset + 1] = ny;\n    }\n  } else {\n    const normalOffset = 3;\n\n    // write normals to interleaved buffer\n    for (let i = 0; i < vertexCount; i++) {\n      const dstOffset = vbstride * i + normalOffset;\n      vb[dstOffset] = 0;\n      vb[dstOffset + 1] = 0;\n      vb[dstOffset + 2] = 1;\n    }\n  }\n\n  // create result geometry\n  const geom = new THREE.BufferGeometry();\n\n  geom.vbstride = vbstride;\n  geom.vb = vb;\n  geom.ib = indices;\n  geom.iblines = iblines;\n  // position attribute\n  var attrPos = new THREE.BufferAttribute(undefined, 3);\n  attrPos.offset = 0;\n  geom.attributes.position = attrPos;\n\n  // normal attribute\n  var attrNormal = new THREE.BufferAttribute(undefined, 3);\n  attrNormal.offset = 3;\n  attrNormal.bytesPerItem = UsePackedNormals ? 2 : 6;\n  attrNormal.normalized = true;\n  geom.attributes.normal = attrNormal;\n\n  // index attribute\n  var attrIndex = new THREE.BufferAttribute(undefined, 1);\n  attrIndex.bytesPerItem = 2;\n  geom.index = attrIndex;\n\n  // add attribute for edge rendering\n  var attrIndexLines = new THREE.BufferAttribute(undefined, 1);\n  attrIndexLines.bytesPerItem = 2;\n  geom.setAttribute('indexlines', attrIndexLines);\n\n  // attribute keys\n  geom.attributesKeys = Object.keys(geom.attributes);\n\n  return geom;\n};\n\n// Creates a quad mesh that corresponds to the z-Min face of the given bbox\n//  @param {Box3}            bbox\n//  @param {BufferGeometry}  unitQuadGeom\n//  @param {Material}        matman       - must be registered at materialManager and use packedNormals\nconst createGizmoMesh = (bbox, material) => {\n\n  // In theory, we could share a static one here. However, this would introduce subtle detail problems\n  // when using multiple viewer instances, because WebGLRenderer attaches gl-context-specific resources.\n  // The number of gizmo boxes is not big anyway, so what.\n  const geom = createUnitQuadGeom();\n\n  // create mesh\n  var boxMesh = new THREE.Mesh(geom, material);\n\n  // move mesh origin to center of bbox z-min face\n  bbox.getCenter(boxMesh.position);\n  bbox.getSize(boxMesh.scale);\n  boxMesh.position.z = bbox.min.z;\n\n  // Attach mesh bbox\n  boxMesh.boundingBox = bbox.clone();\n  boxMesh.boundingBox.max.z = bbox.min.z; // The mesh only spans the z-min surface of bbox\n\n  return boxMesh;\n};\n\n// @param {MaterialManager} matman - needed to register the material\nconst createGizmoMaterial = (matman) => {\n\n  // create material\n  var material = new THREE.MeshPhongMaterial({\n    color: 0xffffff, // white\n    transparent: true,\n    opacity: 1,\n    side: THREE.DoubleSide,\n\n    // Disable z-buffer: It doesn't work with fading and the quads are below all the shapes anyway.\n    depthTest: false,\n    depthWrite: false\n  });\n\n  // Note: This is must be set separately, because it's a custom-lmv property and not supported by the material ctor\n  material.packedNormals = UsePackedNormals;\n\n  // Register at MaterialManager\n  material.name = 'ClusterGizmoMaterial_' + material.id;\n  matman.addHDRMaterial(material.name, material);\n\n  return material;\n};\n\nconst disposeGizmoMesh = (mesh, matman) => {\n  mesh.geometry.dispose();\n  mesh.material.dispose();\n  matman.removeMaterial(mesh.material.name);\n};\n\n// A ClusterGizmo is a quad below an object cluster that helps to distinguish different clusters.\nclass ClusterGizmo {\n\n  // @param {Box3}   clusterBox - bbox of the cluster\n  // @param {string} [meshName] - Attached to the mesh to simplify debugging\n  constructor(viewer, clusterBox, meshName) {\n\n    this.viewer = viewer;\n\n    // create mesh\n    const material = createGizmoMaterial(viewer.impl.matman());\n    this.mesh = createGizmoMesh(clusterBox, material);\n\n    this.mesh.name = meshName;\n\n    // add it to viewer scene\n    this.viewer.impl.scene.add(this.mesh);\n\n    // For smooth fadeIn/Out\n    const setOpacity = (t) => {\n      // Fade-in quad\n      this.mesh.material.opacity = t;\n\n      // Fade-in outline: Edges should have 0.5 opacity when fully faded in\n      this.mesh.material.edgeOpacity = 0.5 * t;\n\n      this.viewer.impl.invalidate(true, true);\n    };\n    this.opacityParam = new avp.AnimatedParam(0.0, setOpacity, 1.0);\n\n    // Initial fade-in\n    this.opacityParam.fadeTo(1);\n  }\n\n  dtor() {\n    // remove from viewer scene\n    this.viewer.impl.scene.remove(this.mesh);\n    this.viewer.impl.invalidate(true, true);\n\n    // dispose gpu resources\n    disposeGizmoMesh(this.mesh, this.viewer.impl.matman());\n\n    this.mesh = null;\n    this.viewer = null;\n  }\n\n  // Fade out and dispose mesh when done\n  dispose() {\n    this.opacityParam.fadeTo(0.0, () => this.dtor());\n  }\n}\n\n// ClusterGizmoController takes care that ClusterGizmos and corresponding labels are created/disposed according to the currently shown layout.\nclass ClusterGizmoController {\n\n  constructor(viewer) {\n\n    this.viewer = viewer;\n\n    this.gizmos = []; // ClusterGizmo[]\n    this.labels = []; // Label3D[]\n\n    // We delay fade-in, so that gizmos/labels appear shortly before the cluster animation ends\n    this.fadeInDelay = 1.8; // in seconds\n    this.timerId = null;\n  }\n\n  createGizmos(sceneLayout) {\n\n    // For each cluster...\n    const layouts = sceneLayout.clusterLayouts;\n    for (let i = 0; i < layouts.length; i++) {\n      const layout = layouts[i];\n\n      // create quad gizmo\n      const bbox = layout.getBBox();\n      const gizmo = new ClusterGizmo(this.viewer, bbox, layout.cluster.name);\n      this.gizmos.push(gizmo);\n\n      // get label position (center of the bbox zMin-face)\n      const labelPos = bbox.getCenter(new THREE.Vector3());\n      labelPos.z = bbox.min.z;\n\n      // create label\n      const text = this.getLabelText(layout);\n      const label = new Autodesk.Edit3D.Label3D(this.viewer, labelPos, text);\n      this.labels.push(label);\n\n      // Hide label if ClusterGizmo size on screen is below MinPixels threshold.\n      //\n      // Note: We could use the screen-size of the label text. However, this looks confusing\n      //       if some cluster labels are shown and others are not (due to longer text that you don't see).\n      //       So, it looks more consistent to use a fixed minPixelSize for all clusters.\n      //       For super-long cluster names, we will introduce abbreviations instead.\n      const MinPixels = 75;\n      label.setWorldBox(gizmo.mesh.boundingBox, MinPixels);\n\n      // When clicking a label, fly to the cluster\n      const flyToCluster = (e) => {\n        const camera = this.viewer.impl.camera;\n\n        // get cluster-platform center and box size\n        const gizmoBox = gizmo.mesh.boundingBox;\n        const p = gizmoBox.getCenter(new THREE.Vector3());\n        const size = gizmoBox.getSize(new THREE.Vector3());\n\n        // Setup view diagonally to look at p\n        const dstView = camera.clone();\n        dstView.target.copy(p);\n\n        // get current distance from target point\n        const curDistance = camera.position.distanceTo(p);\n\n        // Place the camera on the line between target and start camera position.\n        // Choose distance close enough to the cluster to clearly focus it.\n        let dist = Math.max(size.x, size.y, size.z);\n        dist = Math.min(dist, curDistance); // if already close, never move away from target\n        let dir = camera.position.clone().sub(p).normalize();\n        dstView.position.set(\n          p.x + dir.x * dist,\n          p.y + dir.y * dist,\n          p.z + dir.z * dist\n        );\n\n        // trigger animation\n        avp.flyToView(this.viewer, dstView, 1.5);\n\n        // Mark click as consumed, so that it doesn't trigger selection of objects behind the label.\n        e.stopPropagation();\n      };\n      label.container.style.pointerEvents = 'auto';\n      label.container.addEventListener('click', flyToCluster);\n    }\n  }\n\n  getLabelText(layout) {\n    let text = layout.cluster.name;\n\n    // Remove \"Revit \" prefix\n    // For now, we hard-wire this, but this function will be customizable by clients later.\n    const prefix = 'Revit ';\n    if (isNaN(text) && text.startsWith(prefix)) {\n      text = text.substring(prefix.length);\n    }\n\n    return text;\n  }\n\n  disposeGizmos() {\n    this.gizmos.forEach((g) => g.dispose());\n    this.labels.forEach((l) => l.dispose());\n    this.gizmos.length = 0;\n    this.labels.length = 0;\n  }\n\n  // If a delayed fade-in of gizmos is pending for prior layout, cancel it\n  cancelTimer() {\n    if (this.timerId) {\n      window.clearTimeout(this.timerId);\n      this.timerId = null;\n    }\n  }\n\n  onLayoutChanged(sceneLayout) {\n\n    // Make sure that there is no concurrent delayed fade-in of a prior layout\n    this.cancelTimer();\n\n    // Fade-out and dispose any outdated gizmos\n    this.disposeGizmos();\n\n    // Fade-in new gizmos after some delay\n    if (sceneLayout) {\n      this.timerId = window.setTimeout(\n        () => this.createGizmos(sceneLayout),\n        this.fadeInDelay * 1000\n      );\n    }\n  }\n\n  // Dispose all resources immediately\n  reset() {\n    this.gizmos.forEach((g) => g.dtor());\n    this.labels.forEach((l) => l.dtor());\n    this.gizmos.length = 0;\n    this.labels.length = 0;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leHRlbnNpb25zL1Zpc3VhbENsdXN0ZXJzL0NsdXN0ZXJHaXptby5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTtBQUNBO0FBQ0EsTUFBTUEsZ0JBQWdCLEdBQUcsS0FBSzs7QUFFOUIsTUFBTUMsR0FBRyxHQUFHQyxRQUFRLENBQUNDLE9BQU8sQ0FBQ0MsT0FBTzs7QUFFcEM7QUFDQSxNQUFNQyxrQkFBa0IsR0FBR0EsQ0FBQSxLQUFNOztFQUU3QixNQUFNQyxDQUFDLEdBQUcsQ0FBRSxHQUFHO0VBQ2YsTUFBTUMsQ0FBQyxHQUFHLENBQUUsR0FBRzs7RUFFZjtFQUNBLE1BQU1DLFNBQVMsR0FBR0MsWUFBWSxDQUFDQyxJQUFJLENBQUM7RUFDaENKLENBQUMsRUFBRUEsQ0FBQyxFQUFFLENBQUM7RUFDUEEsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsQ0FBQztFQUNQQSxDQUFDLEVBQUVELENBQUMsRUFBRSxDQUFDO0VBQ1BDLENBQUMsRUFBRUEsQ0FBQyxFQUFFLENBQUM7RUFDVixDQUFDOztFQUVGO0VBQ0EsTUFBTUksT0FBTyxHQUFHQyxXQUFXLENBQUNGLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7O0VBRXBEO0VBQ0EsTUFBTUcsT0FBTyxHQUFHRCxXQUFXLENBQUNGLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzs7RUFFMUQ7RUFDQSxNQUFNSSxXQUFXLEdBQUcsQ0FBQztFQUNyQixNQUFNQyxRQUFRLEdBQUdmLGdCQUFnQixHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztFQUMzQyxNQUFNZ0IsRUFBRSxHQUFHLElBQUlQLFlBQVksQ0FBQ0ssV0FBVyxHQUFHQyxRQUFRLENBQUM7O0VBRW5EO0VBQ0EsS0FBSyxJQUFJ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QUksQ0FBQ0YsT0FBTyxHQUFHcUQsTUFBTSxDQUFDRyxVQUFVO1FBQzVCLE1BQUksSUFBSSxDQUFDdkQsWUFBWSxDQUFDQyxXQUFXLENBQUM7UUFDbEMsSUFBSSxDQUFDSCxXQUFXLEdBQUc7TUFDdkIsQ0FBQztJQUNMO0VBQ0o7O0VBRUE7RUFDQTBELEtBQUtBLENBQUEsRUFBRztJQUNKLElBQUksQ0FBQzVELE1BQU0sQ0FBQ3FELE9BQU8sQ0FBQyxDQUFBQyxDQUFDLEtBQUlBLENBQUMsQ0FBQ3pELElBQUksQ0FBQyxDQUFDLENBQUM7SUFDbEMsSUFBSSxDQUFDSSxNQUFNLENBQUNvRCxPQUFPLENBQUMsQ0FBQWpKLENBQUMsS0FBSUEsQ0FBQyxDQUFDeUYsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNsQyxJQUFJLENBQUNHLE1BQU0sQ0FBQ1EsTUFBTSxHQUFHLENBQUM7SUFDdEIsSUFBSSxDQUFDUCxNQUFNLENBQUNPLE1BQU0sR0FBRyxDQUFDO0VBQzFCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdXRvZGVzay5FeHRlbnNpb25zLy4vZXh0ZW5zaW9ucy9WaXN1YWxDbHVzdGVycy9DbHVzdGVyR2l6bW8uanM/ZGY1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8vIERpc2FibGUgcGFja2VkIG5vcm1hbHMgZm9yIG5vdywgYmVjYXVzZSBpdCBzb21ldGltZXMgY2F1c2VzIHdyb25nIHZhbHVlcyBpbiB0aGUgbm9ybWFsLWRlcHRoLWJ1ZmZlciAobm90IGNsZWFyIHdoeSkuXG4vLyBUaGUgbnVtYmVyIG9mIGNsdXN0ZXIgYm94ZXMgaXMgc21hbGwgYW55d2F5LCBzbyB1c2luZyB1bnBhY2tlZCBpcyBva2F5IGhlcmUuXG5jb25zdCBVc2VQYWNrZWROb3JtYWxzID0gZmFsc2U7XG5cbmNvbnN0IGF2cCA9IEF1dG9kZXNrLlZpZXdpbmcuUHJpdmF0ZTtcblxuLy8gQ3JlYXRlcyBhIHF1YWQgd2l0aCB4eSBpbiBbLTAuNSwgMC41XSBhbmQgej0wLiBOb3JtYWwgaXMgK3pcbmNvbnN0IGNyZWF0ZVVuaXRRdWFkR2VvbSA9ICgpID0+IHtcblxuICAgIGNvbnN0IGwgPSAtIDAuNTtcbiAgICBjb25zdCBoID0gKyAwLjU7XG5cbiAgICAvLyB2ZXJ0ZXggcG9zaXRpb25zICgzLWZsb2F0cyBwZXIgdmVydGV4KVxuICAgIGNvbnN0IHBvc2l0aW9ucyA9IEZsb2F0MzJBcnJheS5mcm9tKFtcbiAgICAgICAgbCwgbCwgMCxcbiAgICAgICAgbCwgaCwgMCxcbiAgICAgICAgaCwgbCwgMCxcbiAgICAgICAgaCwgaCwgMCxcbiAgICBdKTtcblxuICAgIC8vIGluZGV4IGJ1ZmZlciBmb3IgdHJpYW5nbGVzXG4gICAgY29uc3QgaW5kaWNlcyA9IFVpbnQxNkFycmF5LmZyb20oWzAsIDMsIDEsIDAsIDIsIDNdKTtcblxuICAgIC8vIGluZGV4IGJ1ZmZlciBmb3IgZWRnZXNcbiAgICBjb25zdCBpYmxpbmVzID0gVWludDE2QXJyYXkuZnJvbShbMCwgMSwgMSwgMywgMywgMiwgMiwgMF0pO1xuXG4gICAgLy8gY3JlYXRlIGludGVybGVhdmVkIHZlcnRleCBidWZmZXJcbiAgICBjb25zdCB2ZXJ0ZXhDb3VudCA9IDQ7ICAgIFxuICAgIGNvbnN0IHZic3RyaWRlID0gVXNlUGFja2VkTm9ybWFscyA/IDQgOiA2OyAvLyBmbG9hdDMyIHZhbHVlcyBwZXIgdmVydGV4XG4gICAgY29uc3QgdmIgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRleENvdW50ICogdmJzdHJpZGUpO1xuXG4gICAgLy8gd3JpdGUgcG9zaXRpb25zIHRvIGludGVybGVhdmVkIGJ1ZmZlclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBzcmNPZmZzZXQgPSAzICogaTtcbiAgICAgICAgY29uc3QgZHN0T2Zmc2V0ID0gdmJzdHJpZGUgKiBpO1xuICAgICAgICB2Yltkc3RPZmZzZXRdICAgICA9IHBvc2l0aW9uc1tzcmNPZmZzZXRdO1xuICAgICAgICB2Yltkc3RPZmZzZXQgKyAxXSA9IHBvc2l0aW9uc1tzcmNPZmZzZXQgKyAxXTtcbiAgICAgICAgdmJbZHN0T2Zmc2V0ICsgMl0gPSBwb3NpdGlvbnNbc3JjT2Zmc2V0ICsgMl07XG4gICAgfVxuXG4gICAgaWYgKFVzZVBhY2tlZE5vcm1hbHMpIHtcbiAgICAgICAgLy8gZW5jb2RlICgwLDAsMSkgYXMgcGFja2VkIFVpbnQxNiBub3JtYWxcbiAgICAgICAgY29uc3QgdG9VaW50MTYgPSAweEZGRkY7ICAgLy8gZm9yIHVwc2NhbGluZyBmcm9tIFswLDFdLWZsb2F0cyB0byBVaW50MTYtc2NhbGVcbiAgICAgICAgY29uc3QgbnggPSAwLjUgKiB0b1VpbnQxNjsgXG4gICAgICAgIGNvbnN0IG55ID0gMS4wICogdG9VaW50MTY7XG5cbiAgICAgICAgLy8gVGhlIGZpcnN0IDMgZmxvYXRzIHBlciB2ZXJ0ZXggYXJlIHVzZWQgYnkgcG9zaXRpb25zLiBcbiAgICAgICAgLy8gQ291bnRpbmcgaW4gVWludDE2IHZhbHVlcywgdGhpcyBtYWtlcyA2LlxuICAgICAgICBjb25zdCBub3JtYWxPZmZzZXQgPSA2O1xuXG4gICAgICAgIC8vIHdyaXRlIG5vcm1hbHMgdG8gaW50ZXJsZWF2ZWQgYnVmZmVyXG4gICAgICAgIGNvbnN0IHZiVWludDE2ID0gbmV3IFVpbnQxNkFycmF5KHZiLmJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHZiVWludDE2U3RyaWRlID0gdmJzdHJpZGUgKiAyOyAvLyAyIFVpbnQxNiBwZXIgZmxvYXQzMlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRzdE9mZnNldCA9IHZiVWludDE2U3RyaWRlICogaSArIG5vcm1hbE9mZnNldDtcbiAgICAgICAgICAgIHZiVWludDE2W2RzdE9mZnNldF0gICAgID0gbng7XG4gICAgICAgICAgICB2YlVpbnQxNltkc3RPZmZzZXQgKyAxXSA9IG55O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsT2Zmc2V0ID0gMztcblxuICAgICAgICAvLyB3cml0ZSBub3JtYWxzIHRvIGludGVybGVhdmVkIGJ1ZmZlclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRzdE9mZnNldCA9IHZic3RyaWRlICogaSArIG5vcm1hbE9mZnNldDtcbiAgICAgICAgICAgIHZiW2RzdE9mZnNldF0gICAgID0gMDtcbiAgICAgICAgICAgIHZiW2RzdE9mZnNldCArIDFdID0gMDtcbiAgICAgICAgICAgIHZiW2RzdE9mZnNldCArIDJdID0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNyZWF0ZSByZXN1bHQgZ2VvbWV0cnlcbiAgICBjb25zdCBnZW9tID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG5cbiAgICBnZW9tLnZic3RyaWRlID0gdmJzdHJpZGU7XG4gICAgZ2VvbS52YiAgICAgICA9IHZiO1xuICAgIGdlb20uaWIgICAgICAgPSBpbmRpY2VzO1xuICAgIGdlb20uaWJsaW5lcyAgPSBpYmxpbmVzO1xuICAgIC8vIHBvc2l0aW9uIGF0dHJpYnV0ZVxuICAgIHZhciBhdHRyUG9zID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh1bmRlZmluZWQsIDMpO1xuICAgIGF0dHJQb3Mub2Zmc2V0ID0gMDtcbiAgICBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24gPSBhdHRyUG9zO1xuICAgIFxuICAgIC8vIG5vcm1hbCBhdHRyaWJ1dGVcbiAgICB2YXIgYXR0ck5vcm1hbCA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodW5kZWZpbmVkLCAzKTtcbiAgICBhdHRyTm9ybWFsLm9mZnNldCA9IDM7XG4gICAgYXR0ck5vcm1hbC5ieXRlc1Blckl0ZW0gPSBVc2VQYWNrZWROb3JtYWxzID8gMiA6IDY7XG4gICAgYXR0ck5vcm1hbC5ub3JtYWxpemVkID0gdHJ1ZTtcbiAgICBnZW9tLmF0dHJpYnV0ZXMubm9ybWFsID0gYXR0ck5vcm1hbDtcblxuICAgIC8vIGluZGV4IGF0dHJpYnV0ZVxuICAgIHZhciBhdHRySW5kZXggPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHVuZGVmaW5lZCwgMSk7XG4gICAgYXR0ckluZGV4LmJ5dGVzUGVySXRlbSA9IDI7XG4gICAgZ2VvbS5pbmRleCA9IGF0dHJJbmRleDtcblxuICAgIC8vIGFkZCBhdHRyaWJ1dGUgZm9yIGVkZ2UgcmVuZGVyaW5nXG4gICAgdmFyIGF0dHJJbmRleExpbmVzID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh1bmRlZmluZWQsIDEpO1xuICAgIGF0dHJJbmRleExpbmVzLmJ5dGVzUGVySXRlbSA9IDI7XG4gICAgZ2VvbS5zZXRBdHRyaWJ1dGUoICdpbmRleGxpbmVzJywgYXR0ckluZGV4TGluZXMpO1xuXG4gICAgLy8gYXR0cmlidXRlIGtleXNcbiAgICBnZW9tLmF0dHJpYnV0ZXNLZXlzID0gT2JqZWN0LmtleXMoIGdlb20uYXR0cmlidXRlcyApO1xuXG4gICAgcmV0dXJuIGdlb207XG59O1xuXG4vLyBDcmVhdGVzIGEgcXVhZCBtZXNoIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHotTWluIGZhY2Ugb2YgdGhlIGdpdmVuIGJib3hcbi8vICBAcGFyYW0ge0JveDN9ICAgICAgICAgICAgYmJveFxuLy8gIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9ICB1bml0UXVhZEdlb21cbi8vICBAcGFyYW0ge01hdGVyaWFsfSAgICAgICAgbWF0bWFuICAgICAgIC0gbXVzdCBiZSByZWdpc3RlcmVkIGF0IG1hdGVyaWFsTWFuYWdlciBhbmQgdXNlIHBhY2tlZE5vcm1hbHNcbmNvbnN0IGNyZWF0ZUdpem1vTWVzaCA9IChiYm94LCBtYXRlcmlhbCkgPT4ge1xuXG4gICAgLy8gSW4gdGhlb3J5LCB3ZSBjb3VsZCBzaGFyZSBhIHN0YXRpYyBvbmUgaGVyZS4gSG93ZXZlciwgdGhpcyB3b3VsZCBpbnRyb2R1Y2Ugc3VidGxlIGRldGFpbCBwcm9ibGVtc1xuICAgIC8vIHdoZW4gdXNpbmcgbXVsdGlwbGUgdmlld2VyIGluc3RhbmNlcywgYmVjYXVzZSBXZWJHTFJlbmRlcmVyIGF0dGFjaGVzIGdsLWNvbnRleHQtc3BlY2lmaWMgcmVzb3VyY2VzLlxuICAgIC8vIFRoZSBudW1iZXIgb2YgZ2l6bW8gYm94ZXMgaXMgbm90IGJpZyBhbnl3YXksIHNvIHdoYXQuXG4gICAgY29uc3QgZ2VvbSA9IGNyZWF0ZVVuaXRRdWFkR2VvbSgpO1xuXG4gICAgLy8gY3JlYXRlIG1lc2hcbiAgICB2YXIgYm94TWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb20sIG1hdGVyaWFsKTtcblxuICAgIC8vIG1vdmUgbWVzaCBvcmlnaW4gdG8gY2VudGVyIG9mIGJib3ggei1taW4gZmFjZVxuICAgIGJib3guZ2V0Q2VudGVyKGJveE1lc2gucG9zaXRpb24pO1xuICAgIGJib3guZ2V0U2l6ZShib3hNZXNoLnNjYWxlKTtcbiAgICBib3hNZXNoLnBvc2l0aW9uLnogPSBiYm94Lm1pbi56O1xuXG4gICAgLy8gQXR0YWNoIG1lc2ggYmJveFxuICAgIGJveE1lc2guYm91bmRpbmdCb3ggPSBiYm94LmNsb25lKCk7XG4gICAgYm94TWVzaC5ib3VuZGluZ0JveC5tYXgueiA9IGJib3gubWluLno7IC8vIFRoZSBtZXNoIG9ubHkgc3BhbnMgdGhlIHotbWluIHN1cmZhY2Ugb2YgYmJveFxuXG4gICAgcmV0dXJuIGJveE1lc2g7XG59O1xuXG4vLyBAcGFyYW0ge01hdGVyaWFsTWFuYWdlcn0gbWF0bWFuIC0gbmVlZGVkIHRvIHJlZ2lzdGVyIHRoZSBtYXRlcmlhbFxuY29uc3QgY3JlYXRlR2l6bW9NYXRlcmlhbCA9IChtYXRtYW4pID0+IHtcblxuICAgIC8vIGNyZWF0ZSBtYXRlcmlhbFxuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCh7XG4gICAgICAgIGNvbG9yOiAweGZmZmZmZiwgLy8gd2hpdGVcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsIFxuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlLFxuXG4gICAgICAgIC8vIERpc2FibGUgei1idWZmZXI6IEl0IGRvZXNuJ3Qgd29yayB3aXRoIGZhZGluZyBhbmQgdGhlIHF1YWRzIGFyZSBiZWxvdyBhbGwgdGhlIHNoYXBlcyBhbnl3YXkuXG4gICAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgIH0pO1xuXG4gICAgLy8gTm90ZTogVGhpcyBpcyBtdXN0IGJlIHNldCBzZXBhcmF0ZWx5LCBiZWNhdXNlIGl0J3MgYSBjdXN0b20tbG12IHByb3BlcnR5IGFuZCBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBtYXRlcmlhbCBjdG9yXG4gICAgbWF0ZXJpYWwucGFja2VkTm9ybWFscyA9IFVzZVBhY2tlZE5vcm1hbHM7XG5cbiAgICAvLyBSZWdpc3RlciBhdCBNYXRlcmlhbE1hbmFnZXJcbiAgICBtYXRlcmlhbC5uYW1lID0gJ0NsdXN0ZXJHaXptb01hdGVyaWFsXycgKyBtYXRlcmlhbC5pZDtcbiAgICBtYXRtYW4uYWRkSERSTWF0ZXJpYWwobWF0ZXJpYWwubmFtZSwgbWF0ZXJpYWwpO1xuXG4gICAgcmV0dXJuIG1hdGVyaWFsO1xufTtcblxuY29uc3QgZGlzcG9zZUdpem1vTWVzaCA9IChtZXNoLCBtYXRtYW4pID0+IHtcbiAgICBtZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICBtZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICBtYXRtYW4ucmVtb3ZlTWF0ZXJpYWwobWVzaC5tYXRlcmlhbC5uYW1lKTtcbn07XG5cbi8vIEEgQ2x1c3Rlckdpem1vIGlzIGEgcXVhZCBiZWxvdyBhbiBvYmplY3QgY2x1c3RlciB0aGF0IGhlbHBzIHRvIGRpc3Rpbmd1aXNoIGRpZmZlcmVudCBjbHVzdGVycy5cbmV4cG9ydCBjbGFzcyBDbHVzdGVyR2l6bW8ge1xuXG4gICAgLy8gQHBhcmFtIHtCb3gzfSAgIGNsdXN0ZXJCb3ggLSBiYm94IG9mIHRoZSBjbHVzdGVyXG4gICAgLy8gQHBhcmFtIHtzdHJpbmd9IFttZXNoTmFtZV0gLSBBdHRhY2hlZCB0byB0aGUgbWVzaCB0byBzaW1wbGlmeSBkZWJ1Z2dpbmdcbiAgICBjb25zdHJ1Y3Rvcih2aWV3ZXIsIGNsdXN0ZXJCb3gsIG1lc2hOYW1lKSB7XG5cbiAgICAgICAgdGhpcy52aWV3ZXIgPSB2aWV3ZXI7XG5cbiAgICAgICAgLy8gY3JlYXRlIG1lc2hcbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBjcmVhdGVHaXptb01hdGVyaWFsKHZpZXdlci5pbXBsLm1hdG1hbigpKTtcbiAgICAgICAgdGhpcy5tZXNoID0gY3JlYXRlR2l6bW9NZXNoKGNsdXN0ZXJCb3gsIG1hdGVyaWFsKTtcblxuICAgICAgICB0aGlzLm1lc2gubmFtZSA9IG1lc2hOYW1lO1xuXG4gICAgICAgIC8vIGFkZCBpdCB0byB2aWV3ZXIgc2NlbmVcbiAgICAgICAgdGhpcy52aWV3ZXIuaW1wbC5zY2VuZS5hZGQodGhpcy5tZXNoKTtcblxuICAgICAgICAvLyBGb3Igc21vb3RoIGZhZGVJbi9PdXRcbiAgICAgICAgY29uc3Qgc2V0T3BhY2l0eSA9IHQgPT4ge1xuICAgICAgICAgICAgLy8gRmFkZS1pbiBxdWFkXG4gICAgICAgICAgICAgdGhpcy5tZXNoLm1hdGVyaWFsLm9wYWNpdHkgPSB0O1xuXG4gICAgICAgICAgICAgLy8gRmFkZS1pbiBvdXRsaW5lOiBFZGdlcyBzaG91bGQgaGF2ZSAwLjUgb3BhY2l0eSB3aGVuIGZ1bGx5IGZhZGVkIGluXG4gICAgICAgICAgICAgdGhpcy5tZXNoLm1hdGVyaWFsLmVkZ2VPcGFjaXR5ID0gMC41ICogdDtcblxuICAgICAgICAgICAgIHRoaXMudmlld2VyLmltcGwuaW52YWxpZGF0ZSh0cnVlLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vcGFjaXR5UGFyYW0gPSBuZXcgYXZwLkFuaW1hdGVkUGFyYW0oMC4wLCBzZXRPcGFjaXR5LCAxLjApO1xuXG4gICAgICAgIC8vIEluaXRpYWwgZmFkZS1pblxuICAgICAgICB0aGlzLm9wYWNpdHlQYXJhbS5mYWRlVG8oMSk7XG4gICAgfVxuXG4gICAgZHRvcigpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGZyb20gdmlld2VyIHNjZW5lXG4gICAgICAgIHRoaXMudmlld2VyLmltcGwuc2NlbmUucmVtb3ZlKHRoaXMubWVzaCk7XG4gICAgICAgIHRoaXMudmlld2VyLmltcGwuaW52YWxpZGF0ZSh0cnVlLCB0cnVlKTtcblxuICAgICAgICAvLyBkaXNwb3NlIGdwdSByZXNvdXJjZXNcbiAgICAgICAgZGlzcG9zZUdpem1vTWVzaCh0aGlzLm1lc2gsIHRoaXMudmlld2VyLmltcGwubWF0bWFuKCkpO1xuXG4gICAgICAgIHRoaXMubWVzaCAgID0gbnVsbDtcbiAgICAgICAgdGhpcy52aWV3ZXIgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIEZhZGUgb3V0IGFuZCBkaXNwb3NlIG1lc2ggd2hlbiBkb25lXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5vcGFjaXR5UGFyYW0uZmFkZVRvKDAuMCwgKCk9PnRoaXMuZHRvcigpKTtcbiAgICB9XG59XG5cbi8vIENsdXN0ZXJHaXptb0NvbnRyb2xsZXIgdGFrZXMgY2FyZSB0aGF0IENsdXN0ZXJHaXptb3MgYW5kIGNvcnJlc3BvbmRpbmcgbGFiZWxzIGFyZSBjcmVhdGVkL2Rpc3Bvc2VkIGFjY29yZGluZyB0byB0aGUgY3VycmVudGx5IHNob3duIGxheW91dC5cbmV4cG9ydCBjbGFzcyBDbHVzdGVyR2l6bW9Db250cm9sbGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKHZpZXdlcikge1xuXG4gICAgICAgIHRoaXMudmlld2VyID0gdmlld2VyO1xuXG4gICAgICAgIHRoaXMuZ2l6bW9zID0gW107IC8vIENsdXN0ZXJHaXptb1tdXG4gICAgICAgIHRoaXMubGFiZWxzID0gW107IC8vIExhYmVsM0RbXVxuXG4gICAgICAgIC8vIFdlIGRlbGF5IGZhZGUtaW4sIHNvIHRoYXQgZ2l6bW9zL2xhYmVscyBhcHBlYXIgc2hvcnRseSBiZWZvcmUgdGhlIGNsdXN0ZXIgYW5pbWF0aW9uIGVuZHNcbiAgICAgICAgdGhpcy5mYWRlSW5EZWxheSA9IDEuODsgLy8gaW4gc2Vjb25kc1xuICAgICAgICB0aGlzLnRpbWVySWQgPSBudWxsO1xuICAgIH1cblxuICAgIGNyZWF0ZUdpem1vcyhzY2VuZUxheW91dCkge1xuXG4gICAgICAgIC8vIEZvciBlYWNoIGNsdXN0ZXIuLi5cbiAgICAgICAgY29uc3QgbGF5b3V0cyA9IHNjZW5lTGF5b3V0LmNsdXN0ZXJMYXlvdXRzO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bGF5b3V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGF5b3V0ID0gbGF5b3V0c1tpXTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIHF1YWQgZ2l6bW9cbiAgICAgICAgICAgIGNvbnN0IGJib3ggPSBsYXlvdXQuZ2V0QkJveCgpO1xuICAgICAgICAgICAgY29uc3QgZ2l6bW8gPSBuZXcgQ2x1c3Rlckdpem1vKHRoaXMudmlld2VyLCBiYm94LCBsYXlvdXQuY2x1c3Rlci5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZ2l6bW9zLnB1c2goZ2l6bW8pO1xuXG4gICAgICAgICAgICAvLyBnZXQgbGFiZWwgcG9zaXRpb24gKGNlbnRlciBvZiB0aGUgYmJveCB6TWluLWZhY2UpXG4gICAgICAgICAgICBjb25zdCBsYWJlbFBvcyA9IGJib3guZ2V0Q2VudGVyKG5ldyBUSFJFRS5WZWN0b3IzKCkpO1xuICAgICAgICAgICAgbGFiZWxQb3MueiA9IGJib3gubWluLno7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBsYWJlbFxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KGxheW91dCk7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IG5ldyBBdXRvZGVzay5FZGl0M0QuTGFiZWwzRCh0aGlzLnZpZXdlciwgbGFiZWxQb3MsIHRleHQpO1xuICAgICAgICAgICAgdGhpcy5sYWJlbHMucHVzaChsYWJlbCk7XG5cbiAgICAgICAgICAgIC8vIEhpZGUgbGFiZWwgaWYgQ2x1c3Rlckdpem1vIHNpemUgb24gc2NyZWVuIGlzIGJlbG93IE1pblBpeGVscyB0aHJlc2hvbGQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gTm90ZTogV2UgY291bGQgdXNlIHRoZSBzY3JlZW4tc2l6ZSBvZiB0aGUgbGFiZWwgdGV4dC4gSG93ZXZlciwgdGhpcyBsb29rcyBjb25mdXNpbmdcbiAgICAgICAgICAgIC8vICAgICAgIGlmIHNvbWUgY2x1c3RlciBsYWJlbHMgYXJlIHNob3duIGFuZCBvdGhlcnMgYXJlIG5vdCAoZHVlIHRvIGxvbmdlciB0ZXh0IHRoYXQgeW91IGRvbid0IHNlZSkuXG4gICAgICAgICAgICAvLyAgICAgICBTbywgaXQgbG9va3MgbW9yZSBjb25zaXN0ZW50IHRvIHVzZSBhIGZpeGVkIG1pblBpeGVsU2l6ZSBmb3IgYWxsIGNsdXN0ZXJzLlxuICAgICAgICAgICAgLy8gICAgICAgRm9yIHN1cGVyLWxvbmcgY2x1c3RlciBuYW1lcywgd2Ugd2lsbCBpbnRyb2R1Y2UgYWJicmV2aWF0aW9ucyBpbnN0ZWFkLlxuICAgICAgICAgICAgY29uc3QgTWluUGl4ZWxzID0gNzU7IFxuICAgICAgICAgICAgbGFiZWwuc2V0V29ybGRCb3goZ2l6bW8ubWVzaC5ib3VuZGluZ0JveCwgTWluUGl4ZWxzKTtcblxuICAgICAgICAgICAgLy8gV2hlbiBjbGlja2luZyBhIGxhYmVsLCBmbHkgdG8gdGhlIGNsdXN0ZXJcbiAgICAgICAgICAgIGNvbnN0IGZseVRvQ2x1c3RlciA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy52aWV3ZXIuaW1wbC5jYW1lcmE7XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgY2x1c3Rlci1wbGF0Zm9ybSBjZW50ZXIgYW5kIGJveCBzaXplXG4gICAgICAgICAgICAgICAgY29uc3QgZ2l6bW9Cb3ggPSBnaXptby5tZXNoLmJvdW5kaW5nQm94O1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBnaXptb0JveC5nZXRDZW50ZXIobmV3IFRIUkVFLlZlY3RvcjMoKSk7IFxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBnaXptb0JveC5nZXRTaXplKG5ldyBUSFJFRS5WZWN0b3IzKCkpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0dXAgdmlldyBkaWFnb25hbGx5IHRvIGxvb2sgYXQgcFxuICAgICAgICAgICAgICAgIGNvbnN0IGRzdFZpZXcgPSBjYW1lcmEuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBkc3RWaWV3LnRhcmdldC5jb3B5KHApO1xuXG4gICAgICAgICAgICAgICAgLy8gZ2V0IGN1cnJlbnQgZGlzdGFuY2UgZnJvbSB0YXJnZXQgcG9pbnRcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJEaXN0YW5jZSA9IGNhbWVyYS5wb3NpdGlvbi5kaXN0YW5jZVRvKHApO1xuXG4gICAgICAgICAgICAgICAgLy8gUGxhY2UgdGhlIGNhbWVyYSBvbiB0aGUgbGluZSBiZXR3ZWVuIHRhcmdldCBhbmQgc3RhcnQgY2FtZXJhIHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIC8vIENob29zZSBkaXN0YW5jZSBjbG9zZSBlbm91Z2ggdG8gdGhlIGNsdXN0ZXIgdG8gY2xlYXJseSBmb2N1cyBpdC5cbiAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IE1hdGgubWF4KHNpemUueCwgc2l6ZS55LCBzaXplLnopO1xuICAgICAgICAgICAgICAgIGRpc3QgICAgID0gTWF0aC5taW4oZGlzdCwgY3VyRGlzdGFuY2UpOyAvLyBpZiBhbHJlYWR5IGNsb3NlLCBuZXZlciBtb3ZlIGF3YXkgZnJvbSB0YXJnZXRcbiAgICAgICAgICAgICAgICBsZXQgZGlyICA9IGNhbWVyYS5wb3NpdGlvbi5jbG9uZSgpLnN1YihwKS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICBkc3RWaWV3LnBvc2l0aW9uLnNldChcbiAgICAgICAgICAgICAgICAgICAgcC54ICsgZGlyLnggKiBkaXN0LFxuICAgICAgICAgICAgICAgICAgICBwLnkgKyBkaXIueSAqIGRpc3QsXG4gICAgICAgICAgICAgICAgICAgIHAueiArIGRpci56ICogZGlzdCxcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBhdnAuZmx5VG9WaWV3KHRoaXMudmlld2VyLCBkc3RWaWV3LCAxLjUpO1xuXG4gICAgICAgICAgICAgICAgLy8gTWFyayBjbGljayBhcyBjb25zdW1lZCwgc28gdGhhdCBpdCBkb2Vzbid0IHRyaWdnZXIgc2VsZWN0aW9uIG9mIG9iamVjdHMgYmVoaW5kIHRoZSBsYWJlbC5cbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxhYmVsLmNvbnRhaW5lci5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgICAgICAgICAgbGFiZWwuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZmx5VG9DbHVzdGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldExhYmVsVGV4dChsYXlvdXQpIHtcbiAgICAgICAgbGV0IHRleHQgPSBsYXlvdXQuY2x1c3Rlci5uYW1lO1xuXG4gICAgICAgIC8vIFJlbW92ZSBcIlJldml0IFwiIHByZWZpeFxuICAgICAgICAvLyBGb3Igbm93LCB3ZSBoYXJkLXdpcmUgdGhpcywgYnV0IHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjdXN0b21pemFibGUgYnkgY2xpZW50cyBsYXRlci5cbiAgICAgICAgY29uc3QgcHJlZml4ID0gJ1Jldml0ICc7XG4gICAgICAgIGlmIChpc05hTih0ZXh0KSAmJiB0ZXh0LnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuXG4gICAgZGlzcG9zZUdpem1vcygpIHtcbiAgICAgICAgdGhpcy5naXptb3MuZm9yRWFjaChnID0+IGcuZGlzcG9zZSgpKTtcbiAgICAgICAgdGhpcy5sYWJlbHMuZm9yRWFjaChsID0+IGwuZGlzcG9zZSgpKTtcbiAgICAgICAgdGhpcy5naXptb3MubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5sYWJlbHMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICAgICAgLy8gSWYgYSBkZWxheWVkIGZhZGUtaW4gb2YgZ2l6bW9zIGlzIHBlbmRpbmcgZm9yIHByaW9yIGxheW91dCwgY2FuY2VsIGl0XG4gICAgY2FuY2VsVGltZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVySWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICAgICAgICAgIHRoaXMudGltZXJJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkxheW91dENoYW5nZWQoc2NlbmVMYXlvdXQpIHtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGVyZSBpcyBubyBjb25jdXJyZW50IGRlbGF5ZWQgZmFkZS1pbiBvZiBhIHByaW9yIGxheW91dFxuICAgICAgICB0aGlzLmNhbmNlbFRpbWVyKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBGYWRlLW91dCBhbmQgZGlzcG9zZSBhbnkgb3V0ZGF0ZWQgZ2l6bW9zXG4gICAgICAgIHRoaXMuZGlzcG9zZUdpem1vcygpO1xuICAgIFxuICAgICAgICAvLyBGYWRlLWluIG5ldyBnaXptb3MgYWZ0ZXIgc29tZSBkZWxheVxuICAgICAgICBpZiAoc2NlbmVMYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXJJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgICgpPT50aGlzLmNyZWF0ZUdpem1vcyhzY2VuZUxheW91dCksXG4gICAgICAgICAgICAgICAgdGhpcy5mYWRlSW5EZWxheSAqIDEwMDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXNwb3NlIGFsbCByZXNvdXJjZXMgaW1tZWRpYXRlbHlcbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5naXptb3MuZm9yRWFjaChnID0+IGcuZHRvcigpKTtcbiAgICAgICAgdGhpcy5sYWJlbHMuZm9yRWFjaChsID0+IGwuZHRvcigpKTtcbiAgICAgICAgdGhpcy5naXptb3MubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5sYWJlbHMubGVuZ3RoID0gMDtcbiAgICB9XG59XG5cbiJdLCJuYW1lcyI6WyJVc2VQYWNrZWROb3JtYWxzIiwiYXZwIiwiQXV0b2Rlc2siLCJWaWV3aW5nIiwiUHJpdmF0ZSIsImNyZWF0ZVVuaXRRdWFkR2VvbSIsImwiLCJoIiwicG9zaXRpb25zIiwiRmxvYXQzMkFycmF5IiwiZnJvbSIsImluZGljZXMiLCJVaW50MTZBcnJheSIsImlibGluZXMiLCJ2ZXJ0ZXhDb3VudCIsInZic3RyaWRlIiwidmIiLCJpIiwic3JjT2Zmc2V0IiwiZHN0T2Zmc2V0IiwidG9VaW50MTYiLCJueCIsIm55Iiwibm9ybWFsT2Zmc2V0IiwidmJVaW50MTYiLCJidWZmZXIiLCJ2YlVpbnQxNlN0cmlkZSIsImdlb20iLCJUSFJFRSIsIkJ1ZmZlckdlb21ldHJ5IiwiaWIiLCJhdHRyUG9zIiwiQnVmZmVyQXR0cmlidXRlIiwidW5kZWZpbmVkIiwib2Zmc2V0IiwiYXR0cmlidXRlcyIsInBvc2l0aW9uIiwiYXR0ck5vcm1hbCIsImJ5dGVzUGVySXRlbSIsIm5vcm1hbGl6ZWQiLCJub3JtYWwiLCJhdHRySW5kZXgiLCJpbmRleCIsImF0dHJJbmRleExpbmVzIiwic2V0QXR0cmlidXRlIiwiYXR0cmlidXRlc0tleXMiLCJPYmplY3QiLCJrZXlzIiwiY3JlYXRlR2l6bW9NZXNoIiwiYmJveCIsIm1hdGVyaWFsIiwiYm94TWVzaCIsIk1lc2giLCJnZXRDZW50ZXIiLCJnZXRTaXplIiwic2NhbGUiLCJ6IiwibWluIiwiYm91bmRpbmdCb3giLCJjbG9uZSIsIm1heCIsImNyZWF0ZUdpem1vTWF0ZXJpYWwiLCJtYXRtYW4iLCJNZXNoUGhvbmdNYXRlcmlhbCIsImNvbG9yIiwidHJhbnNwYXJlbnQiLCJvcGFjaXR5Iiwic2lkZSIsIkRvdWJsZVNpZGUiLCJkZXB0aFRlc3QiLCJkZXB0aFdyaXRlIiwicGFja2VkTm9ybWFscyIsIm5hbWUiLCJpZCIsImFkZEhEUk1hdGVyaWFsIiwiZGlzcG9zZUdpem1vTWVzaCIsIm1lc2giLCJnZW9tZXRyeSIsImRpc3Bvc2UiLCJyZW1vdmVNYXRlcmlhbCIsIkNsdXN0ZXJHaXptbyIsImNvbnN0cnVjdG9yIiwidmlld2VyIiwiY2x1c3RlckJveCIsIm1lc2hOYW1lIiwiaW1wbCIsInNjZW5lIiwiYWRkIiwic2V0T3BhY2l0eSIsInQiLCJlZGdlT3BhY2l0eSIsImludmFsaWRhdGUiLCJvcGFjaXR5UGFyYW0iLCJBbmltYXRlZFBhcmFtIiwiZmFkZVRvIiwiZHRvciIsInJlbW92ZSIsIkNsdXN0ZXJHaXptb0NvbnRyb2xsZXIiLCJnaXptb3MiLCJsYWJlbHMiLCJmYWRlSW5EZWxheSIsInRpbWVySWQiLCJjcmVhdGVHaXptb3MiLCJzY2VuZUxheW91dCIsImxheW91dHMiLCJjbHVzdGVyTGF5b3V0cyIsImxlbmd0aCIsImxheW91dCIsImdldEJCb3giLCJnaXptbyIsImNsdXN0ZXIiLCJwdXNoIiwibGFiZWxQb3MiLCJWZWN0b3IzIiwidGV4dCIsImdldExhYmVsVGV4dCIsImxhYmVsIiwiRWRpdDNEIiwiTGFiZWwzRCIsIk1pblBpeGVscyIsInNldFdvcmxkQm94IiwiZmx5VG9DbHVzdGVyIiwiZSIsImNhbWVyYSIsImdpem1vQm94IiwicCIsInNpemUiLCJkc3RWaWV3IiwidGFyZ2V0IiwiY29weSIsImN1ckRpc3RhbmNlIiwiZGlzdGFuY2VUbyIsImRpc3QiLCJNYXRoIiwieCIsInkiLCJkaXIiLCJzdWIiLCJub3JtYWxpemUiLCJzZXQiLCJmbHlUb1ZpZXciLCJzdG9wUHJvcGFnYXRpb24iLCJjb250YWluZXIiLCJzdHlsZSIsInBvaW50ZXJFdmVudHMiLCJhZGRFdmVudExpc3RlbmVyIiwicHJlZml4IiwiaXNOYU4iLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwiZGlzcG9zZUdpem1vcyIsImZvckVhY2giLCJnIiwiY2FuY2VsVGltZXIiLCJ3aW5kb3ciLCJjbGVhclRpbWVvdXQiLCJvbkxheW91dENoYW5nZWQiLCJzZXRUaW1lb3V0IiwicmVzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./extensions/VisualClusters/ClusterGizmo.js\n");

                /***/
            }),

        /***/
        "./extensions/VisualClusters/ClusterLayout.js":
            /*!****************************************************!*\
              !*** ./extensions/VisualClusters/ClusterLayout.js ***!
              \****************************************************/
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClusterRowLayout: () => (/* binding */ ClusterRowLayout),\n/* harmony export */   ClusterSetLayout: () => (/* binding */ ClusterSetLayout),\n/* harmony export */   ShapeBoxes: () => (/* reexport safe */ _ShapeBoxes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _AnimState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimState.js */ \"./extensions/VisualClusters/AnimState.js\");\n/* harmony import */ var _ShapeBoxes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ShapeBoxes.js */ \"./extensions/VisualClusters/ShapeBoxes.js\");\n\n\n\n\nconst tmpBox = new THREE.Box3();\n\n// Rotate an item by 90 degrees to make sure that width >= height. \n// This is done in a way that the box minPoint keeps the same.\n// \n// Note: Rotations using animTransform rotate around the world origin\n//\n// @param {THREE.Box3}      box - Original worldBox of a shape (without any animTransform applied)\n// @param {ObjectAnimState} dst - animState on which we set the rotation\nconst applyAlignmentTransform = (box, dst) => {\n\n  // rotate by 90 degrees\n  let angle = 90;\n  let axis = new THREE.Vector3(0, 0, 1);\n  dst.rot.setFromAxisAngle(axis, THREE.Math.degToRad(angle));\n\n  // Rotations work around the world origin.\n  // Now, we modify the move vector to make sure that the bbox keeps the same\n\n  // get rotation as matrix\n  let rotTf = new THREE.Matrix4().makeRotationFromQuaternion(dst.rot);\n\n  // get box after rotation\n  const box2 = tmpBox.copy(box).applyMatrix4(rotTf);\n\n  // modify move vector to obtain the same box minPoint as before rotation\n  // Note that box2.min is not simply the same as we would get when rotating the point box.min. \n  dst.move.sub(box2.min).add(box.min);\n};\n\n// A ClusterRowLayout defines how to line up a group of objects along one or more rows.\nclass ClusterRowLayout {\n\n  constructor(cluster) {\n\n    // MinPoint of the whole cluster.\n    this.position = new THREE.Vector3(0, 0, 0);\n\n    // {Cluster} - The cluster defining the object that this layout refers to\n    this.cluster = cluster;\n\n    // For each dbId cluster.shapeIds[i], positions[i] defines the corresponding position.\n    // Each object is anchored at the bbox minPoint.\n    this.positions = []; // Vector3[]\n\n    // If rotated[i] is true, the shape with id clusterShapeIds[i] will be rotated by 90 degree around z, \n    // so that x/y are swapped - while preserving the bbox minPoint.\n    this.rotated = []; // bool[]\n\n    // Spatial extent of this cluster.\n    this.size = new THREE.Vector3(0, 0, 0);\n  }\n\n  getBBox(optionalTarget) {\n    let target = optionalTarget || new THREE.Box3();\n    target.min.copy(this.position);\n    target.max.copy(this.position).add(this.size);\n    return target;\n  }\n\n  // Modifies the given scene anim state so that all objects in the cluster are properly placed and rotated.\n  //\n  //  @param {SceneAnimState} sceneAnimState - SceneAnimState to be modified.\n  //  @param {Vector3}        offset         - Additional translation offset applied to all objects\n  //  @param {ShapeBoxes}     shapeBoxes     - access to shape bboxes\n  //  @param {RotationAlignment} [rotationAlignment] - Optional: Defines rotations that are applied per shape.\n  apply(sceneAnimState, offset, shapeBoxes, rotationAlignment) {\n\n    // reused tmp-vector\n    const targetPos = new THREE.Vector3();\n\n    // Reused below\n    const tmpBox = new THREE.Box3();\n    const tmpVec = new THREE.Vector3();\n\n    for (let i = 0; i < this.cluster.shapeIds.length; i++) {\n\n      // get shapeId\n      let shapeId = this.cluster.shapeIds[i];\n\n      // init itemPlacement for this shape\n      const animState = new _AnimState_js__WEBPACK_IMPORTED_MODULE_0__.ObjectAnimState(shapeId.dbId);\n\n      // get final position of this shape: \n      targetPos.copy(this.positions[i]) // position of the shape within the cluster\n      .add(this.position) // position of this cluster within the cluster set\n      .add(offset); // cluster set position\n\n      // get original shape minPoint\n      let originalBox = shapeBoxes.getShapeBox(shapeId, tmpBox);\n      const originalPos = originalBox.min;\n\n      // Set move-vector so that originalPos is moved to targePos\n      animState.move.subVectors(targetPos, originalPos);\n\n      if (rotationAlignment) {\n        // Apply rotation\n        rotationAlignment.getShapeRotation(shapeId, animState.rot);\n\n        // Set original shape box center as rotation anchor\n        const shapeBox = shapeBoxes.getUnrotatedShapeBox(shapeId, tmpBox);\n        const center = shapeBox.getCenter(tmpVec);\n        animState.setRotationCenter(center, true);\n      }\n\n      // If needed, apply rotation while keeping bbox.min the same.\n      // Note: When using RotationAlignments, the auto-flip is not needed anymore.\n      //       So, this code path will be removed as soon as the new variant is sufficiently tested.\n      const needsRotate = this.rotated[i];\n      if (needsRotate) {\n\n        // get shape bbox\n        originalBox = shapeBoxes.getShapeBox(shapeId, originalBox);\n\n        // apply rotation\n        applyAlignmentTransform(originalBox, animState);\n      }\n\n      // Add object anim state to scene anim state\n      sceneAnimState.setAnimState(shapeId.modelId, shapeId.dbId, animState);\n    }\n  }\n}\n\n// Defines the placement for a set of object clusters\nclass ClusterSetLayout {\n\n  // @param {ClusterLayout}     layouts\n  // @param {RotationAlignment} [rotationAlignment] - only needed if shapes are rotated for alignment.\n  constructor(layouts, rotationAlignment) {\n\n    // ClusterSet position. ClusterSets are anchored at the minPoint\n    this.position = new THREE.Vector3(0, 0, 0);\n\n    // {ClusterLayout[]}\n    this.clusterLayouts = layouts || [];\n\n    // {RotationAlignment}\n    this.rotationAlignment = rotationAlignment;\n  }\n\n  // Modifies the given scene anim state so that all objects in all cluster are properly placed and rotated.\n  //\n  //  @param {SceneAnimState} sceneAnimState - SceneAnimState to be modified.\n  //  @param {ShapeBoxes}     shapeBoxes     - access to shape bboxes\n  apply(sceneAnimState, shapeBoxes) {\n    this.clusterLayouts.forEach((l) => l.apply(sceneAnimState, this.position, shapeBoxes, this.rotationAlignment));\n  }\n\n  // Creates a SceneAnimState that brings all shapes to their target positions\n  createSceneState(models) {\n    let shapeBoxes = new _ShapeBoxes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](models, this.rotationAlignment);\n    let state = new _AnimState_js__WEBPACK_IMPORTED_MODULE_0__.SceneAnimState(models);\n    this.apply(state, shapeBoxes);\n    return state;\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leHRlbnNpb25zL1Zpc3VhbENsdXN0ZXJzL0NsdXN0ZXJMYXlvdXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBaUU7QUFDeEI7OztBQUd6QyxNQUFNRyxNQUFNLEdBQUcsSUFBSUMsS0FBSyxDQUFDQyxJQUFJLENBQUMsQ0FBQzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyx1QkFBdUIsR0FBR0EsQ0FBQ0MsR0FBRyxFQUFFQyxHQUFHLEtBQUs7O0VBRTFDO0VBQ0EsSUFBSUMsS0FBSyxHQUFHLEVBQUU7RUFDZCxJQUFJQyxJQUFJLEdBQUcsSUFBSU4sS0FBSyxDQUFDTyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDckNILEdBQUcsQ0FBQ0ksR0FBRyxDQUFDQyxnQkFBZ0IsQ0FBQ0gsSUFBSSxFQUFFTixLQUFLLENBQUNVLElBQUksQ0FBQ0MsUUFBUSxDQUFDTixLQUFLLENBQUMsQ0FBQzs7RUFFMUQ7RUFDQTs7RUFFQTtFQUNBLElBQUlPLEtBQUssR0FBRyxJQUFJWixLQUFLLENBQUNhLE9BQU8sQ0FBQyxDQUFDLENBQUNDLDBCQUEwQixDQUFDVixHQUFHLENBQUNJLEdBQUcsQ0FBQzs7RUFFbkU7RUFDQSxNQUFNTyxJQUFJLEdBQUdoQixNQUFNLENBQUNpQixJQUFJLENBQUNiLEdBQUcsQ0FBQyxDQUFDYyxZQUFZLENBQUNMLEtBQUssQ0FBQzs7RUFFakQ7RUFDQTtFQUNBUixHQUFHLENBQUNjLElBQUksQ0FBQ0MsR0FBRyxDQUFDSixJQUFJLENBQUNLLEdBQUcsQ0FBQyxDQUFDQyxHQUFHLENBQUNsQixHQUFHLENBQUNpQixHQUFHLENBQUM7QUFDdkMsQ0FBQzs7QUFFRDtBQUNBLE1BQU1FLGdCQUFnQixDQUFDOztFQUVuQkMsV0FBV0EsQ0FBQ0MsT0FBTyxFQUFFOztJQUVqQjtJQUNBLElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUl6QixLQUFLLENBQUNPLE9BQU8sQ0FBQyxD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SSxDQUFDaEMsS0FBSyxDQUFDaUMsS0FBSyxFQUFFOUIsVUFBVSxDQUFDO0lBQzdCLE9BQU84QixLQUFLO0VBQ2hCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdXRvZGVzay5FeHRlbnNpb25zLy4vZXh0ZW5zaW9ucy9WaXN1YWxDbHVzdGVycy9DbHVzdGVyTGF5b3V0LmpzPzZjY2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JqZWN0QW5pbVN0YXRlLCBTY2VuZUFuaW1TdGF0ZSB9IGZyb20gJy4vQW5pbVN0YXRlLmpzJztcbmltcG9ydCBTaGFwZUJveGVzIGZyb20gJy4vU2hhcGVCb3hlcy5qcyc7XG5cblxuY29uc3QgdG1wQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuLy8gUm90YXRlIGFuIGl0ZW0gYnkgOTAgZGVncmVlcyB0byBtYWtlIHN1cmUgdGhhdCB3aWR0aCA+PSBoZWlnaHQuIFxuLy8gVGhpcyBpcyBkb25lIGluIGEgd2F5IHRoYXQgdGhlIGJveCBtaW5Qb2ludCBrZWVwcyB0aGUgc2FtZS5cbi8vIFxuLy8gTm90ZTogUm90YXRpb25zIHVzaW5nIGFuaW1UcmFuc2Zvcm0gcm90YXRlIGFyb3VuZCB0aGUgd29ybGQgb3JpZ2luXG4vL1xuLy8gQHBhcmFtIHtUSFJFRS5Cb3gzfSAgICAgIGJveCAtIE9yaWdpbmFsIHdvcmxkQm94IG9mIGEgc2hhcGUgKHdpdGhvdXQgYW55IGFuaW1UcmFuc2Zvcm0gYXBwbGllZClcbi8vIEBwYXJhbSB7T2JqZWN0QW5pbVN0YXRlfSBkc3QgLSBhbmltU3RhdGUgb24gd2hpY2ggd2Ugc2V0IHRoZSByb3RhdGlvblxuY29uc3QgYXBwbHlBbGlnbm1lbnRUcmFuc2Zvcm0gPSAoYm94LCBkc3QpID0+IHtcblxuICAgIC8vIHJvdGF0ZSBieSA5MCBkZWdyZWVzXG4gICAgbGV0IGFuZ2xlID0gOTA7XG4gICAgbGV0IGF4aXMgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKTtcbiAgICBkc3Qucm90LnNldEZyb21BeGlzQW5nbGUoYXhpcywgVEhSRUUuTWF0aC5kZWdUb1JhZChhbmdsZSkpO1xuXG4gICAgLy8gUm90YXRpb25zIHdvcmsgYXJvdW5kIHRoZSB3b3JsZCBvcmlnaW4uXG4gICAgLy8gTm93LCB3ZSBtb2RpZnkgdGhlIG1vdmUgdmVjdG9yIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBiYm94IGtlZXBzIHRoZSBzYW1lXG5cbiAgICAvLyBnZXQgcm90YXRpb24gYXMgbWF0cml4XG4gICAgbGV0IHJvdFRmID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihkc3Qucm90KTtcblxuICAgIC8vIGdldCBib3ggYWZ0ZXIgcm90YXRpb25cbiAgICBjb25zdCBib3gyID0gdG1wQm94LmNvcHkoYm94KS5hcHBseU1hdHJpeDQocm90VGYpO1xuXG4gICAgLy8gbW9kaWZ5IG1vdmUgdmVjdG9yIHRvIG9idGFpbiB0aGUgc2FtZSBib3ggbWluUG9pbnQgYXMgYmVmb3JlIHJvdGF0aW9uXG4gICAgLy8gTm90ZSB0aGF0IGJveDIubWluIGlzIG5vdCBzaW1wbHkgdGhlIHNhbWUgYXMgd2Ugd291bGQgZ2V0IHdoZW4gcm90YXRpbmcgdGhlIHBvaW50IGJveC5taW4uIFxuICAgIGRzdC5tb3ZlLnN1Yihib3gyLm1pbikuYWRkKGJveC5taW4pO1xufTtcblxuLy8gQSBDbHVzdGVyUm93TGF5b3V0IGRlZmluZXMgaG93IHRvIGxpbmUgdXAgYSBncm91cCBvZiBvYmplY3RzIGFsb25nIG9uZSBvciBtb3JlIHJvd3MuXG5jbGFzcyBDbHVzdGVyUm93TGF5b3V0IHtcblxuICAgIGNvbnN0cnVjdG9yKGNsdXN0ZXIpIHtcblxuICAgICAgICAvLyBNaW5Qb2ludCBvZiB0aGUgd2hvbGUgY2x1c3Rlci5cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsMCwwKTtcblxuICAgICAgICAvLyB7Q2x1c3Rlcn0gLSBUaGUgY2x1c3RlciBkZWZpbmluZyB0aGUgb2JqZWN0IHRoYXQgdGhpcyBsYXlvdXQgcmVmZXJzIHRvXG4gICAgICAgIHRoaXMuY2x1c3RlciA9IGNsdXN0ZXI7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggZGJJZCBjbHVzdGVyLnNoYXBlSWRzW2ldLCBwb3NpdGlvbnNbaV0gZGVmaW5lcyB0aGUgY29ycmVzcG9uZGluZyBwb3NpdGlvbi5cbiAgICAgICAgLy8gRWFjaCBvYmplY3QgaXMgYW5jaG9yZWQgYXQgdGhlIGJib3ggbWluUG9pbnQuXG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gW107IC8vIFZlY3RvcjNbXVxuXG4gICAgICAgIC8vIElmIHJvdGF0ZWRbaV0gaXMgdHJ1ZSwgdGhlIHNoYXBlIHdpdGggaWQgY2x1c3RlclNoYXBlSWRzW2ldIHdpbGwgYmUgcm90YXRlZCBieSA5MCBkZWdyZWUgYXJvdW5kIHosIFxuICAgICAgICAvLyBzbyB0aGF0IHgveSBhcmUgc3dhcHBlZCAtIHdoaWxlIHByZXNlcnZpbmcgdGhlIGJib3ggbWluUG9pbnQuXG4gICAgICAgIHRoaXMucm90YXRlZCA9IFtdOyAvLyBib29sW11cblxuICAgICAgICAvLyBTcGF0aWFsIGV4dGVudCBvZiB0aGlzIGNsdXN0ZXIuXG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApOyAgICAgICAgXG4gICAgfVxuXG4gICAgZ2V0QkJveChvcHRpb25hbFRhcmdldCkge1xuICAgICAgICBsZXQgdGFyZ2V0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLkJveDMoKTtcbiAgICAgICAgdGFyZ2V0Lm1pbi5jb3B5KHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0YXJnZXQubWF4LmNvcHkodGhpcy5wb3NpdGlvbikuYWRkKHRoaXMuc2l6ZSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLy8gTW9kaWZpZXMgdGhlIGdpdmVuIHNjZW5lIGFuaW0gc3RhdGUgc28gdGhhdCBhbGwgb2JqZWN0cyBpbiB0aGUgY2x1c3RlciBhcmUgcHJvcGVybHkgcGxhY2VkIGFuZCByb3RhdGVkLlxuICAgIC8vXG4gICAgLy8gIEBwYXJhbSB7U2NlbmVBbmltU3RhdGV9IHNjZW5lQW5pbVN0YXRlIC0gU2NlbmVBbmltU3RhdGUgdG8gYmUgbW9kaWZpZWQuXG4gICAgLy8gIEBwYXJhbSB7VmVjdG9yM30gICAgICAgIG9mZnNldCAgICAgICAgIC0gQWRkaXRpb25hbCB0cmFuc2xhdGlvbiBvZmZzZXQgYXBwbGllZCB0byBhbGwgb2JqZWN0c1xuICAgIC8vICBAcGFyYW0ge1NoYXBlQm94ZXN9ICAgICBzaGFwZUJveGVzICAgICAtIGFjY2VzcyB0byBzaGFwZSBiYm94ZXNcbiAgICAvLyAgQHBhcmFtIHtSb3RhdGlvbkFsaWdubWVudH0gW3JvdGF0aW9uQWxpZ25tZW50XSAtIE9wdGlvbmFsOiBEZWZpbmVzIHJvdGF0aW9ucyB0aGF0IGFyZSBhcHBsaWVkIHBlciBzaGFwZS5cbiAgICBhcHBseShzY2VuZUFuaW1TdGF0ZSwgb2Zmc2V0LCBzaGFwZUJveGVzLCByb3RhdGlvbkFsaWdubWVudCkge1xuXG4gICAgICAgIC8vIHJldXNlZCB0bXAtdmVjdG9yXG4gICAgICAgIGNvbnN0IHRhcmdldFBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgLy8gUmV1c2VkIGJlbG93XG4gICAgICAgIGNvbnN0IHRtcEJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG4gICAgICAgIGNvbnN0IHRtcFZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNsdXN0ZXIuc2hhcGVJZHMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgLy8gZ2V0IHNoYXBlSWRcbiAgICAgICAgICAgIGxldCBzaGFwZUlkID0gdGhpcy5jbHVzdGVyLnNoYXBlSWRzW2ldO1xuXG4gICAgICAgICAgICAvLyBpbml0IGl0ZW1QbGFjZW1lbnQgZm9yIHRoaXMgc2hhcGVcbiAgICAgICAgICAgIGNvbnN0IGFuaW1TdGF0ZSA9IG5ldyBPYmplY3RBbmltU3RhdGUoc2hhcGVJZC5kYklkKTtcblxuICAgICAgICAgICAgLy8gZ2V0IGZpbmFsIHBvc2l0aW9uIG9mIHRoaXMgc2hhcGU6IFxuICAgICAgICAgICAgdGFyZ2V0UG9zLmNvcHkodGhpcy5wb3NpdGlvbnNbaV0pIC8vIHBvc2l0aW9uIG9mIHRoZSBzaGFwZSB3aXRoaW4gdGhlIGNsdXN0ZXJcbiAgICAgICAgICAgICAgICAuYWRkKHRoaXMucG9zaXRpb24pICAgICAgICAgICAvLyBwb3NpdGlvbiBvZiB0aGlzIGNsdXN0ZXIgd2l0aGluIHRoZSBjbHVzdGVyIHNldFxuICAgICAgICAgICAgICAgIC5hZGQob2Zmc2V0KTsgICAgICAgICAgICAgICAgICAvLyBjbHVzdGVyIHNldCBwb3NpdGlvblxuXG4gICAgICAgICAgICAvLyBnZXQgb3JpZ2luYWwgc2hhcGUgbWluUG9pbnRcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbEJveCA9IHNoYXBlQm94ZXMuZ2V0U2hhcGVCb3goc2hhcGVJZCwgdG1wQm94KTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUG9zID0gb3JpZ2luYWxCb3gubWluO1xuXG4gICAgICAgICAgICAvLyBTZXQgbW92ZS12ZWN0b3Igc28gdGhhdCBvcmlnaW5hbFBvcyBpcyBtb3ZlZCB0byB0YXJnZVBvc1xuICAgICAgICAgICAgYW5pbVN0YXRlLm1vdmUuc3ViVmVjdG9ycyh0YXJnZXRQb3MsIG9yaWdpbmFsUG9zKTtcblxuICAgICAgICAgICAgaWYgKHJvdGF0aW9uQWxpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgcm90YXRpb25cbiAgICAgICAgICAgICAgICByb3RhdGlvbkFsaWdubWVudC5nZXRTaGFwZVJvdGF0aW9uKHNoYXBlSWQsIGFuaW1TdGF0ZS5yb3QpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0IG9yaWdpbmFsIHNoYXBlIGJveCBjZW50ZXIgYXMgcm90YXRpb24gYW5jaG9yXG4gICAgICAgICAgICAgICAgY29uc3Qgc2hhcGVCb3ggPSBzaGFwZUJveGVzLmdldFVucm90YXRlZFNoYXBlQm94KHNoYXBlSWQsIHRtcEJveCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VudGVyICAgPSBzaGFwZUJveC5nZXRDZW50ZXIodG1wVmVjKTtcbiAgICAgICAgICAgICAgICBhbmltU3RhdGUuc2V0Um90YXRpb25DZW50ZXIoY2VudGVyLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbmVlZGVkLCBhcHBseSByb3RhdGlvbiB3aGlsZSBrZWVwaW5nIGJib3gubWluIHRoZSBzYW1lLlxuICAgICAgICAgICAgLy8gTm90ZTogV2hlbiB1c2luZyBSb3RhdGlvbkFsaWdubWVudHMsIHRoZSBhdXRvLWZsaXAgaXMgbm90IG5lZWRlZCBhbnltb3JlLlxuICAgICAgICAgICAgLy8gICAgICAgU28sIHRoaXMgY29kZSBwYXRoIHdpbGwgYmUgcmVtb3ZlZCBhcyBzb29uIGFzIHRoZSBuZXcgdmFyaWFudCBpcyBzdWZmaWNpZW50bHkgdGVzdGVkLlxuICAgICAgICAgICAgY29uc3QgbmVlZHNSb3RhdGUgPSB0aGlzLnJvdGF0ZWRbaV07XG4gICAgICAgICAgICBpZiAobmVlZHNSb3RhdGUpIHtcblxuICAgICAgICAgICAgICAgIC8vIGdldCBzaGFwZSBiYm94XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxCb3ggPSBzaGFwZUJveGVzLmdldFNoYXBlQm94KHNoYXBlSWQsIG9yaWdpbmFsQm94KTtcblxuICAgICAgICAgICAgICAgIC8vIGFwcGx5IHJvdGF0aW9uXG4gICAgICAgICAgICAgICAgYXBwbHlBbGlnbm1lbnRUcmFuc2Zvcm0ob3JpZ2luYWxCb3gsIGFuaW1TdGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBvYmplY3QgYW5pbSBzdGF0ZSB0byBzY2VuZSBhbmltIHN0YXRlXG4gICAgICAgICAgICBzY2VuZUFuaW1TdGF0ZS5zZXRBbmltU3RhdGUoc2hhcGVJZC5tb2RlbElkLCBzaGFwZUlkLmRiSWQsIGFuaW1TdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIERlZmluZXMgdGhlIHBsYWNlbWVudCBmb3IgYSBzZXQgb2Ygb2JqZWN0IGNsdXN0ZXJzXG5jbGFzcyBDbHVzdGVyU2V0TGF5b3V0IHtcblxuICAgIC8vIEBwYXJhbSB7Q2x1c3RlckxheW91dH0gICAgIGxheW91dHNcbiAgICAvLyBAcGFyYW0ge1JvdGF0aW9uQWxpZ25tZW50fSBbcm90YXRpb25BbGlnbm1lbnRdIC0gb25seSBuZWVkZWQgaWYgc2hhcGVzIGFyZSByb3RhdGVkIGZvciBhbGlnbm1lbnQuXG4gICAgY29uc3RydWN0b3IobGF5b3V0cywgcm90YXRpb25BbGlnbm1lbnQpIHtcblxuICAgICAgICAvLyBDbHVzdGVyU2V0IHBvc2l0aW9uLiBDbHVzdGVyU2V0cyBhcmUgYW5jaG9yZWQgYXQgdGhlIG1pblBvaW50XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygwLDAsMCk7XG5cbiAgICAgICAgLy8ge0NsdXN0ZXJMYXlvdXRbXX1cbiAgICAgICAgdGhpcy5jbHVzdGVyTGF5b3V0cyA9IGxheW91dHMgfHwgW107XG5cbiAgICAgICAgLy8ge1JvdGF0aW9uQWxpZ25tZW50fVxuICAgICAgICB0aGlzLnJvdGF0aW9uQWxpZ25tZW50ID0gcm90YXRpb25BbGlnbm1lbnQ7XG4gICAgfVxuXG4gICAgLy8gTW9kaWZpZXMgdGhlIGdpdmVuIHNjZW5lIGFuaW0gc3RhdGUgc28gdGhhdCBhbGwgb2JqZWN0cyBpbiBhbGwgY2x1c3RlciBhcmUgcHJvcGVybHkgcGxhY2VkIGFuZCByb3RhdGVkLlxuICAgIC8vXG4gICAgLy8gIEBwYXJhbSB7U2NlbmVBbmltU3RhdGV9IHNjZW5lQW5pbVN0YXRlIC0gU2NlbmVBbmltU3RhdGUgdG8gYmUgbW9kaWZpZWQuXG4gICAgLy8gIEBwYXJhbSB7U2hhcGVCb3hlc30gICAgIHNoYXBlQm94ZXMgICAgIC0gYWNjZXNzIHRvIHNoYXBlIGJib3hlc1xuICAgIGFwcGx5KHNjZW5lQW5pbVN0YXRlLCBzaGFwZUJveGVzKSB7XG4gICAgICAgIHRoaXMuY2x1c3RlckxheW91dHMuZm9yRWFjaChsID0+IGwuYXBwbHkoc2NlbmVBbmltU3RhdGUsIHRoaXMucG9zaXRpb24sIHNoYXBlQm94ZXMsIHRoaXMucm90YXRpb25BbGlnbm1lbnQpKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGVzIGEgU2NlbmVBbmltU3RhdGUgdGhhdCBicmluZ3MgYWxsIHNoYXBlcyB0byB0aGVpciB0YXJnZXQgcG9zaXRpb25zXG4gICAgY3JlYXRlU2NlbmVTdGF0ZShtb2RlbHMpIHtcbiAgICAgICAgbGV0IHNoYXBlQm94ZXMgPSBuZXcgU2hhcGVCb3hlcyhtb2RlbHMsIHRoaXMucm90YXRpb25BbGlnbm1lbnQpO1xuICAgICAgICBsZXQgc3RhdGUgPSBuZXcgU2NlbmVBbmltU3RhdGUobW9kZWxzKTtcbiAgICAgICAgdGhpcy5hcHBseShzdGF0ZSwgc2hhcGVCb3hlcyk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7XG4gICAgU2hhcGVCb3hlcyxcbiAgICBDbHVzdGVyUm93TGF5b3V0LFxuICAgIENsdXN0ZXJTZXRMYXlvdXRcbn07XG4iXSwibmFtZXMiOlsiT2JqZWN0QW5pbVN0YXRlIiwiU2NlbmVBbmltU3RhdGUiLCJTaGFwZUJveGVzIiwidG1wQm94IiwiVEhSRUUiLCJCb3gzIiwiYXBwbHlBbGlnbm1lbnRUcmFuc2Zvcm0iLCJib3giLCJkc3QiLCJhbmdsZSIsImF4aXMiLCJWZWN0b3IzIiwicm90Iiwic2V0RnJvbUF4aXNBbmdsZSIsIk1hdGgiLCJkZWdUb1JhZCIsInJvdFRmIiwiTWF0cml4NCIsIm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uIiwiYm94MiIsImNvcHkiLCJhcHBseU1hdHJpeDQiLCJtb3ZlIiwic3ViIiwibWluIiwiYWRkIiwiQ2x1c3RlclJvd0xheW91dCIsImNvbnN0cnVjdG9yIiwiY2x1c3RlciIsInBvc2l0aW9uIiwicG9zaXRpb25zIiwicm90YXRlZCIsInNpemUiLCJnZXRCQm94Iiwib3B0aW9uYWxUYXJnZXQiLCJ0YXJnZXQiLCJtYXgiLCJhcHBseSIsInNjZW5lQW5pbVN0YXRlIiwib2Zmc2V0Iiwic2hhcGVCb3hlcyIsInJvdGF0aW9uQWxpZ25tZW50IiwidGFyZ2V0UG9zIiwidG1wVmVjIiwiaSIsInNoYXBlSWRzIiwibGVuZ3RoIiwic2hhcGVJZCIsImFuaW1TdGF0ZSIsImRiSWQiLCJvcmlnaW5hbEJveCIsImdldFNoYXBlQm94Iiwib3JpZ2luYWxQb3MiLCJzdWJWZWN0b3JzIiwiZ2V0U2hhcGVSb3RhdGlvbiIsInNoYXBlQm94IiwiZ2V0VW5yb3RhdGVkU2hhcGVCb3giLCJjZW50ZXIiLCJnZXRDZW50ZXIiLCJzZXRSb3RhdGlvbkNlbnRlciIsIm5lZWRzUm90YXRlIiwic2V0QW5pbVN0YXRlIiwibW9kZWxJZCIsIkNsdXN0ZXJTZXRMYXlvdXQiLCJsYXlvdXRzIiwiY2x1c3RlckxheW91dHMiLCJmb3JFYWNoIiwibCIsImNyZWF0ZVNjZW5lU3RhdGUiLCJtb2RlbHMiLCJzdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./extensions/VisualClusters/ClusterLayout.js\n");

                /***/
            }),

        /***/
        "./extensions/VisualClusters/RotationAlignment.js":
            /*!********************************************************!*\
              !*** ./extensions/VisualClusters/RotationAlignment.js ***!
              \********************************************************/
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RotationAlignment: () => (/* binding */ RotationAlignment),\n/* harmony export */   collectFragBoxAxes: () => (/* binding */ collectFragBoxAxes),\n/* harmony export */   computeObjectAlignment: () => (/* binding */ computeObjectAlignment),\n/* harmony export */   computeTransformedObjectBox: () => (/* binding */ computeTransformedObjectBox),\n/* harmony export */   findAlignmentRotation: () => (/* binding */ findAlignmentRotation),\n/* harmony export */   getAngleToXAxis: () => (/* binding */ getAngleToXAxis),\n/* harmony export */   getBoxCorner: () => (/* binding */ getBoxCorner),\n/* harmony export */   getRotatedFragmentBox: () => (/* binding */ getRotatedFragmentBox)\n/* harmony export */ });\n// The purpose of this file is to compute the necessary transforms to rotate\n// all objects in a way that...\n//\n//  1. Identical objects are oriented in the same way\n//  2. Objects are horizontally aligned with the main axes x/y to reduce bbox extents.\n//  3. Up-Vector is preserved\n//\n// It also provides methods to consider these rotations during computation of\n// cluster layout and animation.\n\n// @param {Box3}   box\n// @param {number} i - in [0, 7]\nconst getBoxCorner = (box, i) => {\n  return new THREE.Vector3(\n    i & 1 ? box.min.x : box.max.x,\n    i & 2 ? box.min.y : box.max.y,\n    i & 4 ? box.min.z : box.max.z\n  );\n};\n\n// Each element is a corner index. Each pair of two forms a main axis direction.\nconst BoxAxisIndices = Uint32Array.from([\n0, 1, 0, 2, 0, 4]\n);\n\n// Helper class to enumerate the main axis directions of one or more rotated bboxes.\nclass BoxAxes {\n\n  constructor() {\n    // Transforming vertices turned out to be the major cost factor. So we use indexing to reduce it.\n    this.vertices = [];\n\n    this.tmpPoint = new THREE.Vector3();\n  }\n\n  // @param {Box3}    box\n  // @param {Matrix4} matrix - orientation of the box\n  addBox(box, matrix) {\n\n    // It's important to skip empty boxes. Otherwise, we would produce infinite \n    // extents after transforming min/max\n    if (box.isEmpty()) {\n      return;\n    }\n\n    // add 8 box corners\n    for (let i = 0; i < 8; i++) {\n      const p = getBoxCorner(box, i).applyMatrix4(matrix);\n      this.vertices.push(p);\n    }\n  }\n\n  // Sets outAxis.indexA and outAxis.indexB to vertex numbers of the given edge\n  //\n  // @param {number} axisIndex\n  // @param {Object} outAxis.indexA and outAxis.indexB will be set.\n  getAxis(axisIndex, outAxis) {\n    // Get offset where the vertices of the box start\n    const boxIndex = Math.floor(axisIndex / 3); // 3 axes per box\n    const vertexOffset = 8 * boxIndex; // 8 vertices per box\n\n    // Get index into BoxAxisIndices\n    const localIndex = 2 * axisIndex % BoxAxisIndices.length; // 2 values per axis\n\n    outAxis.indexA = vertexOffset + BoxAxisIndices[localIndex];\n    outAxis.indexB = vertexOffset + BoxAxisIndices[localIndex + 1];\n  }\n\n  getAxisCount() {\n    const boxCount = this.vertices.length / 8;\n    const AxesPerBox = 3;\n    return boxCount * AxesPerBox;\n  }\n\n  // Returns bounding rectangle of all boxes if we transform all points by the given matrix\n  //  @param {Box2}    outRect\n  //  @param {Matrix4} matrix\n  getBoundingRect(outRect, matrix) {\n    for (let v of this.vertices) {\n      // add transformed vertex to bbox\n      const p = this.tmpPoint.copy(v).applyMatrix4(matrix);\n      outRect.expandByPoint(p);\n    }\n  }\n};\n\n// Find rotation around z-axis that brings the given (horizontal) direction to the x-axis\n//\n//  @param {Vector2}  dir - Does not need to be normalized\n//  @returns {number} ccw angle in radians. Rotate by this angle to bring dir to xAxis.\nconst getAngleToXAxis = (dir) => {\n  return -Math.atan2(dir.y, dir.x);\n};\n\n// Collects main axes of all fragment geometry boxes and projects them to world-space.\n//  @returns {BoxAxes} \nconst collectFragBoxAxes = (model, dbId) => {\n\n  let boxAxes = new BoxAxes();\n\n  const geomList = model.getGeometryList();\n  const fragList = model.getFragmentList();\n\n  // Reused tmp-values\n  const geomBox = new THREE.Box3();\n  const worldMatrix = new THREE.Matrix4();\n\n  // For each fragment...\n  const it = model.getInstanceTree();\n  it.enumNodeFragments(dbId, (fragId) => {\n\n    // Set geomBox to geometry bbox in object-space (for otg, it will simply be the unit box)\n    const geomId = fragList.getGeometryId(fragId);\n    geomList.getModelBox(geomId, geomBox);\n\n    // get fragment world matrix\n    fragList.getOriginalWorldMatrix(fragId, worldMatrix);\n\n    // collect bbox with transform\n    boxAxes.addBox(geomBox, worldMatrix);\n  });\n  return boxAxes;\n};\n\n// Given vertices and axis directions of bboxes, this function finds a rotation around z so that...\n//  - area of the boundsXY is minimized\n//  - We always have xExtent <= yExtent for boundsXY\n// where boundsXY is the bounding box of the xy-projection of all boxes.\n//\n// Note: We assume here that the optimal solution will align one of the edges with the x-axis.\n//\n//  @param {BoxAxes} boxAxes\n//  @returns {Quaternion}\nconst findAlignmentRotation = (boxAxes) => {\n\n  // Reused in the loop below\n  const edgeDir = new THREE.Vector2();\n  const quaternion = new THREE.Quaternion();\n  const rotMatrix = new THREE.Matrix4();\n  const zAxis = new THREE.Vector3(0, 0, 1);\n  const rect = new THREE.Box2();\n\n  let minArea = Infinity;\n  let bestAngle = null;\n  let minExtent = new THREE.Vector2();\n\n  // An axis direction, given by two indices into boxAxes.vertices\n  const axis = {\n    indexA: 0,\n    indexB: 0\n  };\n  let a = null;\n  let b = null;\n\n  // For each edge...\n  const axisCount = boxAxes.getAxisCount();\n  for (let i = 0; i < axisCount; i++) {\n\n    // get edge\n    boxAxes.getAxis(i, axis);\n    a = boxAxes.vertices[axis.indexA];\n    b = boxAxes.vertices[axis.indexB];\n\n    // get edge direction\n    edgeDir.set(b.x - a.x, b.y - a.y);\n\n    // compute rotation matrix that brings that angle to x-axis (ccw radians)\n    let angleToXAxis = getAngleToXAxis(edgeDir);\n    quaternion.setFromAxisAngle(zAxis, angleToXAxis);\n    rotMatrix.makeRotationFromQuaternion(quaternion);\n\n    // compute xy-bounding rectangle that we get when using this angle\n    boxAxes.getBoundingRect(rect, rotMatrix);\n\n    // compute area\n    const dx = rect.max.x - rect.min.x;\n    const dy = rect.max.y - rect.min.y;\n    const area = dx * dy;\n\n    // If this area is better than our candidates so far, use it\n    if (area < minArea) {\n      // keep rotation that minimized area so far\n      minExtent.set(dx, dy);\n      minArea = area;\n      bestAngle = angleToXAxis;\n    }\n  }\n\n  // If needed, rotate by another 90 degree to ensure xExtent < yExtent.\n  // Note that this doesn't change the area\n  if (minExtent.x > minExtent.y) {\n    bestAngle += THREE.Math.degToRad(90.0);\n  }\n\n  // Compute final quaternion\n  quaternion.setFromAxisAngle(zAxis, bestAngle);\n  return quaternion;\n};\n\n// Computes a rotation transform for a given dbId that aligns the object horizontally, so that:\n//  - xy extent of the bbox is minimized\n//  - xExtent <= yExtent\n// @returns {Quaternion}\nconst computeObjectAlignment = (model, dbId) => {\n\n  // project the main axes of all fragment geometry boxes to world-space\n  const axes = collectFragBoxAxes(model, dbId); // {Vector3[]} with two vectors per edge\n\n  // find rotation that minimizes the x/y-bbox of all transformed boxes\n  return findAlignmentRotation(axes);\n};\n\nconst tmpMatrix = new THREE.Matrix4();\nconst tmpMatrix2 = new THREE.Matrix4();\n\n// Returns the bbox that we obtain when applying the given rotationMatrix\n// to the given fragment as animation transform, i.e., applied after world matrix.\nconst getRotatedFragmentBox = (model, fragId, rotMatrix, optionalTarget) => {\n\n  const result = optionalTarget || new THREE.Box3();\n\n  const fragList = model.getFragmentList();\n  const geomList = model.getGeometryList();\n\n  // Get fragment worldMatrix. Note that we don't want it to be affected by current animation state.\n  const worldMatrix = tmpMatrix;\n  fragList.getOriginalWorldMatrix(fragId, worldMatrix);\n\n  // Apply worldMatrix then rotMatrix\n  const fullMatrix = tmpMatrix2.copy(rotMatrix).multiply(worldMatrix);\n\n  // Get geometry bbox in object-space (for otg, it will simply be the unit box)\n  const geomId = fragList.getGeometryId(fragId);\n  geomList.getModelBox(geomId, result);\n\n  // Applying a matrix turns an empty box into an infinite one. So, we must skip it for empty boxes\n  if (!result.isEmpty()) {\n    // Apply combined matrix to geometry box.\n    // Note that we cannot simply rotate the fragment's worldBox here, because\n    // this would sometimes result in an unnecessary large bbox.\n    result.applyMatrix4(fullMatrix);\n  }\n\n  return result;\n};\n\n// Given a list of fragment ids and an addtional transform to be applied to each of those,\n// this function computes the resulting bbox when applying fragment worldMatrix + given transform to each\n// fragment geometry.\n//\n//  @param {Model}   model\n//  @param {dbId}    dbId\n//  @param {Matrix4} matrix\nconst computeTransformedObjectBox = (model, dbId, matrix) => {\n\n  const summedBox = new THREE.Box3();\n  const tmpBox = new THREE.Box3();\n\n  // For each fragment...\n  const it = model.getInstanceTree();\n  it.enumNodeFragments(dbId, (fragId) => {\n    // add aligned box of this fragment\n    const fragBox = getRotatedFragmentBox(model, fragId, matrix, tmpBox);\n    summedBox.union(fragBox);\n  });\n\n  return summedBox;\n};\n\n// Computes for each object an alignment rotation with the goal that...\n//  - x/y extent is minimized\n//  - z-axis is preserved\n//  - xExtent <= yExtent\nclass RotationAlignment {\n\n  // @param {Model[]}\n  constructor(models) {\n\n    // Index modely by modelId\n    this.modelsById = [];\n    models.forEach((m) => this.modelsById[m.id] = m);\n\n    // Caches of rotations and bboxes for rotated shapes\n    this.rotations = []; // {Quaternion[][]}\n    this.boxes = []; // {Box3[][]} - boxes of rotated fragments\n\n    // Reused tmp matrix\n    this.rotMatrix = new THREE.Matrix4();\n  }\n\n  // Store alignment rotation and bbox for a shape in cache\n  _addToCache(modelId, dbId, rotation, bbox) {\n\n    // Get or create arrays for cached rotations and boxes for this model\n    let modelRotations = this.rotations[modelId];\n    let modelBoxes = this.boxes[modelId];\n    if (!this.rotations[modelId]) {\n      // first rotation for this model => create new array\n      modelRotations = [];\n      modelBoxes = [];\n      this.rotations[modelId] = modelRotations;\n      this.boxes[modelId] = modelBoxes;\n    }\n\n    // store rotation and bbox in cache\n    modelRotations[dbId] = rotation;\n    modelBoxes[dbId] = bbox;\n  }\n\n  // Make sure that rotation and rotated box are in cache\n  _computeAlignmentAndBox(modelId, dbId) {\n\n    // Skip if already cached\n    if (this._isInCache(modelId, dbId)) {\n      return;\n    }\n\n    // compute Quaternion to align the shape\n    const model = this.modelsById[modelId];\n    const rotation = computeObjectAlignment(model, dbId);\n\n    // compute bbox that we get after rotation\n    this.rotMatrix.makeRotationFromQuaternion(rotation);\n    const box = computeTransformedObjectBox(model, dbId, this.rotMatrix);\n\n    // Store both for next time\n    this._addToCache(modelId, dbId, rotation, box);\n\n    return box;\n  }\n\n  // Check if alignment transform and bbox are already computed\n  _isInCache(modelId, dbId) {\n    const modelBoxes = this.boxes[modelId];\n    return Boolean(modelBoxes && modelBoxes[dbId]);\n  }\n\n  // Get resulting bbox that a shape has - assuming that the alignment rotation was already applied.\n  //\n  // Note: We cannot simply transform the fragment world-box here, because this results in a larger\n  //       bbox than transforming the geometry boxes directly to the rotated world position.\n  getAlignedBox(shapeId, optionalTarget) {\n\n    const { modelId, dbId } = shapeId;\n\n    const result = optionalTarget || new THREE.Box3();\n\n    // Make sure that box is in cache\n    this._computeAlignmentAndBox(modelId, dbId);\n\n    // Return box from cache\n    const box = this.boxes[modelId][dbId];\n    return result.copy(box);\n  }\n\n  // Returns the alignment rotation for a shape.\n  // @param {ShapeId}      shapeId\n  // @param {Quaternion}   [optionalTarget]\n  // @returns {Quaternion}\n  getShapeRotation(shapeId, optionalTarget) {\n\n    const { modelId, dbId } = shapeId;\n\n    const result = optionalTarget || new THREE.Quaternion();\n\n    // Make sure that rotation is in cache\n    this._computeAlignmentAndBox(modelId, dbId);\n\n    // Return rotation from cache\n    const rotation = this.rotations[modelId][dbId];\n    return result.copy(rotation);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leHRlbnNpb25zL1Zpc3VhbENsdXN0ZXJzL1JvdGF0aW9uQWxpZ25tZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTyxNQUFNQSxZQUFZLEdBQUdBLENBQUNDLEdBQUcsRUFBRUMsQ0FBQyxLQUFLO0VBQ3BDLE9BQU8sSUFBSUMsS0FBSyxDQUFDQyxPQUFPO0lBQ25CRixDQUFDLEdBQUcsQ0FBQyxHQUFJRCxHQUFHLENBQUNJLEdBQUcsQ0FBQ0MsQ0FBQyxHQUFHTCxHQUFHLENBQUNNLEdBQUcsQ0FBQ0QsQ0FBQztJQUM5QkosQ0FBQyxHQUFHLENBQUMsR0FBSUQsR0FBRyxDQUFDSSxHQUFHLENBQUNHLENBQUMsR0FBR1AsR0FBRyxDQUFDTSxHQUFHLENBQUNDLENBQUM7SUFDOUJOLENBQUMsR0FBRyxDQUFDLEdBQUlELEdBQUcsQ0FBQ0ksR0FBRyxDQUFDSSxDQUFDLEdBQUdSLEdBQUcsQ0FBQ00sR0FBRyxDQUFDRTtFQUNsQyxDQUFDO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBLE1BQU1DLGNBQWMsR0FBR0MsV0FBVyxDQUFDQyxJQUFJLENBQUM7QUFDcEMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0FBQ25CLENBQUM7O0FBRUY7QUFDQSxNQUFNQyxPQUFPLENBQUM7O0VBRVZDLFdBQVdBLENBQUEsRUFBRztJQUNWO0lBQ0EsSUFBSSxDQUFDQyxRQUFRLEdBQUcsRUFBRTs7SUFFbEIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSWIsS0FBSyxDQUFDQyxPQUFPLENBQUMsQ0FBQztFQUN2Qzs7RUFFQTtFQUNBO0VBQ0FhLE1BQU1BLENBQUNoQixHQUFHLEVBQUVpQixNQUFNLEVBQUU7O0lBRWhCO0lBQ0E7SUFDQSxJQUFJakIsR0FBRyxDQUFDa0IsT0FBTyxDQUFDLENBQUMsRUFBRTtNQUNmO0lB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QUFJLENBQUN2QyxHQUFHLENBQUM7RUFDM0I7O0VBRUE7RUFDQTtFQUNBO0VBQ0E7RUFDQTBILGdCQUFnQkEsQ0FBQ0QsT0FBTyxFQUFFM0IsY0FBYyxFQUFFOztJQUV0QyxNQUFNLEVBQUVrQixPQUFPLEVBQUVsRSxJQUFJLENBQUMsQ0FBQyxHQUFHMkUsT0FBTzs7SUFFakMsTUFBTTFCLE1BQU0sR0FBR0QsY0FBYyxJQUFJLElBQUk1RixLQUFLLENBQUNrRSxVQUFVLENBQUMsQ0FBQzs7SUFFdkQ7SUFDQSxJQUFJLENBQUNpRCx1QkFBdUIsQ0FBQ0wsT0FBTyxFQUFFbEUsSUFBSSxDQUFDOztJQUUzQztJQUNBLE1BQU1tRSxRQUFRLEdBQUcsSUFBSSxDQUFDSixTQUFTLENBQUNHLE9BQU8sQ0FBQyxDQUFDbEUsSUFBSSxDQUFDO0lBQzlDLE9BQU9pRCxNQUFNLENBQUN4RCxJQUFJLENBQUMwRSxRQUFRLENBQUM7RUFDaEM7QUFDSixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQXV0b2Rlc2suRXh0ZW5zaW9ucy8uL2V4dGVuc2lvbnMvVmlzdWFsQ2x1c3RlcnMvUm90YXRpb25BbGlnbm1lbnQuanM/ZWQxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGUgcHVycG9zZSBvZiB0aGlzIGZpbGUgaXMgdG8gY29tcHV0ZSB0aGUgbmVjZXNzYXJ5IHRyYW5zZm9ybXMgdG8gcm90YXRlXG4vLyBhbGwgb2JqZWN0cyBpbiBhIHdheSB0aGF0Li4uXG4vL1xuLy8gIDEuIElkZW50aWNhbCBvYmplY3RzIGFyZSBvcmllbnRlZCBpbiB0aGUgc2FtZSB3YXlcbi8vICAyLiBPYmplY3RzIGFyZSBob3Jpem9udGFsbHkgYWxpZ25lZCB3aXRoIHRoZSBtYWluIGF4ZXMgeC95IHRvIHJlZHVjZSBiYm94IGV4dGVudHMuXG4vLyAgMy4gVXAtVmVjdG9yIGlzIHByZXNlcnZlZFxuLy9cbi8vIEl0IGFsc28gcHJvdmlkZXMgbWV0aG9kcyB0byBjb25zaWRlciB0aGVzZSByb3RhdGlvbnMgZHVyaW5nIGNvbXB1dGF0aW9uIG9mXG4vLyBjbHVzdGVyIGxheW91dCBhbmQgYW5pbWF0aW9uLlxuXG4vLyBAcGFyYW0ge0JveDN9ICAgYm94XG4vLyBAcGFyYW0ge251bWJlcn0gaSAtIGluIFswLCA3XVxuZXhwb3J0IGNvbnN0IGdldEJveENvcm5lciA9IChib3gsIGkpID0+IHsgICAgXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICAoaSAmIDEpID8gYm94Lm1pbi54IDogYm94Lm1heC54LFxuICAgICAgICAoaSAmIDIpID8gYm94Lm1pbi55IDogYm94Lm1heC55LFxuICAgICAgICAoaSAmIDQpID8gYm94Lm1pbi56IDogYm94Lm1heC56XG4gICAgKTtcbn07XG5cbi8vIEVhY2ggZWxlbWVudCBpcyBhIGNvcm5lciBpbmRleC4gRWFjaCBwYWlyIG9mIHR3byBmb3JtcyBhIG1haW4gYXhpcyBkaXJlY3Rpb24uXG5jb25zdCBCb3hBeGlzSW5kaWNlcyA9IFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDAsIDEsIDAsIDIsIDAsIDRcbl0pO1xuXG4vLyBIZWxwZXIgY2xhc3MgdG8gZW51bWVyYXRlIHRoZSBtYWluIGF4aXMgZGlyZWN0aW9ucyBvZiBvbmUgb3IgbW9yZSByb3RhdGVkIGJib3hlcy5cbmNsYXNzIEJveEF4ZXMge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIFRyYW5zZm9ybWluZyB2ZXJ0aWNlcyB0dXJuZWQgb3V0IHRvIGJlIHRoZSBtYWpvciBjb3N0IGZhY3Rvci4gU28gd2UgdXNlIGluZGV4aW5nIHRvIHJlZHVjZSBpdC5cbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xuXG4gICAgICAgIHRoaXMudG1wUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIH1cblxuICAgIC8vIEBwYXJhbSB7Qm94M30gICAgYm94XG4gICAgLy8gQHBhcmFtIHtNYXRyaXg0fSBtYXRyaXggLSBvcmllbnRhdGlvbiBvZiB0aGUgYm94XG4gICAgYWRkQm94KGJveCwgbWF0cml4KSB7XG5cbiAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gc2tpcCBlbXB0eSBib3hlcy4gT3RoZXJ3aXNlLCB3ZSB3b3VsZCBwcm9kdWNlIGluZmluaXRlIFxuICAgICAgICAvLyBleHRlbnRzIGFmdGVyIHRyYW5zZm9ybWluZyBtaW4vbWF4XG4gICAgICAgIGlmIChib3guaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgOCBib3ggY29ybmVyc1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8ODsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gZ2V0Qm94Q29ybmVyKGJveCwgaSkuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXRzIG91dEF4aXMuaW5kZXhBIGFuZCBvdXRBeGlzLmluZGV4QiB0byB2ZXJ0ZXggbnVtYmVycyBvZiB0aGUgZ2l2ZW4gZWRnZVxuICAgIC8vXG4gICAgLy8gQHBhcmFtIHtudW1iZXJ9IGF4aXNJbmRleFxuICAgIC8vIEBwYXJhbSB7T2JqZWN0fSBvdXRBeGlzLmluZGV4QSBhbmQgb3V0QXhpcy5pbmRleEIgd2lsbCBiZSBzZXQuXG4gICAgZ2V0QXhpcyhheGlzSW5kZXgsIG91dEF4aXMpIHtcbiAgICAgICAgLy8gR2V0IG9mZnNldCB3aGVyZSB0aGUgdmVydGljZXMgb2YgdGhlIGJveCBzdGFydFxuICAgICAgICBjb25zdCBib3hJbmRleCA9IE1hdGguZmxvb3IoYXhpc0luZGV4IC8gMyk7IC8vIDMgYXhlcyBwZXIgYm94XG4gICAgICAgIGNvbnN0IHZlcnRleE9mZnNldCA9IDggKiBib3hJbmRleDsgICAgICAgICAgLy8gOCB2ZXJ0aWNlcyBwZXIgYm94XG5cbiAgICAgICAgLy8gR2V0IGluZGV4IGludG8gQm94QXhpc0luZGljZXNcbiAgICAgICAgY29uc3QgbG9jYWxJbmRleCA9ICgyICogYXhpc0luZGV4KSAlIEJveEF4aXNJbmRpY2VzLmxlbmd0aDsgLy8gMiB2YWx1ZXMgcGVyIGF4aXNcblxuICAgICAgICBvdXRBeGlzLmluZGV4QSA9IHZlcnRleE9mZnNldCArIEJveEF4aXNJbmRpY2VzW2xvY2FsSW5kZXhdO1xuICAgICAgICBvdXRBeGlzLmluZGV4QiA9IHZlcnRleE9mZnNldCArIEJveEF4aXNJbmRpY2VzW2xvY2FsSW5kZXggKyAxXTtcbiAgICB9XG5cbiAgICBnZXRBeGlzQ291bnQoKSB7XG4gICAgICAgIGNvbnN0IGJveENvdW50ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLyA4O1xuICAgICAgICBjb25zdCBBeGVzUGVyQm94ID0gMztcbiAgICAgICAgcmV0dXJuIGJveENvdW50ICogQXhlc1BlckJveDtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiBhbGwgYm94ZXMgaWYgd2UgdHJhbnNmb3JtIGFsbCBwb2ludHMgYnkgdGhlIGdpdmVuIG1hdHJpeFxuICAgIC8vICBAcGFyYW0ge0JveDJ9ICAgIG91dFJlY3RcbiAgICAvLyAgQHBhcmFtIHtNYXRyaXg0fSBtYXRyaXhcbiAgICBnZXRCb3VuZGluZ1JlY3Qob3V0UmVjdCwgbWF0cml4KSB7XG4gICAgICAgIGZvciAobGV0IHYgb2YgdGhpcy52ZXJ0aWNlcykge1xuICAgICAgICAgICAgLy8gYWRkIHRyYW5zZm9ybWVkIHZlcnRleCB0byBiYm94XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy50bXBQb2ludC5jb3B5KHYpLmFwcGx5TWF0cml4NChtYXRyaXgpO1xuICAgICAgICAgICAgb3V0UmVjdC5leHBhbmRCeVBvaW50KHApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gRmluZCByb3RhdGlvbiBhcm91bmQgei1heGlzIHRoYXQgYnJpbmdzIHRoZSBnaXZlbiAoaG9yaXpvbnRhbCkgZGlyZWN0aW9uIHRvIHRoZSB4LWF4aXNcbi8vXG4vLyAgQHBhcmFtIHtWZWN0b3IyfSAgZGlyIC0gRG9lcyBub3QgbmVlZCB0byBiZSBub3JtYWxpemVkXG4vLyAgQHJldHVybnMge251bWJlcn0gY2N3IGFuZ2xlIGluIHJhZGlhbnMuIFJvdGF0ZSBieSB0aGlzIGFuZ2xlIHRvIGJyaW5nIGRpciB0byB4QXhpcy5cbmV4cG9ydCBjb25zdCBnZXRBbmdsZVRvWEF4aXMgPSAoZGlyKSA9PiB7XG4gICAgcmV0dXJuIC1NYXRoLmF0YW4yKGRpci55LCBkaXIueCk7XG59O1xuXG4vLyBDb2xsZWN0cyBtYWluIGF4ZXMgb2YgYWxsIGZyYWdtZW50IGdlb21ldHJ5IGJveGVzIGFuZCBwcm9qZWN0cyB0aGVtIHRvIHdvcmxkLXNwYWNlLlxuLy8gIEByZXR1cm5zIHtCb3hBeGVzfSBcbmV4cG9ydCBjb25zdCBjb2xsZWN0RnJhZ0JveEF4ZXMgPSAobW9kZWwsIGRiSWQpID0+IHtcblxuICAgIGxldCBib3hBeGVzID0gbmV3IEJveEF4ZXMoKTtcblxuICAgIGNvbnN0IGdlb21MaXN0ID0gbW9kZWwuZ2V0R2VvbWV0cnlMaXN0KCk7XG4gICAgY29uc3QgZnJhZ0xpc3QgPSBtb2RlbC5nZXRGcmFnbWVudExpc3QoKTtcbiAgICBcbiAgICAvLyBSZXVzZWQgdG1wLXZhbHVlc1xuICAgIGNvbnN0IGdlb21Cb3ggICAgID0gbmV3IFRIUkVFLkJveDMoKTtcbiAgICBjb25zdCB3b3JsZE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAvLyBGb3IgZWFjaCBmcmFnbWVudC4uLlxuICAgIGNvbnN0IGl0ID0gbW9kZWwuZ2V0SW5zdGFuY2VUcmVlKCk7XG4gICAgaXQuZW51bU5vZGVGcmFnbWVudHMoZGJJZCwgKGZyYWdJZCkgPT4ge1xuXG4gICAgICAgIC8vIFNldCBnZW9tQm94IHRvIGdlb21ldHJ5IGJib3ggaW4gb2JqZWN0LXNwYWNlIChmb3Igb3RnLCBpdCB3aWxsIHNpbXBseSBiZSB0aGUgdW5pdCBib3gpXG4gICAgICAgIGNvbnN0IGdlb21JZCA9IGZyYWdMaXN0LmdldEdlb21ldHJ5SWQoZnJhZ0lkKTtcbiAgICAgICAgZ2VvbUxpc3QuZ2V0TW9kZWxCb3goZ2VvbUlkLCBnZW9tQm94KTtcblxuICAgICAgICAvLyBnZXQgZnJhZ21lbnQgd29ybGQgbWF0cml4XG4gICAgICAgIGZyYWdMaXN0LmdldE9yaWdpbmFsV29ybGRNYXRyaXgoZnJhZ0lkLCB3b3JsZE1hdHJpeCk7XG5cbiAgICAgICAgLy8gY29sbGVjdCBiYm94IHdpdGggdHJhbnNmb3JtXG4gICAgICAgIGJveEF4ZXMuYWRkQm94KGdlb21Cb3gsIHdvcmxkTWF0cml4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYm94QXhlcztcbn07XG5cbi8vIEdpdmVuIHZlcnRpY2VzIGFuZCBheGlzIGRpcmVjdGlvbnMgb2YgYmJveGVzLCB0aGlzIGZ1bmN0aW9uIGZpbmRzIGEgcm90YXRpb24gYXJvdW5kIHogc28gdGhhdC4uLlxuLy8gIC0gYXJlYSBvZiB0aGUgYm91bmRzWFkgaXMgbWluaW1pemVkXG4vLyAgLSBXZSBhbHdheXMgaGF2ZSB4RXh0ZW50IDw9IHlFeHRlbnQgZm9yIGJvdW5kc1hZXG4vLyB3aGVyZSBib3VuZHNYWSBpcyB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSB4eS1wcm9qZWN0aW9uIG9mIGFsbCBib3hlcy5cbi8vXG4vLyBOb3RlOiBXZSBhc3N1bWUgaGVyZSB0aGF0IHRoZSBvcHRpbWFsIHNvbHV0aW9uIHdpbGwgYWxpZ24gb25lIG9mIHRoZSBlZGdlcyB3aXRoIHRoZSB4LWF4aXMuXG4vL1xuLy8gIEBwYXJhbSB7Qm94QXhlc30gYm94QXhlc1xuLy8gIEByZXR1cm5zIHtRdWF0ZXJuaW9ufVxuZXhwb3J0IGNvbnN0IGZpbmRBbGlnbm1lbnRSb3RhdGlvbiA9IChib3hBeGVzKSA9PiB7XG5cbiAgICAvLyBSZXVzZWQgaW4gdGhlIGxvb3AgYmVsb3dcbiAgICBjb25zdCBlZGdlRGlyICAgID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICBjb25zdCBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgICBjb25zdCByb3RNYXRyaXggID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICBjb25zdCB6QXhpcyAgICAgID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwwLDEpO1xuICAgIGNvbnN0IHJlY3QgICAgICAgPSBuZXcgVEhSRUUuQm94MigpO1xuXG4gICAgbGV0IG1pbkFyZWEgICAgICAgID0gSW5maW5pdHk7XG4gICAgbGV0IGJlc3RBbmdsZSAgICAgID0gbnVsbDtcbiAgICBsZXQgbWluRXh0ZW50ICAgICAgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgLy8gQW4gYXhpcyBkaXJlY3Rpb24sIGdpdmVuIGJ5IHR3byBpbmRpY2VzIGludG8gYm94QXhlcy52ZXJ0aWNlc1xuICAgIGNvbnN0IGF4aXMgPSB7IFxuICAgICAgICBpbmRleEE6IDAsIFxuICAgICAgICBpbmRleEI6IDAgXG4gICAgfTtcbiAgICBsZXQgYSA9IG51bGw7XG4gICAgbGV0IGIgPSBudWxsO1xuXG4gICAgLy8gRm9yIGVhY2ggZWRnZS4uLlxuICAgIGNvbnN0IGF4aXNDb3VudCA9IGJveEF4ZXMuZ2V0QXhpc0NvdW50KCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPGF4aXNDb3VudDsgaSsrKSB7XG5cbiAgICAgICAgLy8gZ2V0IGVkZ2VcbiAgICAgICAgYm94QXhlcy5nZXRBeGlzKGksIGF4aXMpO1xuICAgICAgICBhID0gYm94QXhlcy52ZXJ0aWNlc1theGlzLmluZGV4QV07XG4gICAgICAgIGIgPSBib3hBeGVzLnZlcnRpY2VzW2F4aXMuaW5kZXhCXTtcblxuICAgICAgICAvLyBnZXQgZWRnZSBkaXJlY3Rpb25cbiAgICAgICAgZWRnZURpci5zZXQoYi54LWEueCwgYi55LWEueSk7XG5cbiAgICAgICAgLy8gY29tcHV0ZSByb3RhdGlvbiBtYXRyaXggdGhhdCBicmluZ3MgdGhhdCBhbmdsZSB0byB4LWF4aXMgKGNjdyByYWRpYW5zKVxuICAgICAgICBsZXQgYW5nbGVUb1hBeGlzID0gZ2V0QW5nbGVUb1hBeGlzKGVkZ2VEaXIpO1xuICAgICAgICBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoekF4aXMsIGFuZ2xlVG9YQXhpcyk7XG4gICAgICAgIHJvdE1hdHJpeC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihxdWF0ZXJuaW9uKTtcblxuICAgICAgICAvLyBjb21wdXRlIHh5LWJvdW5kaW5nIHJlY3RhbmdsZSB0aGF0IHdlIGdldCB3aGVuIHVzaW5nIHRoaXMgYW5nbGVcbiAgICAgICAgYm94QXhlcy5nZXRCb3VuZGluZ1JlY3QocmVjdCwgcm90TWF0cml4KTtcblxuICAgICAgICAvLyBjb21wdXRlIGFyZWFcbiAgICAgICAgY29uc3QgZHggPSByZWN0Lm1heC54IC0gcmVjdC5taW4ueDtcbiAgICAgICAgY29uc3QgZHkgPSByZWN0Lm1heC55IC0gcmVjdC5taW4ueTtcbiAgICAgICAgY29uc3QgYXJlYSA9IGR4ICogZHk7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBhcmVhIGlzIGJldHRlciB0aGFuIG91ciBjYW5kaWRhdGVzIHNvIGZhciwgdXNlIGl0XG4gICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgLy8ga2VlcCByb3RhdGlvbiB0aGF0IG1pbmltaXplZCBhcmVhIHNvIGZhclxuICAgICAgICAgICAgbWluRXh0ZW50LnNldChkeCwgZHkpO1xuICAgICAgICAgICAgbWluQXJlYSAgID0gYXJlYTtcbiAgICAgICAgICAgIGJlc3RBbmdsZSA9IGFuZ2xlVG9YQXhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5lZWRlZCwgcm90YXRlIGJ5IGFub3RoZXIgOTAgZGVncmVlIHRvIGVuc3VyZSB4RXh0ZW50IDwgeUV4dGVudC5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBkb2Vzbid0IGNoYW5nZSB0aGUgYXJlYVxuICAgIGlmIChtaW5FeHRlbnQueCA+IG1pbkV4dGVudC55KSB7XG4gICAgICAgIGJlc3RBbmdsZSArPSBUSFJFRS5NYXRoLmRlZ1RvUmFkKDkwLjApO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgZmluYWwgcXVhdGVybmlvblxuICAgIHF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSh6QXhpcywgYmVzdEFuZ2xlKTtcbiAgICByZXR1cm4gcXVhdGVybmlvbjtcbn07XG5cbi8vIENvbXB1dGVzIGEgcm90YXRpb24gdHJhbnNmb3JtIGZvciBhIGdpdmVuIGRiSWQgdGhhdCBhbGlnbnMgdGhlIG9iamVjdCBob3Jpem9udGFsbHksIHNvIHRoYXQ6XG4vLyAgLSB4eSBleHRlbnQgb2YgdGhlIGJib3ggaXMgbWluaW1pemVkXG4vLyAgLSB4RXh0ZW50IDw9IHlFeHRlbnRcbi8vIEByZXR1cm5zIHtRdWF0ZXJuaW9ufVxuZXhwb3J0IGNvbnN0IGNvbXB1dGVPYmplY3RBbGlnbm1lbnQgPSAobW9kZWwsIGRiSWQpID0+IHtcblxuICAgIC8vIHByb2plY3QgdGhlIG1haW4gYXhlcyBvZiBhbGwgZnJhZ21lbnQgZ2VvbWV0cnkgYm94ZXMgdG8gd29ybGQtc3BhY2VcbiAgICBjb25zdCBheGVzID0gY29sbGVjdEZyYWdCb3hBeGVzKG1vZGVsLCBkYklkKTsgLy8ge1ZlY3RvcjNbXX0gd2l0aCB0d28gdmVjdG9ycyBwZXIgZWRnZVxuXG4gICAgLy8gZmluZCByb3RhdGlvbiB0aGF0IG1pbmltaXplcyB0aGUgeC95LWJib3ggb2YgYWxsIHRyYW5zZm9ybWVkIGJveGVzXG4gICAgcmV0dXJuIGZpbmRBbGlnbm1lbnRSb3RhdGlvbihheGVzKTtcbn07XG5cbmNvbnN0IHRtcE1hdHJpeCAgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuY29uc3QgdG1wTWF0cml4MiA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbi8vIFJldHVybnMgdGhlIGJib3ggdGhhdCB3ZSBvYnRhaW4gd2hlbiBhcHBseWluZyB0aGUgZ2l2ZW4gcm90YXRpb25NYXRyaXhcbi8vIHRvIHRoZSBnaXZlbiBmcmFnbWVudCBhcyBhbmltYXRpb24gdHJhbnNmb3JtLCBpLmUuLCBhcHBsaWVkIGFmdGVyIHdvcmxkIG1hdHJpeC5cbmV4cG9ydCBjb25zdCBnZXRSb3RhdGVkRnJhZ21lbnRCb3ggPSAobW9kZWwsIGZyYWdJZCwgcm90TWF0cml4LCBvcHRpb25hbFRhcmdldCkgPT4ge1xuXG4gICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLkJveDMoKTtcblxuICAgIGNvbnN0IGZyYWdMaXN0ID0gbW9kZWwuZ2V0RnJhZ21lbnRMaXN0KCk7XG4gICAgY29uc3QgZ2VvbUxpc3QgPSBtb2RlbC5nZXRHZW9tZXRyeUxpc3QoKTtcblxuICAgIC8vIEdldCBmcmFnbWVudCB3b3JsZE1hdHJpeC4gTm90ZSB0aGF0IHdlIGRvbid0IHdhbnQgaXQgdG8gYmUgYWZmZWN0ZWQgYnkgY3VycmVudCBhbmltYXRpb24gc3RhdGUuXG4gICAgY29uc3Qgd29ybGRNYXRyaXggPSB0bXBNYXRyaXg7XG4gICAgZnJhZ0xpc3QuZ2V0T3JpZ2luYWxXb3JsZE1hdHJpeChmcmFnSWQsIHdvcmxkTWF0cml4KTtcblxuICAgIC8vIEFwcGx5IHdvcmxkTWF0cml4IHRoZW4gcm90TWF0cml4XG4gICAgY29uc3QgZnVsbE1hdHJpeCA9IHRtcE1hdHJpeDIuY29weShyb3RNYXRyaXgpLm11bHRpcGx5KHdvcmxkTWF0cml4KTtcblxuICAgIC8vIEdldCBnZW9tZXRyeSBiYm94IGluIG9iamVjdC1zcGFjZSAoZm9yIG90ZywgaXQgd2lsbCBzaW1wbHkgYmUgdGhlIHVuaXQgYm94KVxuICAgIGNvbnN0IGdlb21JZCA9IGZyYWdMaXN0LmdldEdlb21ldHJ5SWQoZnJhZ0lkKTtcbiAgICBnZW9tTGlzdC5nZXRNb2RlbEJveChnZW9tSWQsIHJlc3VsdCk7XG5cbiAgICAvLyBBcHBseWluZyBhIG1hdHJpeCB0dXJucyBhbiBlbXB0eSBib3ggaW50byBhbiBpbmZpbml0ZSBvbmUuIFNvLCB3ZSBtdXN0IHNraXAgaXQgZm9yIGVtcHR5IGJveGVzXG4gICAgaWYgKCFyZXN1bHQuaXNFbXB0eSgpKSB7XG4gICAgICAgIC8vIEFwcGx5IGNvbWJpbmVkIG1hdHJpeCB0byBnZW9tZXRyeSBib3guXG4gICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBjYW5ub3Qgc2ltcGx5IHJvdGF0ZSB0aGUgZnJhZ21lbnQncyB3b3JsZEJveCBoZXJlLCBiZWNhdXNlXG4gICAgICAgIC8vIHRoaXMgd291bGQgc29tZXRpbWVzIHJlc3VsdCBpbiBhbiB1bm5lY2Vzc2FyeSBsYXJnZSBiYm94LlxuICAgICAgICByZXN1bHQuYXBwbHlNYXRyaXg0KGZ1bGxNYXRyaXgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBHaXZlbiBhIGxpc3Qgb2YgZnJhZ21lbnQgaWRzIGFuZCBhbiBhZGR0aW9uYWwgdHJhbnNmb3JtIHRvIGJlIGFwcGxpZWQgdG8gZWFjaCBvZiB0aG9zZSxcbi8vIHRoaXMgZnVuY3Rpb24gY29tcHV0ZXMgdGhlIHJlc3VsdGluZyBiYm94IHdoZW4gYXBwbHlpbmcgZnJhZ21lbnQgd29ybGRNYXRyaXggKyBnaXZlbiB0cmFuc2Zvcm0gdG8gZWFjaFxuLy8gZnJhZ21lbnQgZ2VvbWV0cnkuXG4vL1xuLy8gIEBwYXJhbSB7TW9kZWx9ICAgbW9kZWxcbi8vICBAcGFyYW0ge2RiSWR9ICAgIGRiSWRcbi8vICBAcGFyYW0ge01hdHJpeDR9IG1hdHJpeFxuZXhwb3J0IGNvbnN0IGNvbXB1dGVUcmFuc2Zvcm1lZE9iamVjdEJveCA9IChtb2RlbCwgZGJJZCwgbWF0cml4KSA9PiB7XG5cbiAgICBjb25zdCBzdW1tZWRCb3ggPSBuZXcgVEhSRUUuQm94MygpO1xuICAgIGNvbnN0IHRtcEJveCAgICA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cbiAgICAvLyBGb3IgZWFjaCBmcmFnbWVudC4uLlxuICAgIGNvbnN0IGl0ID0gbW9kZWwuZ2V0SW5zdGFuY2VUcmVlKCk7XG4gICAgaXQuZW51bU5vZGVGcmFnbWVudHMoZGJJZCwgKGZyYWdJZCkgPT4ge1xuICAgICAgICAvLyBhZGQgYWxpZ25lZCBib3ggb2YgdGhpcyBmcmFnbWVudFxuICAgICAgICBjb25zdCBmcmFnQm94ID0gZ2V0Um90YXRlZEZyYWdtZW50Qm94KG1vZGVsLCBmcmFnSWQsIG1hdHJpeCwgdG1wQm94KTtcbiAgICAgICAgc3VtbWVkQm94LnVuaW9uKGZyYWdCb3gpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN1bW1lZEJveDtcbn07XG5cbi8vIENvbXB1dGVzIGZvciBlYWNoIG9iamVjdCBhbiBhbGlnbm1lbnQgcm90YXRpb24gd2l0aCB0aGUgZ29hbCB0aGF0Li4uXG4vLyAgLSB4L3kgZXh0ZW50IGlzIG1pbmltaXplZFxuLy8gIC0gei1heGlzIGlzIHByZXNlcnZlZFxuLy8gIC0geEV4dGVudCA8PSB5RXh0ZW50XG5leHBvcnQgY2xhc3MgUm90YXRpb25BbGlnbm1lbnQge1xuXG4gICAgLy8gQHBhcmFtIHtNb2RlbFtdfVxuICAgIGNvbnN0cnVjdG9yKG1vZGVscykge1xuXG4gICAgICAgIC8vIEluZGV4IG1vZGVseSBieSBtb2RlbElkXG4gICAgICAgIHRoaXMubW9kZWxzQnlJZCA9IFtdO1xuICAgICAgICBtb2RlbHMuZm9yRWFjaChtID0+IHRoaXMubW9kZWxzQnlJZFttLmlkXSA9IG0pO1xuXG4gICAgICAgIC8vIENhY2hlcyBvZiByb3RhdGlvbnMgYW5kIGJib3hlcyBmb3Igcm90YXRlZCBzaGFwZXNcbiAgICAgICAgdGhpcy5yb3RhdGlvbnMgPSBbXTsgLy8ge1F1YXRlcm5pb25bXVtdfVxuICAgICAgICB0aGlzLmJveGVzICAgICA9IFtdOyAvLyB7Qm94M1tdW119IC0gYm94ZXMgb2Ygcm90YXRlZCBmcmFnbWVudHNcblxuICAgICAgICAvLyBSZXVzZWQgdG1wIG1hdHJpeFxuICAgICAgICB0aGlzLnJvdE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgfTtcblxuICAgIC8vIFN0b3JlIGFsaWdubWVudCByb3RhdGlvbiBhbmQgYmJveCBmb3IgYSBzaGFwZSBpbiBjYWNoZVxuICAgIF9hZGRUb0NhY2hlKG1vZGVsSWQsIGRiSWQsIHJvdGF0aW9uLCBiYm94KSB7XG5cbiAgICAgICAgLy8gR2V0IG9yIGNyZWF0ZSBhcnJheXMgZm9yIGNhY2hlZCByb3RhdGlvbnMgYW5kIGJveGVzIGZvciB0aGlzIG1vZGVsXG4gICAgICAgIGxldCBtb2RlbFJvdGF0aW9ucyA9IHRoaXMucm90YXRpb25zW21vZGVsSWRdO1xuICAgICAgICBsZXQgbW9kZWxCb3hlcyAgICAgPSB0aGlzLmJveGVzW21vZGVsSWRdOyBcbiAgICAgICAgaWYgKCF0aGlzLnJvdGF0aW9uc1ttb2RlbElkXSkge1xuICAgICAgICAgICAgLy8gZmlyc3Qgcm90YXRpb24gZm9yIHRoaXMgbW9kZWwgPT4gY3JlYXRlIG5ldyBhcnJheVxuICAgICAgICAgICAgbW9kZWxSb3RhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIG1vZGVsQm94ZXMgICAgID0gW107XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uc1ttb2RlbElkXSA9IG1vZGVsUm90YXRpb25zO1xuICAgICAgICAgICAgdGhpcy5ib3hlc1ttb2RlbElkXSAgICAgPSBtb2RlbEJveGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcmUgcm90YXRpb24gYW5kIGJib3ggaW4gY2FjaGVcbiAgICAgICAgbW9kZWxSb3RhdGlvbnNbZGJJZF0gPSByb3RhdGlvbjtcbiAgICAgICAgbW9kZWxCb3hlc1tkYklkXSAgICAgPSBiYm94O1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHJvdGF0aW9uIGFuZCByb3RhdGVkIGJveCBhcmUgaW4gY2FjaGVcbiAgICBfY29tcHV0ZUFsaWdubWVudEFuZEJveChtb2RlbElkLCBkYklkKSB7XG5cbiAgICAgICAgLy8gU2tpcCBpZiBhbHJlYWR5IGNhY2hlZFxuICAgICAgICBpZiAodGhpcy5faXNJbkNhY2hlKG1vZGVsSWQsIGRiSWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb21wdXRlIFF1YXRlcm5pb24gdG8gYWxpZ24gdGhlIHNoYXBlXG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbHNCeUlkW21vZGVsSWRdO1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGNvbXB1dGVPYmplY3RBbGlnbm1lbnQobW9kZWwsIGRiSWQpO1xuXG4gICAgICAgIC8vIGNvbXB1dGUgYmJveCB0aGF0IHdlIGdldCBhZnRlciByb3RhdGlvblxuICAgICAgICB0aGlzLnJvdE1hdHJpeC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihyb3RhdGlvbik7XG4gICAgICAgIGNvbnN0IGJveCA9IGNvbXB1dGVUcmFuc2Zvcm1lZE9iamVjdEJveChtb2RlbCwgZGJJZCwgdGhpcy5yb3RNYXRyaXgpO1xuXG4gICAgICAgIC8vIFN0b3JlIGJvdGggZm9yIG5leHQgdGltZVxuICAgICAgICB0aGlzLl9hZGRUb0NhY2hlKG1vZGVsSWQsIGRiSWQsIHJvdGF0aW9uLCBib3gpO1xuXG4gICAgICAgIHJldHVybiBib3g7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYWxpZ25tZW50IHRyYW5zZm9ybSBhbmQgYmJveCBhcmUgYWxyZWFkeSBjb21wdXRlZFxuICAgIF9pc0luQ2FjaGUobW9kZWxJZCwgZGJJZCkge1xuICAgICAgICBjb25zdCBtb2RlbEJveGVzID0gdGhpcy5ib3hlc1ttb2RlbElkXTtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4obW9kZWxCb3hlcyAmJiBtb2RlbEJveGVzW2RiSWRdKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgcmVzdWx0aW5nIGJib3ggdGhhdCBhIHNoYXBlIGhhcyAtIGFzc3VtaW5nIHRoYXQgdGhlIGFsaWdubWVudCByb3RhdGlvbiB3YXMgYWxyZWFkeSBhcHBsaWVkLlxuICAgIC8vXG4gICAgLy8gTm90ZTogV2UgY2Fubm90IHNpbXBseSB0cmFuc2Zvcm0gdGhlIGZyYWdtZW50IHdvcmxkLWJveCBoZXJlLCBiZWNhdXNlIHRoaXMgcmVzdWx0cyBpbiBhIGxhcmdlclxuICAgIC8vICAgICAgIGJib3ggdGhhbiB0cmFuc2Zvcm1pbmcgdGhlIGdlb21ldHJ5IGJveGVzIGRpcmVjdGx5IHRvIHRoZSByb3RhdGVkIHdvcmxkIHBvc2l0aW9uLlxuICAgIGdldEFsaWduZWRCb3goc2hhcGVJZCwgb3B0aW9uYWxUYXJnZXQpIHtcblxuICAgICAgICBjb25zdCB7IG1vZGVsSWQsIGRiSWQgfSA9IHNoYXBlSWQ7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLkJveDMoKTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBib3ggaXMgaW4gY2FjaGVcbiAgICAgICAgdGhpcy5fY29tcHV0ZUFsaWdubWVudEFuZEJveChtb2RlbElkLCBkYklkKTtcblxuICAgICAgICAvLyBSZXR1cm4gYm94IGZyb20gY2FjaGVcbiAgICAgICAgY29uc3QgYm94ID0gdGhpcy5ib3hlc1ttb2RlbElkXVtkYklkXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KGJveCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyB0aGUgYWxpZ25tZW50IHJvdGF0aW9uIGZvciBhIHNoYXBlLlxuICAgIC8vIEBwYXJhbSB7U2hhcGVJZH0gICAgICBzaGFwZUlkXG4gICAgLy8gQHBhcmFtIHtRdWF0ZXJuaW9ufSAgIFtvcHRpb25hbFRhcmdldF1cbiAgICAvLyBAcmV0dXJucyB7UXVhdGVybmlvbn1cbiAgICBnZXRTaGFwZVJvdGF0aW9uKHNoYXBlSWQsIG9wdGlvbmFsVGFyZ2V0KSB7XG5cbiAgICAgICAgY29uc3QgeyBtb2RlbElkLCBkYklkIH0gPSBzaGFwZUlkO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgcm90YXRpb24gaXMgaW4gY2FjaGVcbiAgICAgICAgdGhpcy5fY29tcHV0ZUFsaWdubWVudEFuZEJveChtb2RlbElkLCBkYklkKTtcblxuICAgICAgICAvLyBSZXR1cm4gcm90YXRpb24gZnJvbSBjYWNoZVxuICAgICAgICBjb25zdCByb3RhdGlvbiA9IHRoaXMucm90YXRpb25zW21vZGVsSWRdW2RiSWRdO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHkocm90YXRpb24pO1xuICAgIH1cbn07XG4iXSwibmFtZXMiOlsiZ2V0Qm94Q29ybmVyIiwiYm94IiwiaSIsIlRIUkVFIiwiVmVjdG9yMyIsIm1pbiIsIngiLCJtYXgiLCJ5IiwieiIsIkJveEF4aXNJbmRpY2VzIiwiVWludDMyQXJyYXkiLCJmcm9tIiwiQm94QXhlcyIsImNvbnN0cnVjdG9yIiwidmVydGljZXMiLCJ0bXBQb2ludCIsImFkZEJveCIsIm1hdHJpeCIsImlzRW1wdHkiLCJwIiwiYXBwbHlNYXRyaXg0IiwicHVzaCIsImdldEF4aXMiLCJheGlzSW5kZXgiLCJvdXRBeGlzIiwiYm94SW5kZXgiLCJNYXRoIiwiZmxvb3IiLCJ2ZXJ0ZXhPZmZzZXQiLCJsb2NhbEluZGV4IiwibGVuZ3RoIiwiaW5kZXhBIiwiaW5kZXhCIiwiZ2V0QXhpc0NvdW50IiwiYm94Q291bnQiLCJBeGVzUGVyQm94IiwiZ2V0Qm91bmRpbmdSZWN0Iiwib3V0UmVjdCIsInYiLCJjb3B5IiwiZXhwYW5kQnlQb2ludCIsImdldEFuZ2xlVG9YQXhpcyIsImRpciIsImF0YW4yIiwiY29sbGVjdEZyYWdCb3hBeGVzIiwibW9kZWwiLCJkYklkIiwiYm94QXhlcyIsImdlb21MaXN0IiwiZ2V0R2VvbWV0cnlMaXN0IiwiZnJhZ0xpc3QiLCJnZXRGcmFnbWVudExpc3QiLCJnZW9tQm94IiwiQm94MyIsIndvcmxkTWF0cml4IiwiTWF0cml4NCIsIml0IiwiZ2V0SW5zdGFuY2VUcmVlIiwiZW51bU5vZGVGcmFnbWVudHMiLCJmcmFnSWQiLCJnZW9tSWQiLCJnZXRHZW9tZXRyeUlkIiwiZ2V0TW9kZWxCb3giLCJnZXRPcmlnaW5hbFdvcmxkTWF0cml4IiwiZmluZEFsaWdubWVudFJvdGF0aW9uIiwiZWRnZURpciIsIlZlY3RvcjIiLCJxdWF0ZXJuaW9uIiwiUXVhdGVybmlvbiIsInJvdE1hdHJpeCIsInpBeGlzIiwicmVjdCIsIkJveDIiLCJtaW5BcmVhIiwiSW5maW5pdHkiLCJiZXN0QW5nbGUiLCJtaW5FeHRlbnQiLCJheGlzIiwiYSIsImIiLCJheGlzQ291bnQiLCJzZXQiLCJhbmdsZVRvWEF4aXMiLCJzZXRGcm9tQXhpc0FuZ2xlIiwibWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24iLCJkeCIsImR5IiwiYXJlYSIsImRlZ1RvUmFkIiwiY29tcHV0ZU9iamVjdEFsaWdubWVudCIsImF4ZXMiLCJ0bXBNYXRyaXgiLCJ0bXBNYXRyaXgyIiwiZ2V0Um90YXRlZEZyYWdtZW50Qm94Iiwib3B0aW9uYWxUYXJnZXQiLCJyZXN1bHQiLCJmdWxsTWF0cml4IiwibXVsdGlwbHkiLCJjb21wdXRlVHJhbnNmb3JtZWRPYmplY3RCb3giLCJzdW1tZWRCb3giLCJ0bXBCb3giLCJmcmFnQm94IiwidW5pb24iLCJSb3RhdGlvbkFsaWdubWVudCIsIm1vZGVscyIsIm1vZGVsc0J5SWQiLCJmb3JFYWNoIiwibSIsImlkIiwicm90YXRpb25zIiwiYm94ZXMiLCJfYWRkVG9DYWNoZSIsIm1vZGVsSWQiLCJyb3RhdGlvbiIsImJib3giLCJtb2RlbFJvdGF0aW9ucyIsIm1vZGVsQm94ZXMiLCJfY29tcHV0ZUFsaWdubWVudEFuZEJveCIsIl9pc0luQ2FjaGUiLCJCb29sZWFuIiwiZ2V0QWxpZ25lZEJveCIsInNoYXBlSWQiLCJnZXRTaGFwZVJvdGF0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./extensions/VisualClusters/RotationAlignment.js\n");

                /***/
            }),

        /***/
        "./extensions/VisualClusters/RowLayoutBuilder.js":
            /*!*******************************************************!*\
              !*** ./extensions/VisualClusters/RowLayoutBuilder.js ***!
              \*******************************************************/
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createClusterSetLayout: () => (/* binding */ createClusterSetLayout)\n/* harmony export */ });\n/* harmony import */ var _ClusterLayout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ClusterLayout.js */ \"./extensions/VisualClusters/ClusterLayout.js\");\n//\n// An algorithm to computes the placement (ClusterSetLayout) for a set of object clusters.\n//\n\n\n\n\n// Computes the x/y extent that we obtain when lining up all shapes in a single row. \n//\n//  @param {bool} autoRotate - If true, we assume that each object is rotated in a way that sizeX <= sizeY.\nconst getRowExtent = (cluster, shapeBoxes, spacing, autoRotate) => {\n\n  // Reused tmp vector\n  let boxDiag = new THREE.Vector3();\n\n  // Accumulated row width\n  let rowSize = new THREE.Vector2();\n\n  for (let i = 0; i < cluster.shapeIds.length; i++) {\n\n    // get shape box diagonal\n    let shapeId = cluster.shapeIds[i];\n    boxDiag = shapeBoxes.getShapeSize(shapeId, boxDiag);\n\n    // get width/height along row\n    const shapeSizeX = autoRotate ? Math.min(boxDiag.x, boxDiag.y) : boxDiag.x;\n    const shapeSizeY = autoRotate ? Math.max(boxDiag.x, boxDiag.y) : boxDiag.y;\n\n    // sum up shape with along the row\n    rowSize.x += shapeSizeX;\n\n    // Track y-extent of row (determined by largest shape along y)\n    rowSize.y = Math.max(rowSize.y, shapeSizeY);\n    rowSize.z = Math.max(rowSize.z, boxDiag.z);\n  }\n\n  // consider spacing\n  rowSize.x += (cluster.shapeIds.length - 1) * spacing;\n\n  return rowSize;\n};\n\n// Given a list of bboxes, this function creates a ClusterLayout that stacks all items vertically.\n//  @param {Cluster}    cluster\n//  @param {ShapeBoxes} shapeBoxes\n//  @param {number}     spacing\nconst createStack = (cluster, shapeBoxes, spacing) => {\n\n  let shapeIds = cluster.shapeIds;\n\n  let layout = new _ClusterLayout_js__WEBPACK_IMPORTED_MODULE_0__.ClusterRowLayout(cluster);\n\n  // Track position where to add next shape\n  let zOffset = 0.0;\n\n  // Reused tmp vector\n  let boxSize = new THREE.Vector3();\n\n  // Why backwards?: Shapes are ordered by increasing size. For stacking, it looks better to start with the largest.\n  for (let i = shapeIds.length - 1; i >= 0; i--) {\n    let shapeId = shapeIds[i];\n\n    // Place shape i\n    layout.positions[i] = new THREE.Vector3(0, 0, zOffset);\n\n    // Size along the row is alway min(sizeX, sizeY)\n    boxSize = shapeBoxes.getShapeSize(shapeId, boxSize);\n\n    // Track layout size\n    layout.size.x = Math.max(layout.size.x, boxSize.x);\n    layout.size.y = Math.max(layout.size.y, boxSize.y);\n    layout.size.z = zOffset + boxSize.y;\n\n    // Step up to next stack level\n    zOffset += boxSize.z + spacing;\n  }\n  return layout;\n};\n\n// Given a list of bboxes, this function creates a ClusterLayout that lines them up in one or more rows.\n//  @param {Cluster}    cluster\n//  @param {ShapeBoxes} shapeBoxes\n//  @param {number}     rowWidth\n//  @param {number}     spacing\n//  @param {number}     autoRotate - If true, each shape is aligned so that sizeX <= sizeY\nconst createRows = (cluster, shapeBoxes, rowWidth, spacing, autoRotate) => {\n\n  let shapeIds = cluster.shapeIds;\n\n  let layout = new _ClusterLayout_js__WEBPACK_IMPORTED_MODULE_0__.ClusterRowLayout(cluster);\n\n  // Track position where to add next shape\n  let nextPos = new THREE.Vector3(0, 0, 0);\n\n  // Reused tmp vector\n  let boxSize = new THREE.Vector3();\n\n  // Track y-extent of current row\n  let rowSizeY = 0;\n\n  for (let i = 0; i < shapeIds.length; i++) {\n    let shapeId = shapeIds[i];\n\n    // Place shape i\n    layout.positions[i] = nextPos.clone();\n\n    // Size along the row is alway min(sizeX, sizeY)\n    boxSize = shapeBoxes.getShapeSize(shapeId, boxSize);\n\n    // If wanted, we orient all shapes so that sizeX < sizeY.\n    layout.rotated[i] = autoRotate && boxSize.x > boxSize.y;\n\n    // get shapeSize in x/y - after rotating in a way that sizeX <= sizeY\n    const shapeSizeX = autoRotate ? Math.min(boxSize.x, boxSize.y) : boxSize.x;\n    const shapeSizeY = autoRotate ? Math.max(boxSize.x, boxSize.y) : boxSize.y;\n\n    // Track y-extent of current row\n    rowSizeY = Math.max(rowSizeY, shapeSizeY);\n\n    // Track overall extent of the whole layout\n    layout.size.x = Math.max(layout.size.x, nextPos.x + shapeSizeX);\n    layout.size.y = Math.max(layout.size.y, nextPos.y + shapeSizeY); // \n    layout.size.z = Math.max(layout.size.z, boxSize.z); // max over all shape heights\n\n    // Shift position along x to next new slot\n    nextPos.x += shapeSizeX + spacing;\n\n    // If width of current row reached the target row width...\n    if (nextPos.x >= rowWidth) {\n      // Start a new row\n      nextPos.x = 0;\n      nextPos.y += rowSizeY + spacing;\n      rowSizeY = 0;\n    }\n  }\n\n  return layout;\n};\n\n// Given a list of shapeIds, this function computes how these can be positioned in order to form a compact block.\n//\n//   @param {Cluster}    cluster    - Note: cluster.shapeIds within the claster will be sorted within this function.\n//   @param {ShapeBoxes} shapeBoxes - to get shape sizes per shapeId\n//   @param {bool}       autoRotate - Ensure sizeX <= sizeY for each shape by auto-rotating by 90 degree if necessary.\n//   @returns {ClusterRowLayout}\nconst createClusterRowLayout = function (cluster, shapeBoxes, spacing, autoRotate) {let enableStacking = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n  // Sort shapes by increasing yExtent.\n  //\n  // When using autoRotate, we must consider that shapes will be xy-flipped, so that we\n  // must sort by max{xExtent, yExtent} instead.\n  //\n  // Note: The autoRotate option will eventually be removed, because the rotationAlignment can already ensure xExtent <= yExtent,\n  //       so that the layout algorithm can just assume it and always sort by y-extent only.\n  let shapeIds = cluster.shapeIds;\n  const byY = (a, b) => bySizeY(a, b, shapeBoxes);\n  const byMaxXY = (a, b) => byMaxXYSize(a, b, shapeBoxes);\n  const pred = autoRotate ? byMaxXY : byY;\n\n  // Sort shapeIds\n  shapeIds.sort(pred);\n\n  // Compute x/y-extent that we would get when lining up all objects in a single row\n  const singleRowSize = getRowExtent(cluster, shapeBoxes, spacing, autoRotate);\n\n  // For simplicity and performance, the code below is just a heuristic: We neglect the fact \n  // that y-extents of rows may be varying. So, depending on the variance of y-extents\n  // we may not get an actual squre. However, at least we usually avoid to odd aspect ratios.\n  // \n  // We would like to choose the number of rows in a way that the cluster gets approximately squared.\n  // Given n rows, we would approximately obtain a cluster for which...\n  //  - sizeX = singleRowSizeX / numRows\n  //  - sizeY = singleRowSizeY * numRows\n  //\n  // To get it approximately square, we choose so that \n  //    sizeX = sizeY\n  //\n  const numRows = Math.sqrt(singleRowSize.x / singleRowSize.y);\n  const rowWidth = singleRowSize.x / numRows;\n\n  const rows = createRows(cluster, shapeBoxes, rowWidth, spacing, autoRotate);\n\n  // For large flat shapes (like floors/ceilings), it may be better to just stack them on top of each other.\n  // So, we try stacking them as well.\n  if (enableStacking) {\n    const stack = createStack(cluster, shapeBoxes, spacing);\n\n    // If the stack height is smaller than the horizonal extent, we use the stack.\n    const useStack = stack.size.z < Math.max(rows.size.x, rows.size.y);\n    if (useStack) {\n      return stack;\n    }\n  }\n\n  return rows;\n};\n\n// Sort predicate to order objects by increasing y-extent\n// Input:\n//   @param {ShapeId}    a          - shapeID a\n//   @param {ShapeId}    b          - shapeID b\n//   @param {ShapeBoxes} shapeBoxes - shape sizes per shapeId\n//\n// Output: -1, if the max extent of object a is greater than of object b\n//          1, otherwise\nconst bySizeY = (a, b, shapeBoxes) => {\n\n  // Get bbox extents\n  const diagA = shapeBoxes.getShapeSize(a);\n  const diagB = shapeBoxes.getShapeSize(b);\n\n  // If y-extent is different, use it\n  if (diagA.y != diagB.y) {\n    return diagA.y - diagB.y;\n  }\n\n  // Among shapes with equal y-extent, sort by increasing x-extent\n  if (diagA.x != diagB.x) {\n    return diagA.x - diagB.x;\n  }\n\n  return 0;\n};\n\n\n// Sort predicate to order objects by increasing maxXYExtent (=max(xExtent, yExtent)). \n// Input:\n//   @param {ShapeId}    a          - shapeID a\n//   @param {ShapeId}    b          - shapeID b\n//   @param {ShapeBoxes} shapeBoxes - shape sizes per shapeId\n//\n// Output: -1, if the max extent of object a is greater than of object b\n//          1, otherwise\nconst byMaxXYSize = (a, b, shapeBoxes) => {\n\n  // Get bbox extents\n  const diagA = shapeBoxes.getShapeSize(a);\n  const diagB = shapeBoxes.getShapeSize(b);\n\n  // Sort based on the max axis extent.\n  const sizeA = Math.max(diagA.x, diagA.y);\n  const sizeB = Math.max(diagB.x, diagB.y);\n  if (sizeA < sizeB) {\n    return -1;\n  } else\n  if (sizeA > sizeB) {\n    return 1;\n  }\n\n  // If max-entents are equal, sort by minExtent\n  const minExtA = Math.min(diagA.x, diagA.y);\n  const minExtB = Math.min(diagB.x, diagB.y);\n  if (minExtA > minExtB) {\n    return -1;\n  } else if (minExtA < minExtB) {\n    return 1;\n  }\n\n  // If min/max extents are both equal, just sort by id for consistency\n  return b - a;\n};\n\n// Given a set of individual ClusterRowLayouts, this function sets their positions, so that clusters are lined up in a grid or stack as well.\n//\n//  @param {ClusterRowLayout[]} layouts\n//  @param {number}             clusterSpacing - Minimum distance between two clusters\n//  @param {Box3}               sceneBox       - bbox of the full scene (without anim transforms)\nconst setClusterPositions = (layouts, clusterSpacing, sceneBox) => {\n\n  // For placing the clusters, we use the same code that we used for arranging the shapes within\n  // the cluster. \n  //\n  // Only difference is that the shapes to be placed are actually clusters instead of shapes.\n\n  const parentCluster = {\n    // In this case, shapeIds are just indices into the layouts array\n    shapeIds: new Int32Array(layouts.length)\n  };\n\n  // Enlist all cluster indices 0, 1, ..., layouts.length-1.\n  for (let i = 0; i < layouts.length; i++) {\n    parentCluster.shapeIds[i] = i;\n  }\n\n  // ShapeBoxes access when using clusters as shapes.\n  const clusterBoxes = {\n    // Return cluster size\n    getShapeSize: (shapeId, target) => {\n      target = target || new THREE.Vector3();\n      const layout = layouts[shapeId];\n      target.copy(layout.size);\n      return target;\n    }\n  };\n\n  // We only align single shapes, but don't rotate clusters. Note that the aspect ratio \n  const autoRotate = false;\n\n  // Run layout to place the clusters\n  const enableStacking = false; // We only use stacking inside clusters. But the clusters themselves are always layouted horizontally.\n  const parentLayout = createClusterRowLayout(parentCluster, clusterBoxes, clusterSpacing, autoRotate, enableStacking);\n\n  // Parent cluster should be horizonally centered at the scene midpoint\n  let origin = sceneBox.getCenter(new THREE.Vector3());\n\n  origin.x -= 0.5 * parentLayout.size.x;\n\n  // Start the flea-market behind the actual building\n  origin.y = sceneBox.min.y + 1.1 * (sceneBox.max.y - sceneBox.min.y);\n\n  // Copy positions from parent clusterLayout to the individual cluster positions\n  for (let i = 0; i < parentCluster.shapeIds.length; i++) {\n    // get position for next cluster\n    const clusterPos = parentLayout.positions[i];\n\n    // Find the corresponding cluster\n    const clusterIndex = parentCluster.shapeIds[i];\n    const layout = layouts[clusterIndex]; // Note that shapeIds is reordered during layout process. So we cannot assume shapeIds[i]==i anymore\n\n    // set cluster position\n    layout.position.copy(clusterPos).add(origin);\n  }\n};\n\nconst getDefaultOptions = () => {\n  return {\n    // minimum distance between two shapes within a group\n    spacing: 1.0,\n\n    // minimum distance between different groups\n    clusterSpacing: 10.0,\n\n    // If true, we stack clusters vertically - otherwise, we line up along x/y\n    stackClusters: true\n  };\n};\n\n// Computes a ClusterSetLayout from a set of object clusters.\n//\n// @param {Cluster[]}         layouts    - Each shape group is given by an array of shapeIds\n// @param {ShapeBoxes}        shapeBoxes - Provides bboxes per shape\n// @param {RotationAlignment} [rotationAlignment] - Defines rotations per shape (optional)\n// @param {Object}            options    - configuration params (see getDefaultOptions)\n// @returns {ClusterSetLayout}\nconst createClusterSetLayout = function (clusters, shapeBoxes, rotationAlignment) {let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getDefaultOptions();\n\n  // When using pre-rotated shapes, the algorithm doesn't need to flipXY for items anymore.\n  const enableXYFlip = !rotationAlignment;\n\n  // Create layout for each cluster\n  const layouts = clusters.map((c) => createClusterRowLayout(c, shapeBoxes, options.spacing, enableXYFlip));\n\n  // Based on layouts and known cluster sizes, determine the placement of each cluster\n  //setClusterPositions(layouts, shapeBoxes, options.stackClusters, options.clusterSpacing);\n  setClusterPositions(layouts, options.clusterSpacing, shapeBoxes.sceneBox);\n\n  return new _ClusterLayout_js__WEBPACK_IMPORTED_MODULE_0__.ClusterSetLayout(layouts, rotationAlignment);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leHRlbnNpb25zL1Zpc3VhbENsdXN0ZXJzL1Jvd0xheW91dEJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRXdFOzs7QUFHeEU7QUFDQTtBQUNBO0FBQ0EsTUFBTUUsWUFBWSxHQUFHQSxDQUFDQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsT0FBTyxFQUFFQyxVQUFVLEtBQUs7O0VBRS9EO0VBQ0EsSUFBSUMsT0FBTyxHQUFHLElBQUlDLEtBQUssQ0FBQ0MsT0FBTyxDQUFDLENBQUM7O0VBRWpDO0VBQ0EsSUFBSUMsT0FBTyxHQUFHLElBQUlGLEtBQUssQ0FBQ0csT0FBTyxDQUFDLENBQUM7O0VBRWpDLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHVCxPQUFPLENBQUNVLFFBQVEsQ0FBQ0MsTUFBTSxFQUFFRixDQUFDLEVBQUUsRUFBRTs7SUFFOUM7SUFDQSxJQUFJRyxPQUFPLEdBQUdaLE9BQU8sQ0FBQ1UsUUFBUSxDQUFDRCxDQUFDLENBQUM7SUFDakNMLE9BQU8sR0FBR0gsVUFBVSxDQUFDWSxZQUFZLENBQUNELE9BQU8sRUFBRVIsT0FBTyxDQUFDOztJQUVuRDtJQUNBLE1BQU1VLFVBQVUsR0FBR1gsVUFBVSxHQUFHWSxJQUFJLENBQUNDLEdBQUcsQ0FBQ1osT0FBTyxDQUFDYSxDQUFDLEVBQUViLE9BQU8sQ0FBQ2MsQ0FBQyxDQUFDLEdBQUdkLE9BQU8sQ0FBQ2EsQ0FBQztJQUMxRSxNQUFNRSxVQUFVLEdBQUdoQixVQUFVLEdBQUdZLElBQUksQ0FBQ0ssR0FBRyxDQUFDaEIsT0FBTyxDQUFDYSxDQUFDLEVBQUViLE9BQU8sQ0FBQ2MsQ0FBQyxDQUFDLEdBQUdkLE9BQU8sQ0FBQ2MsQ0FBQzs7SUFFMUU7SUFDQVgsT0FBTyxDQUFDVSxDQUFDLElBQUlILFVBQVU7O0lBRXZCO0lBQ0FQLE9BQU8sQ0FBQ1csQ0FBQyxHQUFHSCxJQUFJLENBQUNLLEdBQUcsQ0FBQ2IsT0FBTyxDQUFDVyxDQUFD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RCxjQUFjLEVBQUUsSUFBSTs7SUFFcEI7SUFDQWUsYUFBYSxFQUFFO0VBQ25CLENBQUM7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsc0JBQXNCLEdBQUcsU0FBQUEsQ0FBQ0MsUUFBUSxFQUFFNUUsVUFBVSxFQUFFNkUsaUJBQWlCLEVBQW9DLEtBQWxDQyxPQUFPLEdBQUEzQyxTQUFBLENBQUF6QixNQUFBLFFBQUF5QixTQUFBLFFBQUFDLFNBQUEsR0FBQUQsU0FBQSxNQUFHc0MsaUJBQWlCLENBQUMsQ0FBQzs7RUFFbEc7RUFDQSxNQUFNTSxZQUFZLEdBQUcsQ0FBQ0YsaUJBQWlCOztFQUV2QztFQUNBLE1BQU1uQixPQUFPLEdBQUdrQixRQUFRLENBQUNJLEdBQUcsQ0FBQyxDQUFBQyxDQUFDLEtBQUloRCxzQkFBc0IsQ0FBQ2dELENBQUMsRUFBRWpGLFVBQVUsRUFBRThFLE9BQU8sQ0FBQzdFLE9BQU8sRUFBRThFLFlBQVksQ0FBQyxDQUFDOztFQUV2RztFQUNBO0VBQ0F0QixtQkFBbUIsQ0FBQ0MsT0FBTyxFQUFFb0IsT0FBTyxDQUFDbkIsY0FBYyxFQUFFM0QsVUFBVSxDQUFDNEQsUUFBUSxDQUFDOztFQUV6RSxPQUFPLElBQUkvRCwrREFBZ0IsQ0FBQzZELE9BQU8sRUFBRW1CLGlCQUFpQixDQUFDO0FBQzNELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdXRvZGVzay5FeHRlbnNpb25zLy4vZXh0ZW5zaW9ucy9WaXN1YWxDbHVzdGVycy9Sb3dMYXlvdXRCdWlsZGVyLmpzP2VmMDMiXSwic291cmNlc0NvbnRlbnQiOlsiLy9cbi8vIEFuIGFsZ29yaXRobSB0byBjb21wdXRlcyB0aGUgcGxhY2VtZW50IChDbHVzdGVyU2V0TGF5b3V0KSBmb3IgYSBzZXQgb2Ygb2JqZWN0IGNsdXN0ZXJzLlxuLy9cblxuaW1wb3J0IHsgQ2x1c3RlclJvd0xheW91dCwgQ2x1c3RlclNldExheW91dCB9IGZyb20gJy4vQ2x1c3RlckxheW91dC5qcyc7XG5cblxuLy8gQ29tcHV0ZXMgdGhlIHgveSBleHRlbnQgdGhhdCB3ZSBvYnRhaW4gd2hlbiBsaW5pbmcgdXAgYWxsIHNoYXBlcyBpbiBhIHNpbmdsZSByb3cuIFxuLy9cbi8vICBAcGFyYW0ge2Jvb2x9IGF1dG9Sb3RhdGUgLSBJZiB0cnVlLCB3ZSBhc3N1bWUgdGhhdCBlYWNoIG9iamVjdCBpcyByb3RhdGVkIGluIGEgd2F5IHRoYXQgc2l6ZVggPD0gc2l6ZVkuXG5jb25zdCBnZXRSb3dFeHRlbnQgPSAoY2x1c3Rlciwgc2hhcGVCb3hlcywgc3BhY2luZywgYXV0b1JvdGF0ZSkgPT4ge1xuXG4gICAgLy8gUmV1c2VkIHRtcCB2ZWN0b3JcbiAgICBsZXQgYm94RGlhZyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAvLyBBY2N1bXVsYXRlZCByb3cgd2lkdGhcbiAgICBsZXQgcm93U2l6ZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsdXN0ZXIuc2hhcGVJZHMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAvLyBnZXQgc2hhcGUgYm94IGRpYWdvbmFsXG4gICAgICAgIGxldCBzaGFwZUlkID0gY2x1c3Rlci5zaGFwZUlkc1tpXTtcbiAgICAgICAgYm94RGlhZyA9IHNoYXBlQm94ZXMuZ2V0U2hhcGVTaXplKHNoYXBlSWQsIGJveERpYWcpO1xuXG4gICAgICAgIC8vIGdldCB3aWR0aC9oZWlnaHQgYWxvbmcgcm93XG4gICAgICAgIGNvbnN0IHNoYXBlU2l6ZVggPSBhdXRvUm90YXRlID8gTWF0aC5taW4oYm94RGlhZy54LCBib3hEaWFnLnkpIDogYm94RGlhZy54O1xuICAgICAgICBjb25zdCBzaGFwZVNpemVZID0gYXV0b1JvdGF0ZSA/IE1hdGgubWF4KGJveERpYWcueCwgYm94RGlhZy55KSA6IGJveERpYWcueTtcblxuICAgICAgICAvLyBzdW0gdXAgc2hhcGUgd2l0aCBhbG9uZyB0aGUgcm93XG4gICAgICAgIHJvd1NpemUueCArPSBzaGFwZVNpemVYO1xuXG4gICAgICAgIC8vIFRyYWNrIHktZXh0ZW50IG9mIHJvdyAoZGV0ZXJtaW5lZCBieSBsYXJnZXN0IHNoYXBlIGFsb25nIHkpXG4gICAgICAgIHJvd1NpemUueSA9IE1hdGgubWF4KHJvd1NpemUueSwgc2hhcGVTaXplWSk7XG4gICAgICAgIHJvd1NpemUueiA9IE1hdGgubWF4KHJvd1NpemUueiwgYm94RGlhZy56KTtcbiAgICB9XG5cbiAgICAvLyBjb25zaWRlciBzcGFjaW5nXG4gICAgcm93U2l6ZS54ICs9IChjbHVzdGVyLnNoYXBlSWRzLmxlbmd0aCAtIDEpICogc3BhY2luZztcblxuICAgIHJldHVybiByb3dTaXplO1xufTtcblxuLy8gR2l2ZW4gYSBsaXN0IG9mIGJib3hlcywgdGhpcyBmdW5jdGlvbiBjcmVhdGVzIGEgQ2x1c3RlckxheW91dCB0aGF0IHN0YWNrcyBhbGwgaXRlbXMgdmVydGljYWxseS5cbi8vICBAcGFyYW0ge0NsdXN0ZXJ9ICAgIGNsdXN0ZXJcbi8vICBAcGFyYW0ge1NoYXBlQm94ZXN9IHNoYXBlQm94ZXNcbi8vICBAcGFyYW0ge251bWJlcn0gICAgIHNwYWNpbmdcbmNvbnN0IGNyZWF0ZVN0YWNrID0gKGNsdXN0ZXIsIHNoYXBlQm94ZXMsIHNwYWNpbmcpID0+IHtcblxuICAgIGxldCBzaGFwZUlkcyA9IGNsdXN0ZXIuc2hhcGVJZHM7XG5cbiAgICBsZXQgbGF5b3V0ID0gbmV3IENsdXN0ZXJSb3dMYXlvdXQoY2x1c3Rlcik7XG5cbiAgICAvLyBUcmFjayBwb3NpdGlvbiB3aGVyZSB0byBhZGQgbmV4dCBzaGFwZVxuICAgIGxldCB6T2Zmc2V0ID0gMC4wO1xuXG4gICAgLy8gUmV1c2VkIHRtcCB2ZWN0b3JcbiAgICBsZXQgYm94U2l6ZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAvLyBXaHkgYmFja3dhcmRzPzogU2hhcGVzIGFyZSBvcmRlcmVkIGJ5IGluY3JlYXNpbmcgc2l6ZS4gRm9yIHN0YWNraW5nLCBpdCBsb29rcyBiZXR0ZXIgdG8gc3RhcnQgd2l0aCB0aGUgbGFyZ2VzdC5cbiAgICBmb3IgKGxldCBpID0gc2hhcGVJZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IHNoYXBlSWQgPSBzaGFwZUlkc1tpXTtcblxuICAgICAgICAvLyBQbGFjZSBzaGFwZSBpXG4gICAgICAgIGxheW91dC5wb3NpdGlvbnNbaV0gPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCB6T2Zmc2V0KTtcblxuICAgICAgICAvLyBTaXplIGFsb25nIHRoZSByb3cgaXMgYWx3YXkgbWluKHNpemVYLCBzaXplWSlcbiAgICAgICAgYm94U2l6ZSA9IHNoYXBlQm94ZXMuZ2V0U2hhcGVTaXplKHNoYXBlSWQsIGJveFNpemUpO1xuXG4gICAgICAgIC8vIFRyYWNrIGxheW91dCBzaXplXG4gICAgICAgIGxheW91dC5zaXplLnggPSBNYXRoLm1heChsYXlvdXQuc2l6ZS54LCBib3hTaXplLngpO1xuICAgICAgICBsYXlvdXQuc2l6ZS55ID0gTWF0aC5tYXgobGF5b3V0LnNpemUueSwgYm94U2l6ZS55KTtcbiAgICAgICAgbGF5b3V0LnNpemUueiA9IHpPZmZzZXQgKyBib3hTaXplLnk7XG5cbiAgICAgICAgLy8gU3RlcCB1cCB0byBuZXh0IHN0YWNrIGxldmVsXG4gICAgICAgIHpPZmZzZXQgKz0gYm94U2l6ZS56ICsgc3BhY2luZztcbiAgICB9XG4gICAgcmV0dXJuIGxheW91dDtcbn07XG5cbi8vIEdpdmVuIGEgbGlzdCBvZiBiYm94ZXMsIHRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIENsdXN0ZXJMYXlvdXQgdGhhdCBsaW5lcyB0aGVtIHVwIGluIG9uZSBvciBtb3JlIHJvd3MuXG4vLyAgQHBhcmFtIHtDbHVzdGVyfSAgICBjbHVzdGVyXG4vLyAgQHBhcmFtIHtTaGFwZUJveGVzfSBzaGFwZUJveGVzXG4vLyAgQHBhcmFtIHtudW1iZXJ9ICAgICByb3dXaWR0aFxuLy8gIEBwYXJhbSB7bnVtYmVyfSAgICAgc3BhY2luZ1xuLy8gIEBwYXJhbSB7bnVtYmVyfSAgICAgYXV0b1JvdGF0ZSAtIElmIHRydWUsIGVhY2ggc2hhcGUgaXMgYWxpZ25lZCBzbyB0aGF0IHNpemVYIDw9IHNpemVZXG5jb25zdCBjcmVhdGVSb3dzID0gKGNsdXN0ZXIsIHNoYXBlQm94ZXMsIHJvd1dpZHRoLCBzcGFjaW5nLCBhdXRvUm90YXRlKSA9PiB7XG5cbiAgICBsZXQgc2hhcGVJZHMgPSBjbHVzdGVyLnNoYXBlSWRzO1xuXG4gICAgbGV0IGxheW91dCA9IG5ldyBDbHVzdGVyUm93TGF5b3V0KGNsdXN0ZXIpO1xuXG4gICAgLy8gVHJhY2sgcG9zaXRpb24gd2hlcmUgdG8gYWRkIG5leHQgc2hhcGVcbiAgICBsZXQgbmV4dFBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsMCwwKTtcblxuICAgIC8vIFJldXNlZCB0bXAgdmVjdG9yXG4gICAgbGV0IGJveFNpemUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgLy8gVHJhY2sgeS1leHRlbnQgb2YgY3VycmVudCByb3dcbiAgICBsZXQgcm93U2l6ZVkgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc2hhcGVJZCA9IHNoYXBlSWRzW2ldO1xuXG4gICAgICAgIC8vIFBsYWNlIHNoYXBlIGlcbiAgICAgICAgbGF5b3V0LnBvc2l0aW9uc1tpXSA9IG5leHRQb3MuY2xvbmUoKTtcblxuICAgICAgICAvLyBTaXplIGFsb25nIHRoZSByb3cgaXMgYWx3YXkgbWluKHNpemVYLCBzaXplWSlcbiAgICAgICAgYm94U2l6ZSA9IHNoYXBlQm94ZXMuZ2V0U2hhcGVTaXplKHNoYXBlSWQsIGJveFNpemUpO1xuXG4gICAgICAgIC8vIElmIHdhbnRlZCwgd2Ugb3JpZW50IGFsbCBzaGFwZXMgc28gdGhhdCBzaXplWCA8IHNpemVZLlxuICAgICAgICBsYXlvdXQucm90YXRlZFtpXSA9IGF1dG9Sb3RhdGUgJiYgKGJveFNpemUueCA+IGJveFNpemUueSk7XG5cbiAgICAgICAgLy8gZ2V0IHNoYXBlU2l6ZSBpbiB4L3kgLSBhZnRlciByb3RhdGluZyBpbiBhIHdheSB0aGF0IHNpemVYIDw9IHNpemVZXG4gICAgICAgIGNvbnN0IHNoYXBlU2l6ZVggPSBhdXRvUm90YXRlID8gTWF0aC5taW4oYm94U2l6ZS54LCBib3hTaXplLnkpIDogYm94U2l6ZS54O1xuICAgICAgICBjb25zdCBzaGFwZVNpemVZID0gYXV0b1JvdGF0ZSA/IE1hdGgubWF4KGJveFNpemUueCwgYm94U2l6ZS55KSA6IGJveFNpemUueTtcblxuICAgICAgICAvLyBUcmFjayB5LWV4dGVudCBvZiBjdXJyZW50IHJvd1xuICAgICAgICByb3dTaXplWSA9IE1hdGgubWF4KHJvd1NpemVZLCBzaGFwZVNpemVZKTtcblxuICAgICAgICAvLyBUcmFjayBvdmVyYWxsIGV4dGVudCBvZiB0aGUgd2hvbGUgbGF5b3V0XG4gICAgICAgIGxheW91dC5zaXplLnggPSBNYXRoLm1heChsYXlvdXQuc2l6ZS54LCBuZXh0UG9zLnggKyBzaGFwZVNpemVYKTtcbiAgICAgICAgbGF5b3V0LnNpemUueSA9IE1hdGgubWF4KGxheW91dC5zaXplLnksIG5leHRQb3MueSArIHNoYXBlU2l6ZVkpOyAvLyBcbiAgICAgICAgbGF5b3V0LnNpemUueiA9IE1hdGgubWF4KGxheW91dC5zaXplLnosIGJveFNpemUueik7ICAgICAgICAgICAgICAvLyBtYXggb3ZlciBhbGwgc2hhcGUgaGVpZ2h0c1xuXG4gICAgICAgIC8vIFNoaWZ0IHBvc2l0aW9uIGFsb25nIHggdG8gbmV4dCBuZXcgc2xvdFxuICAgICAgICBuZXh0UG9zLnggKz0gc2hhcGVTaXplWCArIHNwYWNpbmc7XG5cbiAgICAgICAgLy8gSWYgd2lkdGggb2YgY3VycmVudCByb3cgcmVhY2hlZCB0aGUgdGFyZ2V0IHJvdyB3aWR0aC4uLlxuICAgICAgICBpZiAobmV4dFBvcy54ID49IHJvd1dpZHRoKSB7XG4gICAgICAgICAgICAvLyBTdGFydCBhIG5ldyByb3dcbiAgICAgICAgICAgIG5leHRQb3MueCAgPSAwO1xuICAgICAgICAgICAgbmV4dFBvcy55ICs9IHJvd1NpemVZICsgc3BhY2luZztcbiAgICAgICAgICAgIHJvd1NpemVZICAgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheW91dDtcbn1cblxuLy8gR2l2ZW4gYSBsaXN0IG9mIHNoYXBlSWRzLCB0aGlzIGZ1bmN0aW9uIGNvbXB1dGVzIGhvdyB0aGVzZSBjYW4gYmUgcG9zaXRpb25lZCBpbiBvcmRlciB0byBmb3JtIGEgY29tcGFjdCBibG9jay5cbi8vXG4vLyAgIEBwYXJhbSB7Q2x1c3Rlcn0gICAgY2x1c3RlciAgICAtIE5vdGU6IGNsdXN0ZXIuc2hhcGVJZHMgd2l0aGluIHRoZSBjbGFzdGVyIHdpbGwgYmUgc29ydGVkIHdpdGhpbiB0aGlzIGZ1bmN0aW9uLlxuLy8gICBAcGFyYW0ge1NoYXBlQm94ZXN9IHNoYXBlQm94ZXMgLSB0byBnZXQgc2hhcGUgc2l6ZXMgcGVyIHNoYXBlSWRcbi8vICAgQHBhcmFtIHtib29sfSAgICAgICBhdXRvUm90YXRlIC0gRW5zdXJlIHNpemVYIDw9IHNpemVZIGZvciBlYWNoIHNoYXBlIGJ5IGF1dG8tcm90YXRpbmcgYnkgOTAgZGVncmVlIGlmIG5lY2Vzc2FyeS5cbi8vICAgQHJldHVybnMge0NsdXN0ZXJSb3dMYXlvdXR9XG5jb25zdCBjcmVhdGVDbHVzdGVyUm93TGF5b3V0ID0gKGNsdXN0ZXIsIHNoYXBlQm94ZXMsIHNwYWNpbmcsIGF1dG9Sb3RhdGUsIGVuYWJsZVN0YWNraW5nID0gdHJ1ZSkgPT4ge1xuXG4gICAgLy8gU29ydCBzaGFwZXMgYnkgaW5jcmVhc2luZyB5RXh0ZW50LlxuICAgIC8vXG4gICAgLy8gV2hlbiB1c2luZyBhdXRvUm90YXRlLCB3ZSBtdXN0IGNvbnNpZGVyIHRoYXQgc2hhcGVzIHdpbGwgYmUgeHktZmxpcHBlZCwgc28gdGhhdCB3ZVxuICAgIC8vIG11c3Qgc29ydCBieSBtYXh7eEV4dGVudCwgeUV4dGVudH0gaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIE5vdGU6IFRoZSBhdXRvUm90YXRlIG9wdGlvbiB3aWxsIGV2ZW50dWFsbHkgYmUgcmVtb3ZlZCwgYmVjYXVzZSB0aGUgcm90YXRpb25BbGlnbm1lbnQgY2FuIGFscmVhZHkgZW5zdXJlIHhFeHRlbnQgPD0geUV4dGVudCxcbiAgICAvLyAgICAgICBzbyB0aGF0IHRoZSBsYXlvdXQgYWxnb3JpdGhtIGNhbiBqdXN0IGFzc3VtZSBpdCBhbmQgYWx3YXlzIHNvcnQgYnkgeS1leHRlbnQgb25seS5cbiAgICBsZXQgc2hhcGVJZHMgPSBjbHVzdGVyLnNoYXBlSWRzO1xuICAgIGNvbnN0IGJ5WSAgICAgPSAoYSwgYikgPT4gYnlTaXplWShhLCBiLCBzaGFwZUJveGVzKTtcbiAgICBjb25zdCBieU1heFhZID0gKGEsIGIpID0+IGJ5TWF4WFlTaXplKGEsIGIsIHNoYXBlQm94ZXMpO1xuICAgIGNvbnN0IHByZWQgPSBhdXRvUm90YXRlID8gYnlNYXhYWSA6IGJ5WTtcblxuICAgIC8vIFNvcnQgc2hhcGVJZHNcbiAgICBzaGFwZUlkcy5zb3J0KHByZWQpO1xuXG4gICAgLy8gQ29tcHV0ZSB4L3ktZXh0ZW50IHRoYXQgd2Ugd291bGQgZ2V0IHdoZW4gbGluaW5nIHVwIGFsbCBvYmplY3RzIGluIGEgc2luZ2xlIHJvd1xuICAgIGNvbnN0IHNpbmdsZVJvd1NpemUgPSBnZXRSb3dFeHRlbnQoY2x1c3Rlciwgc2hhcGVCb3hlcywgc3BhY2luZywgYXV0b1JvdGF0ZSk7XG5cbiAgICAvLyBGb3Igc2ltcGxpY2l0eSBhbmQgcGVyZm9ybWFuY2UsIHRoZSBjb2RlIGJlbG93IGlzIGp1c3QgYSBoZXVyaXN0aWM6IFdlIG5lZ2xlY3QgdGhlIGZhY3QgXG4gICAgLy8gdGhhdCB5LWV4dGVudHMgb2Ygcm93cyBtYXkgYmUgdmFyeWluZy4gU28sIGRlcGVuZGluZyBvbiB0aGUgdmFyaWFuY2Ugb2YgeS1leHRlbnRzXG4gICAgLy8gd2UgbWF5IG5vdCBnZXQgYW4gYWN0dWFsIHNxdXJlLiBIb3dldmVyLCBhdCBsZWFzdCB3ZSB1c3VhbGx5IGF2b2lkIHRvIG9kZCBhc3BlY3QgcmF0aW9zLlxuICAgIC8vIFxuICAgIC8vIFdlIHdvdWxkIGxpa2UgdG8gY2hvb3NlIHRoZSBudW1iZXIgb2Ygcm93cyBpbiBhIHdheSB0aGF0IHRoZSBjbHVzdGVyIGdldHMgYXBwcm94aW1hdGVseSBzcXVhcmVkLlxuICAgIC8vIEdpdmVuIG4gcm93cywgd2Ugd291bGQgYXBwcm94aW1hdGVseSBvYnRhaW4gYSBjbHVzdGVyIGZvciB3aGljaC4uLlxuICAgIC8vICAtIHNpemVYID0gc2luZ2xlUm93U2l6ZVggLyBudW1Sb3dzXG4gICAgLy8gIC0gc2l6ZVkgPSBzaW5nbGVSb3dTaXplWSAqIG51bVJvd3NcbiAgICAvL1xuICAgIC8vIFRvIGdldCBpdCBhcHByb3hpbWF0ZWx5IHNxdWFyZSwgd2UgY2hvb3NlIHNvIHRoYXQgXG4gICAgLy8gICAgc2l6ZVggPSBzaXplWVxuICAgIC8vXG4gICAgY29uc3QgbnVtUm93cyA9IE1hdGguc3FydChzaW5nbGVSb3dTaXplLnggLyBzaW5nbGVSb3dTaXplLnkpO1xuICAgIGNvbnN0IHJvd1dpZHRoID0gc2luZ2xlUm93U2l6ZS54IC8gbnVtUm93cztcblxuICAgIGNvbnN0IHJvd3MgPSBjcmVhdGVSb3dzKGNsdXN0ZXIsIHNoYXBlQm94ZXMsIHJvd1dpZHRoLCBzcGFjaW5nLCBhdXRvUm90YXRlKTtcblxuICAgIC8vIEZvciBsYXJnZSBmbGF0IHNoYXBlcyAobGlrZSBmbG9vcnMvY2VpbGluZ3MpLCBpdCBtYXkgYmUgYmV0dGVyIHRvIGp1c3Qgc3RhY2sgdGhlbSBvbiB0b3Agb2YgZWFjaCBvdGhlci5cbiAgICAvLyBTbywgd2UgdHJ5IHN0YWNraW5nIHRoZW0gYXMgd2VsbC5cbiAgICBpZiAoZW5hYmxlU3RhY2tpbmcpIHtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBjcmVhdGVTdGFjayhjbHVzdGVyLCBzaGFwZUJveGVzLCBzcGFjaW5nKTtcblxuICAgICAgICAvLyBJZiB0aGUgc3RhY2sgaGVpZ2h0IGlzIHNtYWxsZXIgdGhhbiB0aGUgaG9yaXpvbmFsIGV4dGVudCwgd2UgdXNlIHRoZSBzdGFjay5cbiAgICAgICAgY29uc3QgdXNlU3RhY2sgPSAoc3RhY2suc2l6ZS56IDwgTWF0aC5tYXgocm93cy5zaXplLngsIHJvd3Muc2l6ZS55KSk7XG4gICAgICAgIGlmICh1c2VTdGFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvd3M7XG59XG5cbi8vIFNvcnQgcHJlZGljYXRlIHRvIG9yZGVyIG9iamVjdHMgYnkgaW5jcmVhc2luZyB5LWV4dGVudFxuLy8gSW5wdXQ6XG4vLyAgIEBwYXJhbSB7U2hhcGVJZH0gICAgYSAgICAgICAgICAtIHNoYXBlSUQgYVxuLy8gICBAcGFyYW0ge1NoYXBlSWR9ICAgIGIgICAgICAgICAgLSBzaGFwZUlEIGJcbi8vICAgQHBhcmFtIHtTaGFwZUJveGVzfSBzaGFwZUJveGVzIC0gc2hhcGUgc2l6ZXMgcGVyIHNoYXBlSWRcbi8vXG4vLyBPdXRwdXQ6IC0xLCBpZiB0aGUgbWF4IGV4dGVudCBvZiBvYmplY3QgYSBpcyBncmVhdGVyIHRoYW4gb2Ygb2JqZWN0IGJcbi8vICAgICAgICAgIDEsIG90aGVyd2lzZVxuY29uc3QgYnlTaXplWSA9IChhLCBiLCBzaGFwZUJveGVzKSA9PiB7XG5cbiAgICAvLyBHZXQgYmJveCBleHRlbnRzXG4gICAgY29uc3QgZGlhZ0EgPSBzaGFwZUJveGVzLmdldFNoYXBlU2l6ZShhKTtcbiAgICBjb25zdCBkaWFnQiA9IHNoYXBlQm94ZXMuZ2V0U2hhcGVTaXplKGIpO1xuXG4gICAgLy8gSWYgeS1leHRlbnQgaXMgZGlmZmVyZW50LCB1c2UgaXRcbiAgICBpZiAoZGlhZ0EueSAhPSBkaWFnQi55KSB7XG4gICAgICAgIHJldHVybiBkaWFnQS55IC0gZGlhZ0IueTtcbiAgICB9XG5cbiAgICAvLyBBbW9uZyBzaGFwZXMgd2l0aCBlcXVhbCB5LWV4dGVudCwgc29ydCBieSBpbmNyZWFzaW5nIHgtZXh0ZW50XG4gICAgaWYgKGRpYWdBLnggIT0gZGlhZ0IueCkge1xuICAgICAgICByZXR1cm4gZGlhZ0EueCAtIGRpYWdCLng7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59O1xuXG5cbi8vIFNvcnQgcHJlZGljYXRlIHRvIG9yZGVyIG9iamVjdHMgYnkgaW5jcmVhc2luZyBtYXhYWUV4dGVudCAoPW1heCh4RXh0ZW50LCB5RXh0ZW50KSkuIFxuLy8gSW5wdXQ6XG4vLyAgIEBwYXJhbSB7U2hhcGVJZH0gICAgYSAgICAgICAgICAtIHNoYXBlSUQgYVxuLy8gICBAcGFyYW0ge1NoYXBlSWR9ICAgIGIgICAgICAgICAgLSBzaGFwZUlEIGJcbi8vICAgQHBhcmFtIHtTaGFwZUJveGVzfSBzaGFwZUJveGVzIC0gc2hhcGUgc2l6ZXMgcGVyIHNoYXBlSWRcbi8vXG4vLyBPdXRwdXQ6IC0xLCBpZiB0aGUgbWF4IGV4dGVudCBvZiBvYmplY3QgYSBpcyBncmVhdGVyIHRoYW4gb2Ygb2JqZWN0IGJcbi8vICAgICAgICAgIDEsIG90aGVyd2lzZVxuY29uc3QgYnlNYXhYWVNpemUgPSAoYSwgYiwgc2hhcGVCb3hlcykgPT4ge1xuXG4gICAgLy8gR2V0IGJib3ggZXh0ZW50c1xuICAgIGNvbnN0IGRpYWdBID0gc2hhcGVCb3hlcy5nZXRTaGFwZVNpemUoYSk7XG4gICAgY29uc3QgZGlhZ0IgPSBzaGFwZUJveGVzLmdldFNoYXBlU2l6ZShiKTtcblxuICAgIC8vIFNvcnQgYmFzZWQgb24gdGhlIG1heCBheGlzIGV4dGVudC5cbiAgICBjb25zdCBzaXplQSA9IE1hdGgubWF4KGRpYWdBLngsIGRpYWdBLnkpO1xuICAgIGNvbnN0IHNpemVCID0gTWF0aC5tYXgoZGlhZ0IueCwgZGlhZ0IueSk7XG4gICAgaWYgKHNpemVBIDwgc2l6ZUIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0gXG4gICAgZWxzZSBpZiAoc2l6ZUEgPiBzaXplQikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9IFxuICAgIFxuICAgIC8vIElmIG1heC1lbnRlbnRzIGFyZSBlcXVhbCwgc29ydCBieSBtaW5FeHRlbnRcbiAgICBjb25zdCBtaW5FeHRBID0gTWF0aC5taW4oZGlhZ0EueCwgZGlhZ0EueSk7XG4gICAgY29uc3QgbWluRXh0QiA9IE1hdGgubWluKGRpYWdCLngsIGRpYWdCLnkpO1xuICAgIGlmIChtaW5FeHRBID4gbWluRXh0Qikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChtaW5FeHRBIDwgbWluRXh0Qikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICAvLyBJZiBtaW4vbWF4IGV4dGVudHMgYXJlIGJvdGggZXF1YWwsIGp1c3Qgc29ydCBieSBpZCBmb3IgY29uc2lzdGVuY3lcbiAgICByZXR1cm4gYiAtIGE7XG59O1xuXG4vLyBHaXZlbiBhIHNldCBvZiBpbmRpdmlkdWFsIENsdXN0ZXJSb3dMYXlvdXRzLCB0aGlzIGZ1bmN0aW9uIHNldHMgdGhlaXIgcG9zaXRpb25zLCBzbyB0aGF0IGNsdXN0ZXJzIGFyZSBsaW5lZCB1cCBpbiBhIGdyaWQgb3Igc3RhY2sgYXMgd2VsbC5cbi8vXG4vLyAgQHBhcmFtIHtDbHVzdGVyUm93TGF5b3V0W119IGxheW91dHNcbi8vICBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgY2x1c3RlclNwYWNpbmcgLSBNaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdHdvIGNsdXN0ZXJzXG4vLyAgQHBhcmFtIHtCb3gzfSAgICAgICAgICAgICAgIHNjZW5lQm94ICAgICAgIC0gYmJveCBvZiB0aGUgZnVsbCBzY2VuZSAod2l0aG91dCBhbmltIHRyYW5zZm9ybXMpXG5jb25zdCBzZXRDbHVzdGVyUG9zaXRpb25zID0gKGxheW91dHMsIGNsdXN0ZXJTcGFjaW5nLCBzY2VuZUJveCkgPT4ge1xuXG4gICAgLy8gRm9yIHBsYWNpbmcgdGhlIGNsdXN0ZXJzLCB3ZSB1c2UgdGhlIHNhbWUgY29kZSB0aGF0IHdlIHVzZWQgZm9yIGFycmFuZ2luZyB0aGUgc2hhcGVzIHdpdGhpblxuICAgIC8vIHRoZSBjbHVzdGVyLiBcbiAgICAvL1xuICAgIC8vIE9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IHRoZSBzaGFwZXMgdG8gYmUgcGxhY2VkIGFyZSBhY3R1YWxseSBjbHVzdGVycyBpbnN0ZWFkIG9mIHNoYXBlcy5cblxuICAgIGNvbnN0IHBhcmVudENsdXN0ZXIgPSB7XG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSwgc2hhcGVJZHMgYXJlIGp1c3QgaW5kaWNlcyBpbnRvIHRoZSBsYXlvdXRzIGFycmF5XG4gICAgICAgIHNoYXBlSWRzOiBuZXcgSW50MzJBcnJheShsYXlvdXRzLmxlbmd0aClcbiAgICB9O1xuXG4gICAgLy8gRW5saXN0IGFsbCBjbHVzdGVyIGluZGljZXMgMCwgMSwgLi4uLCBsYXlvdXRzLmxlbmd0aC0xLlxuICAgIGZvciAobGV0IGk9MDsgaTxsYXlvdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcmVudENsdXN0ZXIuc2hhcGVJZHNbaV0gPSBpO1xuICAgIH1cblxuICAgIC8vIFNoYXBlQm94ZXMgYWNjZXNzIHdoZW4gdXNpbmcgY2x1c3RlcnMgYXMgc2hhcGVzLlxuICAgIGNvbnN0IGNsdXN0ZXJCb3hlcyA9IHtcbiAgICAgICAgLy8gUmV0dXJuIGNsdXN0ZXIgc2l6ZVxuICAgICAgICBnZXRTaGFwZVNpemU6IChzaGFwZUlkLCB0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgY29uc3QgbGF5b3V0ID0gbGF5b3V0c1tzaGFwZUlkXTtcbiAgICAgICAgICAgIHRhcmdldC5jb3B5KGxheW91dC5zaXplKTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gV2Ugb25seSBhbGlnbiBzaW5nbGUgc2hhcGVzLCBidXQgZG9uJ3Qgcm90YXRlIGNsdXN0ZXJzLiBOb3RlIHRoYXQgdGhlIGFzcGVjdCByYXRpbyBcbiAgICBjb25zdCBhdXRvUm90YXRlID0gZmFsc2U7XG5cbiAgICAvLyBSdW4gbGF5b3V0IHRvIHBsYWNlIHRoZSBjbHVzdGVyc1xuICAgIGNvbnN0IGVuYWJsZVN0YWNraW5nID0gZmFsc2U7IC8vIFdlIG9ubHkgdXNlIHN0YWNraW5nIGluc2lkZSBjbHVzdGVycy4gQnV0IHRoZSBjbHVzdGVycyB0aGVtc2VsdmVzIGFyZSBhbHdheXMgbGF5b3V0ZWQgaG9yaXpvbnRhbGx5LlxuICAgIGNvbnN0IHBhcmVudExheW91dCA9IGNyZWF0ZUNsdXN0ZXJSb3dMYXlvdXQocGFyZW50Q2x1c3RlciwgY2x1c3RlckJveGVzLCBjbHVzdGVyU3BhY2luZywgYXV0b1JvdGF0ZSwgZW5hYmxlU3RhY2tpbmcpO1xuXG4gICAgLy8gUGFyZW50IGNsdXN0ZXIgc2hvdWxkIGJlIGhvcml6b25hbGx5IGNlbnRlcmVkIGF0IHRoZSBzY2VuZSBtaWRwb2ludFxuICAgIGxldCBvcmlnaW4gPSBzY2VuZUJveC5nZXRDZW50ZXIobmV3IFRIUkVFLlZlY3RvcjMoKSk7XG5cbiAgICBvcmlnaW4ueCAtPSAwLjUgKiBwYXJlbnRMYXlvdXQuc2l6ZS54O1xuXG4gICAgLy8gU3RhcnQgdGhlIGZsZWEtbWFya2V0IGJlaGluZCB0aGUgYWN0dWFsIGJ1aWxkaW5nXG4gICAgb3JpZ2luLnkgPSBzY2VuZUJveC5taW4ueSArIDEuMSAqIChzY2VuZUJveC5tYXgueSAtIHNjZW5lQm94Lm1pbi55KTtcblxuICAgIC8vIENvcHkgcG9zaXRpb25zIGZyb20gcGFyZW50IGNsdXN0ZXJMYXlvdXQgdG8gdGhlIGluZGl2aWR1YWwgY2x1c3RlciBwb3NpdGlvbnNcbiAgICBmb3IgKGxldCBpPTA7IGk8cGFyZW50Q2x1c3Rlci5zaGFwZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBnZXQgcG9zaXRpb24gZm9yIG5leHQgY2x1c3RlclxuICAgICAgICBjb25zdCBjbHVzdGVyUG9zID0gcGFyZW50TGF5b3V0LnBvc2l0aW9uc1tpXTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBjb3JyZXNwb25kaW5nIGNsdXN0ZXJcbiAgICAgICAgY29uc3QgY2x1c3RlckluZGV4ID0gcGFyZW50Q2x1c3Rlci5zaGFwZUlkc1tpXTtcbiAgICAgICAgY29uc3QgbGF5b3V0ICAgICAgID0gbGF5b3V0c1tjbHVzdGVySW5kZXhdOyAvLyBOb3RlIHRoYXQgc2hhcGVJZHMgaXMgcmVvcmRlcmVkIGR1cmluZyBsYXlvdXQgcHJvY2Vzcy4gU28gd2UgY2Fubm90IGFzc3VtZSBzaGFwZUlkc1tpXT09aSBhbnltb3JlXG5cbiAgICAgICAgLy8gc2V0IGNsdXN0ZXIgcG9zaXRpb25cbiAgICAgICAgbGF5b3V0LnBvc2l0aW9uLmNvcHkoY2x1c3RlclBvcykuYWRkKG9yaWdpbik7XG4gICAgfVxufVxuXG5jb25zdCBnZXREZWZhdWx0T3B0aW9ucyA9ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBtaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdHdvIHNoYXBlcyB3aXRoaW4gYSBncm91cFxuICAgICAgICBzcGFjaW5nOiAxLjAsXG5cbiAgICAgICAgLy8gbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIGRpZmZlcmVudCBncm91cHNcbiAgICAgICAgY2x1c3RlclNwYWNpbmc6IDEwLjAsXG5cbiAgICAgICAgLy8gSWYgdHJ1ZSwgd2Ugc3RhY2sgY2x1c3RlcnMgdmVydGljYWxseSAtIG90aGVyd2lzZSwgd2UgbGluZSB1cCBhbG9uZyB4L3lcbiAgICAgICAgc3RhY2tDbHVzdGVyczogdHJ1ZVxuICAgIH1cbn07XG5cbi8vIENvbXB1dGVzIGEgQ2x1c3RlclNldExheW91dCBmcm9tIGEgc2V0IG9mIG9iamVjdCBjbHVzdGVycy5cbi8vXG4vLyBAcGFyYW0ge0NsdXN0ZXJbXX0gICAgICAgICBsYXlvdXRzICAgIC0gRWFjaCBzaGFwZSBncm91cCBpcyBnaXZlbiBieSBhbiBhcnJheSBvZiBzaGFwZUlkc1xuLy8gQHBhcmFtIHtTaGFwZUJveGVzfSAgICAgICAgc2hhcGVCb3hlcyAtIFByb3ZpZGVzIGJib3hlcyBwZXIgc2hhcGVcbi8vIEBwYXJhbSB7Um90YXRpb25BbGlnbm1lbnR9IFtyb3RhdGlvbkFsaWdubWVudF0gLSBEZWZpbmVzIHJvdGF0aW9ucyBwZXIgc2hhcGUgKG9wdGlvbmFsKVxuLy8gQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgb3B0aW9ucyAgICAtIGNvbmZpZ3VyYXRpb24gcGFyYW1zIChzZWUgZ2V0RGVmYXVsdE9wdGlvbnMpXG4vLyBAcmV0dXJucyB7Q2x1c3RlclNldExheW91dH1cbmNvbnN0IGNyZWF0ZUNsdXN0ZXJTZXRMYXlvdXQgPSAoY2x1c3RlcnMsIHNoYXBlQm94ZXMsIHJvdGF0aW9uQWxpZ25tZW50LCBvcHRpb25zID0gZ2V0RGVmYXVsdE9wdGlvbnMoKSkgPT4ge1xuXG4gICAgLy8gV2hlbiB1c2luZyBwcmUtcm90YXRlZCBzaGFwZXMsIHRoZSBhbGdvcml0aG0gZG9lc24ndCBuZWVkIHRvIGZsaXBYWSBmb3IgaXRlbXMgYW55bW9yZS5cbiAgICBjb25zdCBlbmFibGVYWUZsaXAgPSAhcm90YXRpb25BbGlnbm1lbnQ7XG5cbiAgICAvLyBDcmVhdGUgbGF5b3V0IGZvciBlYWNoIGNsdXN0ZXJcbiAgICBjb25zdCBsYXlvdXRzID0gY2x1c3RlcnMubWFwKGMgPT4gY3JlYXRlQ2x1c3RlclJvd0xheW91dChjLCBzaGFwZUJveGVzLCBvcHRpb25zLnNwYWNpbmcsIGVuYWJsZVhZRmxpcCkpO1xuXG4gICAgLy8gQmFzZWQgb24gbGF5b3V0cyBhbmQga25vd24gY2x1c3RlciBzaXplcywgZGV0ZXJtaW5lIHRoZSBwbGFjZW1lbnQgb2YgZWFjaCBjbHVzdGVyXG4gICAgLy9zZXRDbHVzdGVyUG9zaXRpb25zKGxheW91dHMsIHNoYXBlQm94ZXMsIG9wdGlvbnMuc3RhY2tDbHVzdGVycywgb3B0aW9ucy5jbHVzdGVyU3BhY2luZyk7XG4gICAgc2V0Q2x1c3RlclBvc2l0aW9ucyhsYXlvdXRzLCBvcHRpb25zLmNsdXN0ZXJTcGFjaW5nLCBzaGFwZUJveGVzLnNjZW5lQm94KTtcblxuICAgIHJldHVybiBuZXcgQ2x1c3RlclNldExheW91dChsYXlvdXRzLCByb3RhdGlvbkFsaWdubWVudCk7XG59O1xuXG5leHBvcnQge1xuICAgIGNyZWF0ZUNsdXN0ZXJTZXRMYXlvdXRcbn1cbiJdLCJuYW1lcyI6WyJDbHVzdGVyUm93TGF5b3V0IiwiQ2x1c3RlclNldExheW91dCIsImdldFJvd0V4dGVudCIsImNsdXN0ZXIiLCJzaGFwZUJveGVzIiwic3BhY2luZyIsImF1dG9Sb3RhdGUiLCJib3hEaWFnIiwiVEhSRUUiLCJWZWN0b3IzIiwicm93U2l6ZSIsIlZlY3RvcjIiLCJpIiwic2hhcGVJZHMiLCJsZW5ndGgiLCJzaGFwZUlkIiwiZ2V0U2hhcGVTaXplIiwic2hhcGVTaXplWCIsIk1hdGgiLCJtaW4iLCJ4IiwieSIsInNoYXBlU2l6ZVkiLCJtYXgiLCJ6IiwiY3JlYXRlU3RhY2siLCJsYXlvdXQiLCJ6T2Zmc2V0IiwiYm94U2l6ZSIsInBvc2l0aW9ucyIsInNpemUiLCJjcmVhdGVSb3dzIiwicm93V2lkdGgiLCJuZXh0UG9zIiwicm93U2l6ZVkiLCJjbG9uZSIsInJvdGF0ZWQiLCJjcmVhdGVDbHVzdGVyUm93TGF5b3V0IiwiZW5hYmxlU3RhY2tpbmciLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJieVkiLCJhIiwiYiIsImJ5U2l6ZVkiLCJieU1heFhZIiwiYnlNYXhYWVNpemUiLCJwcmVkIiwic29ydCIsInNpbmdsZVJvd1NpemUiLCJudW1Sb3dzIiwic3FydCIsInJvd3MiLCJzdGFjayIsInVzZVN0YWNrIiwiZGlhZ0EiLCJkaWFnQiIsInNpemVBIiwic2l6ZUIiLCJtaW5FeHRBIiwibWluRXh0QiIsInNldENsdXN0ZXJQb3NpdGlvbnMiLCJsYXlvdXRzIiwiY2x1c3RlclNwYWNpbmciLCJzY2VuZUJveCIsInBhcmVudENsdXN0ZXIiLCJJbnQzMkFycmF5IiwiY2x1c3RlckJveGVzIiwidGFyZ2V0IiwiY29weSIsInBhcmVudExheW91dCIsIm9yaWdpbiIsImdldENlbnRlciIsImNsdXN0ZXJQb3MiLCJjbHVzdGVySW5kZXgiLCJwb3NpdGlvbiIsImFkZCIsImdldERlZmF1bHRPcHRpb25zIiwic3RhY2tDbHVzdGVycyIsImNyZWF0ZUNsdXN0ZXJTZXRMYXlvdXQiLCJjbHVzdGVycyIsInJvdGF0aW9uQWxpZ25tZW50Iiwib3B0aW9ucyIsImVuYWJsZVhZRmxpcCIsIm1hcCIsImMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./extensions/VisualClusters/RowLayoutBuilder.js\n");

                /***/
            }),

        /***/
        "./extensions/VisualClusters/ShapeBoxes.js":
            /*!*************************************************!*\
              !*** ./extensions/VisualClusters/ShapeBoxes.js ***!
              \*************************************************/
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ShapeBoxes)\n/* harmony export */ });\n\nconst getSummedModelBox = (models) => {\n  let bbox = new THREE.Box3();\n  for (let i = 0; i < models.length; i++) {\n    const modelBox = models[i].getBoundingBox();\n    bbox.union(modelBox);\n  }\n  return bbox;\n};\n\n// Helper class to faciliate access to shape bboxes across multiple models\nclass ShapeBoxes {\n\n  // @param {bool} [rotationAlignment] - If specified, we don't return the original fragment boxes. Instead, we return the boxes obtained\n  //                                     assuming that an alignment rotation has been applied to each shape. (see RotationAlignment.js for details)\n  constructor(models, rotationAlignment) {\n\n    // Index modely by modelId\n    this.modelsById = [];\n    models.forEach((m) => this.modelsById[m.id] = m);\n\n    // reused for bbox access\n    this.tmpFloat6 = new Float32Array(6);\n    this.tmpBox = new THREE.Box3();\n\n    // Compute summed scene box. Note that sceneBox is always the original scene bbox - not considering alignment rotations per object.\n    this.sceneBox = getSummedModelBox(models);\n\n    // {RotationAlignment}\n    this.rotationAlignment = rotationAlignment;\n  }\n\n  // Return shapeBox that we obtain when not applying any rotationAlignment.\n  // @param {ShapeId} shapeId\n  // @param {Box3}    [optionalTarget]\n  getUnrotatedShapeBox(shapeId, optionalTarget) {\n    const box = optionalTarget || new THREE.Box3();\n\n    const { modelId, dbId } = shapeId;\n\n    // get instanceTree\n    const model = this.modelsById[modelId];\n    const it = model.getInstanceTree();\n\n    // get box as 6 floats in tmpArray\n    it.getNodeBox(dbId, this.tmpFloat6);\n\n    // convert to Box3\n    const values = this.tmpFloat6;\n    box.min.set(values[0], values[1], values[2]);\n    box.max.set(values[3], values[4], values[5]);\n\n    return box;\n  }\n\n  // @param {ShapeId} shapeId\n  // @param {Box3}    [optionalTarget]\n  getShapeBox(shapeId, optionalTarget) {\n\n    // If shapes are rotated, we must return the bboxes of the rotated shapes instead\n    // of the original fragment boxes.\n    // It would be nice if AlignmentRotation could simply provide only the rotations and ShapeBoxes\n    // apply them to the fragment boxes. Unfortunately, this would not work, because it would unnecessarily \n    // increase the bbox sizes. So, RotationAlignment has to provide own bboxes that are computed by transforming the geometry boxes directly.\n    if (this.rotationAlignment) {\n      return this.rotationAlignment.getAlignedBox(shapeId, optionalTarget);\n    }\n\n    // No rotation applied - just use original boxes.\n    return this.getUnrotatedShapeBox(shapeId, optionalTarget);\n  }\n\n  // get shape box diagonal from a given ShapeId\n  getShapeSize(shapeId, optionalTarget) {\n    const target = optionalTarget || new THREE.Vector3();\n\n    const box = this.getShapeBox(shapeId, this.tmpBox);\n\n    // For empty boxes, the diagonal contains -infinity - which isn't helpful for layouting.\n    // So, we return zero extent for this case.\n    if (box.isEmpty()) {\n      target.set(0, 0, 0);\n    } else {\n      box.getSize(target);\n    }\n    return target;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leHRlbnNpb25zL1Zpc3VhbENsdXN0ZXJzL1NoYXBlQm94ZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQSxNQUFNQSxpQkFBaUIsR0FBR0EsQ0FBQ0MsTUFBTSxLQUFLO0VBQ2xDLElBQUlDLElBQUksR0FBRyxJQUFJQyxLQUFLLENBQUNDLElBQUksQ0FBQyxDQUFDO0VBQzNCLEtBQUssSUFBSUMsQ0FBQyxHQUFDLENBQUMsRUFBRUEsQ0FBQyxHQUFDSixNQUFNLENBQUNLLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEVBQUU7SUFDaEMsTUFBTUUsUUFBUSxHQUFHTixNQUFNLENBQUNJLENBQUMsQ0FBQyxDQUFDRyxjQUFjLENBQUMsQ0FBQztJQUMzQ04sSUFBSSxDQUFDTyxLQUFLLENBQUNGLFFBQVEsQ0FBQztFQUN4QjtFQUNBLE9BQU9MLElBQUk7QUFDZixDQUFDOztBQUVEO0FBQ2UsTUFBTVEsVUFBVSxDQUFDOztFQUU1QjtFQUNBO0VBQ0FDLFdBQVdBLENBQUNWLE1BQU0sRUFBRVcsaUJBQWlCLEVBQUU7O0lBRW5DO0lBQ0EsSUFBSSxDQUFDQyxVQUFVLEdBQUcsRUFBRTtJQUNwQlosTUFBTSxDQUFDYSxPQUFPLENBQUMsQ0FBQUMsQ0FBQyxLQUFJLElBQUksQ0FBQ0YsVUFBVSxDQUFDRSxDQUFDLENBQUNDLEVBQUUsQ0FBQyxHQUFHRCxDQUFDLENBQUM7O0lBRTlDO0lBQ0EsSUFBSSxDQUFDRSxTQUFTLEdBQUcsSUFBSUMsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUNwQyxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJaEIsS0FBSyxDQUFDQyxJQUFJLENBQUMsQ0FBQzs7SUFFOUI7SUFDQSxJQUFJLENBQUNnQixRQUFRLEdBQUdwQixpQkFBaUIsQ0FBQ0MsTUFBTSxDQUFDOztJQUV6QztJQUNBLElBQUksQ0FBQ1csaUJBQWlCLEdBQUdBLGlCQUFpQjtFQUM5Qzs7RUFFQTtFQUNBO0VBQ0E7RUFDQVMsb0JBQW9CQSxDQUFDQyxPQUFPLEVBQUVDLGNBQWMsRUFBRTtJQUMxQyxNQUFNQyxHQUFHLEdBQUdELGNBQWMsSUFBSSxJQUFJcEIsS0FBSyxDQUFDQyxJQUFJLENBQUMsQ0FBQzs7SUFFOUMsTUFBTSxFQUFFcUIsT0FBTyxFQUFFQyxJQUFJLENBQUMsQ0FBQyxHQUFHSixPQUFPOztJQUVqQztJQUNBLE1BQU1LLEtBQUssR0FBRyxJQUFJLENBQUNkLFVBQVUsQ0FBQ1ksT0FBTyxDQUFDO0lBQ3RDLE1BQU1HLEVBQUUsR0FBTUQsS0FBSyxDQUFDRSxlQUFlLENBQUMsQ0FBQzs7SUFFckM7SUFDQUQsRUFBRSxDQUFDRSxVQUFVLENBQUNKLElBQUksRUFBRSxJQUFJLENBQUNULFNBQVMsQ0FBQzs7SUFFbkM7SUFDQSxNQUFNYyxNQUFNLEdBQUcsSUFBSSxDQUFDZCxTQUFTO0lBQzdCTyxHQUFHLENBQUNRLEdBQUcsQ0FBQ0MsR0FBRyxDQUFDRixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUVBLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRUEsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVDUCxHQUFHLENBQUNVLEdBQUcsQ0FBQ0QsR0FBRyxDQUFDRixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUVBLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRUEsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDOztJQUU1QyxPQUFPUCxHQUFHO0VBQ2Q7O0VBRUE7RUFDQTtFQUNBVyxXQUFXQSxDQUFDYixPQUFPLEVBQUVDLGNBQWMsRUFBRTs7SUFFakM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLElBQUksSUFBSSxDQUFDWCxpQkFBaUIsRUFBRTtNQUN4QixPQUFPLElBQUksQ0FBQ0EsaUJBQWlCLENBQUN3QixhQUFhLENBQUNkLE9BQU8sRUFBRUMsY0FBYyxDQUFDO0lBQ3hFOztJQUVBO0lBQ0EsT0FBTyxJQUFJLENBQUNGLG9CQUFvQixDQUFDQyxPQUFPLEVBQUVDLGNBQWMsQ0FBQztFQUM3RDs7RUFFQTtFQUNBYyxZQUFZQSxDQUFDZixPQUFPLEVBQUVDLGNBQWMsRUFBRTtJQUNsQyxNQUFNZSxNQUFNLEdBQUdmLGNBQWMsSUFBSSxJQUFJcEIsS0FBSyxDQUFDb0MsT0FBTyxDQUFDLENBQUM7O0lBRXBELE1BQU1mLEdBQUcsR0FBRyxJQUFJLENBQUNXLFdBQVcsQ0FBQ2IsT0FBTyxFQUFFLElBQUksQ0FBQ0gsTUFBTSxDQUFDOztJQUVsRDtJQUNBO0lBQ0EsSUFBSUssR0FBRyxDQUFDZ0IsT0FBTyxDQUFDLENBQUMsRUFBRTtNQUNmRixNQUFNLENBQUNMLEdBQUcsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQztJQUNyQixDQUFDLE1BQU07TUFDSFQsR0FBRyxDQUFDaUIsT0FBTyxDQUFDSCxNQUFNLENBQUM7SUFDdkI7SUFDQSxPQUFPQSxNQUFNO0VBQ2pCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdXRvZGVzay5FeHRlbnNpb25zLy4vZXh0ZW5zaW9ucy9WaXN1YWxDbHVzdGVycy9TaGFwZUJveGVzLmpzPzAxNWYiXSwic291cmNlc0NvbnRlbnQiOlsiXG5jb25zdCBnZXRTdW1tZWRNb2RlbEJveCA9IChtb2RlbHMpID0+IHtcbiAgICBsZXQgYmJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPG1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBtb2RlbEJveCA9IG1vZGVsc1tpXS5nZXRCb3VuZGluZ0JveCgpO1xuICAgICAgICBiYm94LnVuaW9uKG1vZGVsQm94KTtcbiAgICB9XG4gICAgcmV0dXJuIGJib3g7XG59O1xuXG4vLyBIZWxwZXIgY2xhc3MgdG8gZmFjaWxpYXRlIGFjY2VzcyB0byBzaGFwZSBiYm94ZXMgYWNyb3NzIG11bHRpcGxlIG1vZGVsc1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhcGVCb3hlcyB7XG5cbiAgICAvLyBAcGFyYW0ge2Jvb2x9IFtyb3RhdGlvbkFsaWdubWVudF0gLSBJZiBzcGVjaWZpZWQsIHdlIGRvbid0IHJldHVybiB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgYm94ZXMuIEluc3RlYWQsIHdlIHJldHVybiB0aGUgYm94ZXMgb2J0YWluZWRcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3N1bWluZyB0aGF0IGFuIGFsaWdubWVudCByb3RhdGlvbiBoYXMgYmVlbiBhcHBsaWVkIHRvIGVhY2ggc2hhcGUuIChzZWUgUm90YXRpb25BbGlnbm1lbnQuanMgZm9yIGRldGFpbHMpXG4gICAgY29uc3RydWN0b3IobW9kZWxzLCByb3RhdGlvbkFsaWdubWVudCkge1xuXG4gICAgICAgIC8vIEluZGV4IG1vZGVseSBieSBtb2RlbElkXG4gICAgICAgIHRoaXMubW9kZWxzQnlJZCA9IFtdO1xuICAgICAgICBtb2RlbHMuZm9yRWFjaChtID0+IHRoaXMubW9kZWxzQnlJZFttLmlkXSA9IG0pO1xuXG4gICAgICAgIC8vIHJldXNlZCBmb3IgYmJveCBhY2Nlc3NcbiAgICAgICAgdGhpcy50bXBGbG9hdDYgPSBuZXcgRmxvYXQzMkFycmF5KDYpO1xuICAgICAgICB0aGlzLnRtcEJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBzdW1tZWQgc2NlbmUgYm94LiBOb3RlIHRoYXQgc2NlbmVCb3ggaXMgYWx3YXlzIHRoZSBvcmlnaW5hbCBzY2VuZSBiYm94IC0gbm90IGNvbnNpZGVyaW5nIGFsaWdubWVudCByb3RhdGlvbnMgcGVyIG9iamVjdC5cbiAgICAgICAgdGhpcy5zY2VuZUJveCA9IGdldFN1bW1lZE1vZGVsQm94KG1vZGVscyk7XG5cbiAgICAgICAgLy8ge1JvdGF0aW9uQWxpZ25tZW50fVxuICAgICAgICB0aGlzLnJvdGF0aW9uQWxpZ25tZW50ID0gcm90YXRpb25BbGlnbm1lbnQ7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHNoYXBlQm94IHRoYXQgd2Ugb2J0YWluIHdoZW4gbm90IGFwcGx5aW5nIGFueSByb3RhdGlvbkFsaWdubWVudC5cbiAgICAvLyBAcGFyYW0ge1NoYXBlSWR9IHNoYXBlSWRcbiAgICAvLyBAcGFyYW0ge0JveDN9ICAgIFtvcHRpb25hbFRhcmdldF1cbiAgICBnZXRVbnJvdGF0ZWRTaGFwZUJveChzaGFwZUlkLCBvcHRpb25hbFRhcmdldCkge1xuICAgICAgICBjb25zdCBib3ggPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuQm94MygpO1xuXG4gICAgICAgIGNvbnN0IHsgbW9kZWxJZCwgZGJJZCB9ID0gc2hhcGVJZDtcblxuICAgICAgICAvLyBnZXQgaW5zdGFuY2VUcmVlXG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbHNCeUlkW21vZGVsSWRdO1xuICAgICAgICBjb25zdCBpdCAgICA9IG1vZGVsLmdldEluc3RhbmNlVHJlZSgpO1xuXG4gICAgICAgIC8vIGdldCBib3ggYXMgNiBmbG9hdHMgaW4gdG1wQXJyYXlcbiAgICAgICAgaXQuZ2V0Tm9kZUJveChkYklkLCB0aGlzLnRtcEZsb2F0Nik7XG5cbiAgICAgICAgLy8gY29udmVydCB0byBCb3gzXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMudG1wRmxvYXQ2O1xuICAgICAgICBib3gubWluLnNldCh2YWx1ZXNbMF0sIHZhbHVlc1sxXSwgdmFsdWVzWzJdKTtcbiAgICAgICAgYm94Lm1heC5zZXQodmFsdWVzWzNdLCB2YWx1ZXNbNF0sIHZhbHVlc1s1XSk7XG5cbiAgICAgICAgcmV0dXJuIGJveDtcbiAgICB9XG5cbiAgICAvLyBAcGFyYW0ge1NoYXBlSWR9IHNoYXBlSWRcbiAgICAvLyBAcGFyYW0ge0JveDN9ICAgIFtvcHRpb25hbFRhcmdldF1cbiAgICBnZXRTaGFwZUJveChzaGFwZUlkLCBvcHRpb25hbFRhcmdldCkge1xuXG4gICAgICAgIC8vIElmIHNoYXBlcyBhcmUgcm90YXRlZCwgd2UgbXVzdCByZXR1cm4gdGhlIGJib3hlcyBvZiB0aGUgcm90YXRlZCBzaGFwZXMgaW5zdGVhZFxuICAgICAgICAvLyBvZiB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgYm94ZXMuXG4gICAgICAgIC8vIEl0IHdvdWxkIGJlIG5pY2UgaWYgQWxpZ25tZW50Um90YXRpb24gY291bGQgc2ltcGx5IHByb3ZpZGUgb25seSB0aGUgcm90YXRpb25zIGFuZCBTaGFwZUJveGVzXG4gICAgICAgIC8vIGFwcGx5IHRoZW0gdG8gdGhlIGZyYWdtZW50IGJveGVzLiBVbmZvcnR1bmF0ZWx5LCB0aGlzIHdvdWxkIG5vdCB3b3JrLCBiZWNhdXNlIGl0IHdvdWxkIHVubmVjZXNzYXJpbHkgXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBiYm94IHNpemVzLiBTbywgUm90YXRpb25BbGlnbm1lbnQgaGFzIHRvIHByb3ZpZGUgb3duIGJib3hlcyB0aGF0IGFyZSBjb21wdXRlZCBieSB0cmFuc2Zvcm1pbmcgdGhlIGdlb21ldHJ5IGJveGVzIGRpcmVjdGx5LlxuICAgICAgICBpZiAodGhpcy5yb3RhdGlvbkFsaWdubWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm90YXRpb25BbGlnbm1lbnQuZ2V0QWxpZ25lZEJveChzaGFwZUlkLCBvcHRpb25hbFRhcmdldCk7XG4gICAgICAgIH0gXG5cbiAgICAgICAgLy8gTm8gcm90YXRpb24gYXBwbGllZCAtIGp1c3QgdXNlIG9yaWdpbmFsIGJveGVzLlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnJvdGF0ZWRTaGFwZUJveChzaGFwZUlkLCBvcHRpb25hbFRhcmdldCk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHNoYXBlIGJveCBkaWFnb25hbCBmcm9tIGEgZ2l2ZW4gU2hhcGVJZFxuICAgIGdldFNoYXBlU2l6ZShzaGFwZUlkLCBvcHRpb25hbFRhcmdldCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIGNvbnN0IGJveCA9IHRoaXMuZ2V0U2hhcGVCb3goc2hhcGVJZCwgdGhpcy50bXBCb3gpO1xuXG4gICAgICAgIC8vIEZvciBlbXB0eSBib3hlcywgdGhlIGRpYWdvbmFsIGNvbnRhaW5zIC1pbmZpbml0eSAtIHdoaWNoIGlzbid0IGhlbHBmdWwgZm9yIGxheW91dGluZy5cbiAgICAgICAgLy8gU28sIHdlIHJldHVybiB6ZXJvIGV4dGVudCBmb3IgdGhpcyBjYXNlLlxuICAgICAgICBpZiAoYm94LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGFyZ2V0LnNldCgwLDAsMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib3guZ2V0U2l6ZSh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbImdldFN1bW1lZE1vZGVsQm94IiwibW9kZWxzIiwiYmJveCIsIlRIUkVFIiwiQm94MyIsImkiLCJsZW5ndGgiLCJtb2RlbEJveCIsImdldEJvdW5kaW5nQm94IiwidW5pb24iLCJTaGFwZUJveGVzIiwiY29uc3RydWN0b3IiLCJyb3RhdGlvbkFsaWdubWVudCIsIm1vZGVsc0J5SWQiLCJmb3JFYWNoIiwibSIsImlkIiwidG1wRmxvYXQ2IiwiRmxvYXQzMkFycmF5IiwidG1wQm94Iiwic2NlbmVCb3giLCJnZXRVbnJvdGF0ZWRTaGFwZUJveCIsInNoYXBlSWQiLCJvcHRpb25hbFRhcmdldCIsImJveCIsIm1vZGVsSWQiLCJkYklkIiwibW9kZWwiLCJpdCIsImdldEluc3RhbmNlVHJlZSIsImdldE5vZGVCb3giLCJ2YWx1ZXMiLCJtaW4iLCJzZXQiLCJtYXgiLCJnZXRTaGFwZUJveCIsImdldEFsaWduZWRCb3giLCJnZXRTaGFwZVNpemUiLCJ0YXJnZXQiLCJWZWN0b3IzIiwiaXNFbXB0eSIsImdldFNpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./extensions/VisualClusters/ShapeBoxes.js\n");

                /***/
            }),

        /***/
        "./extensions/VisualClusters/VisualClusters.js":
            /*!*****************************************************!*\
              !*** ./extensions/VisualClusters/VisualClusters.js ***!
              \*****************************************************/
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ VisualClustersExtension)\n/* harmony export */ });\n/* harmony import */ var _Cluster_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cluster.js */ \"./extensions/VisualClusters/Cluster.js\");\n/* harmony import */ var _RowLayoutBuilder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RowLayoutBuilder.js */ \"./extensions/VisualClusters/RowLayoutBuilder.js\");\n/* harmony import */ var _AnimController_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AnimController.js */ \"./extensions/VisualClusters/AnimController.js\");\n/* harmony import */ var _ShapeBoxes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ShapeBoxes.js */ \"./extensions/VisualClusters/ShapeBoxes.js\");\n/* harmony import */ var _AnimState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AnimState.js */ \"./extensions/VisualClusters/AnimState.js\");\n/* harmony import */ var _ClusterGizmo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ClusterGizmo.js */ \"./extensions/VisualClusters/ClusterGizmo.js\");\n/* harmony import */ var _RotationAlignment_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./RotationAlignment.js */ \"./extensions/VisualClusters/RotationAlignment.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst av = Autodesk.Viewing;\nconst avu = av.UI;\n\nconst namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.VisualClusters');\n\n// Name of the animation state that organizes all objects in clusters based on Category attribute.\nconst ClusteredStateName = 'ByCategory';\n\nconst createClusterIcon = () => {\n  return [\n  '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 143 135\">',\n  '<g fill=\"currentColor\">',\n  '<polygon points=\"29.275 51 9.725 51 0 68.05 9.725 85 29.275 85 39 68.05\"/>',\n  '<polygon points=\"133.275 51 113.725 51 104 68.05 113.725 85 133.275 85 143 68.05\"/>',\n  '<polygon points=\"89.05 0 55.05 0 38 29.55 55.05 59 89.05 59 106 29.55\"/>',\n  '<polygon points=\"89.05 76 55.05 76 38 105.45 55.05 135 89.05 135 106 105.45\"/>',\n  '</g>',\n  '</svg>'].\n  join('');\n};\n\n// Create a clustering layout that forms clusters of objects based on Category attribute.\nconst createDefaultLayout = async (models, alignShapeRotation, attribName, searchAncestors) => {\n\n  // Make sure that we only work on supported models\n  const modelSupported = (model) => model.is3d() && Boolean(model.getInstanceTree());\n  models = models.filter(modelSupported);\n\n  // build clusters\n  let clusters = await (0,_Cluster_js__WEBPACK_IMPORTED_MODULE_0__.buildClustersFromAttribute)(models, attribName, searchAncestors);\n\n  // Exclude topography & rooms\n  const filter = (c) => c.name != 'Revit Topography' && c.name != 'Revit Rooms' && c.name != 'Revit <Sketch>';\n  clusters = clusters.filter(filter);\n\n  // Use RotationLayout to orient all shapes in a way that the projected x/y-extent is small\n  const rotationAlignment = alignShapeRotation ? new _RotationAlignment_js__WEBPACK_IMPORTED_MODULE_6__.RotationAlignment(models) : null;\n\n  // Create helper for bbox access\n  const shapeBoxes = new _ShapeBoxes_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](models, rotationAlignment);\n\n  // Compute layouts\n  return (0,_RowLayoutBuilder_js__WEBPACK_IMPORTED_MODULE_1__.createClusterSetLayout)(clusters, shapeBoxes, rotationAlignment);\n};\n\n/**\n * Purpose of VisualClusters extension is to group objects into clusters.\n * \n * This means:\n *  1. Categories: Form categories by assigning each shape in a model (or multiple) to a unique category, e.g. based on values of a database property.\n *  2. Layout:     Compute a \"layout\" that places all shapes in a way that shapes of the same group are located closeby.\n *  3. Animation:  Animate between original shape positions and new positions according to cluster layout.\n * \n * Example: By default, the clustering extension forms clusters based on the \"Category\" Given a building model and 2 groups - windows and doors - the result is that all windows and doors are moved away from their\n *          original positions, so that you have one cluster of windows and one cluster of doors located outside the original building.\n * \n * The extension id is: `Autodesk.VisualClusters`\n * \n * @example\n *   viewer.loadExtension('Autodesk.VisualClusters')\n * \n *   If you have a 3D model with propertyDb loaded, you should now see a button in the toolbar to trigger clustering based on Category attribute.\n *  \n * @memberof Autodesk.Viewing.Extensions\n * @alias Autodesk.Viewing.Extensions.VisualClusters\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n * @constructor\n*/\nclass VisualClustersExtension extends av.Extension {\n  constructor(viewer, options) {\n    super(viewer, options);\n\n    // If true, the toggle button for the layout is pressed and all objects\n    // are arranged in clusters (or being computed or animating towards that state)\n    this.layoutActive = false;\n\n    // Used to detect if an async layout computation is meanwhile outdated.\n    this.layoutTimeStamp = 0;\n\n    // Controls transitions between clustered and original state\n    this.animController = new _AnimController_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.viewer);\n\n    // Controls gizmos and labels for clusters\n    this.gizmoController = new _ClusterGizmo_js__WEBPACK_IMPORTED_MODULE_5__.ClusterGizmoController(this.viewer);\n\n    // Bind event listener callbacks\n    this.onModelAddedCb = this.onModelAdded.bind(this);\n    this.onModelRemovedCb = this.onModelRemoved.bind(this);\n    this.dbLoadedCb = this.onDbLoaded.bind(this);\n    this.onTransitionEndedCb = this.onTransitionEnded.bind(this);\n  }\n\n  async load() {\n\n    await this.viewer.loadExtension('Autodesk.Edit3D');\n\n    if (this.options.skipDefaultListeners) {\n      return true;\n    }\n\n    this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.onModelAddedCb);\n    this.viewer.addEventListener(av.MODEL_REMOVED_EVENT, this.onModelRemovedCb);\n    this.viewer.addEventListener(av.OBJECT_TREE_CREATED_EVENT, this.dbLoadedCb);\n    this.viewer.addEventListener(av.ANIM_ENDED, this.onTransitionEndedCb);\n    return true;\n  }\n\n  unload() {\n    if (!this.options.skipDefaultListeners) {\n      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.onModelAddedCb);\n      this.viewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.onModelRemovedCb);\n      this.viewer.removeEventListener(av.OBJECT_TREE_CREATED_EVENT, this.onDbLoaded);\n      this.viewer.removeEventListener(av.ANIM_ENDED, this.onTransitionEndedCb);\n    }\n\n    // Revert all anim transform changes.\n    this.animController.reset();\n\n    this._destroyUI();\n    return true;\n  }\n\n  // Reset to initial state.\n  reset() {\n    this.animController.reset();\n    this.gizmoController.reset();\n    this.layoutActive = false;\n    this.updateButton();\n  }\n\n  onModelAdded() {\n    this.updateButton();\n  }\n\n  onModelRemoved() {\n    this.updateButton();\n\n    // Auto-reset: When reset all animation transforms and extension state.\n    // This avoids leaking any state information when switching between views.\n    //\n    // Note: When temporarily switching all models off in a multi-model scenario, auto-reset might\n    //       not be wanted. If we need to support that case, we need a concept to tell the extension\n    //       explicitly whether a view-switch occurred or leave the reset to the client.\n    const lastModelRemoved = !this.viewer.getVisibleModels().length;\n    if (lastModelRemoved) {\n      this.reset();\n    }\n  }\n\n  onDbLoaded() {\n    this.updateButton();\n  }\n\n  onToolbarCreated() {\n    if (this.options.skipDefaultButton) {\n      return;\n    }\n\n    this.clusterButton = new avu.Button(\"toolbar-clusterTool\");\n    this.clusterButton.icon.innerHTML = createClusterIcon();\n\n    // add button to toolbar section 'Model Tools'\n    let toolbar = this.viewer.getToolbar && this.viewer.getToolbar();\n    if (toolbar) {\n      let modelTools = toolbar.getControl(av.TOOLBAR.MODELTOOLSID);\n\n      // Add our button to the toolbar\n      if (modelTools) {\n        modelTools.addControl(this.clusterButton);\n      }\n    }\n\n    this.clusterButton.onClick = () => {\n      this.setLayoutActive(!this.layoutActive);\n    };\n\n    this.updateButton();\n  }\n\n  onTransitionStarted() {\n    // check if animation state is available and whether there are clusters\n    // (models with clusters have an animStates array with length bigger than 0)\n    if (ClusteredStateName in this.animController.states &&\n    this.animController.states[ClusteredStateName].animStates.filter(Boolean)[0].animStates.length > 0) {\n      this.viewer.fireEvent({ type: av.TRANSITION_STARTED, sceneAnimState: this.animController.states[ClusteredStateName] });\n    } else {\n      this.viewer.fireEvent({ type: av.TRANSITION_STARTED, sceneAnimState: null });\n    }\n  }\n\n  onTransitionEnded() {\n    if (ClusteredStateName in this.animController.states &&\n    this.animController.states[ClusteredStateName].animStates.filter(Boolean)[0].animStates.length > 0) {\n      this.viewer.fireEvent({ type: av.TRANSITION_ENDED, sceneAnimState: this.animController.states[ClusteredStateName] });\n    } else {\n      this.viewer.fireEvent({ type: av.TRANSITION_ENDED, sceneAnimState: null });\n    }\n  }\n\n  _destroyUI() {\n    // Remove button from toolbar\n    if (this.clusterButton) {\n      const toolbar = this.viewer.getToolbar && this.viewer.getToolbar();\n      const modelTools = toolbar && toolbar.getControl(av.TOOLBAR.MODELTOOLSID);\n      if (modelTools) {\n        modelTools.removeControl(this.clusterButton);\n      }\n      this.clusterButton = null;\n    }\n    this.setLayoutActive(false);\n  }\n\n  setLayoutActive(active, attributeName) {\n    if (this.layoutActive === active) {\n      return;\n    }\n\n    // Indicate that layout is activated\n    this.layoutActive = active;\n\n    this.updateButton();\n\n    // Layout disabled: Animate back to original state\n    if (!active) {\n      this.onTransitionStarted();\n      this.animController.animateTo(null);\n      this.gizmoController.onLayoutChanged(null);\n      return;\n    }\n\n    this.applyLayout(attributeName);\n  }\n\n  async applyLayout(attributeName) {\n\n    // get currently visible/loaded models\n    const models = this.viewer.getVisibleModels();\n\n    // If a layout computation is active, mark it as outdated.\n    this.layoutTimeStamp++;\n\n    // Remember timestamp so that we can check later if result is still wanted\n    const layoutTimeStamp = this.layoutTimeStamp;\n\n    const sceneLayout = this.customSceneLayout ?\n    this.customSceneLayout :\n    await createDefaultLayout(\n      models,\n      true,\n      attributeName ? attributeName : this.options.attribName,\n      this.options.searchAncestors\n    );\n\n    // If this.layoutTimeStamp has changed, the result is outdated.\n    if (!this.layoutActive || layoutTimeStamp !== this.layoutTimeStamp) {\n      return;\n    }\n\n    this.sceneLayout = sceneLayout;\n\n    // Create animation state that represents this layout\n    this.sceneAnimState = sceneLayout.createSceneState(models);\n\n    // Make animation state available\n    this.animController.registerState(ClusteredStateName, this.sceneAnimState);\n\n    this.onTransitionStarted();\n\n    // Animate to clustered layout\n    this.animController.animateTo(ClusteredStateName);\n    this.gizmoController.onLayoutChanged(this.sceneLayout);\n  }\n\n  updateButton() {\n    if (!this.clusterButton) {\n      return;\n    }\n\n    const models = this.viewer.getVisibleModels();\n\n    // Only show button if we have >=1 3D model. Note that we cannot rely on this.viewer.impl.is2d, because it\n    // is set after addModel event is fired.\n    const showButton = models.some((model) => model.is3d());\n    this.clusterButton.setVisible(showButton);\n    if (!showButton) {\n      return;\n    }\n\n    // Disable button if some propDb is still loading or if we don't have any propDb at all.\n    const propDbLoading = (model) => model.getPropertyDb() && !model.getPropertyDb().isLoadDone();\n    const propDbMissing = (model) => !propDbLoading(model) && !model.getInstanceTree();\n    const waitForDb = models.some(propDbLoading);\n    const noPropDb = models.some(propDbMissing);\n    const disable = waitForDb || noPropDb;\n\n    // Choose button tooltip. If we disable, explain why.\n    let tooltip = 'Form Clusters by Category';\n    if (disable) {\n      tooltip = waitForDb ? 'Waiting for database to load' : 'Visual Clustering can only be used if a database is available';\n    }\n    this.clusterButton.setToolTip(tooltip);\n\n    // Set button state\n    if (disable) {\n      this.clusterButton.setState(avu.Button.State.DISABLED);\n    } else {\n      this.clusterButton.setState(this.layoutActive ? avu.Button.State.ACTIVE : avu.Button.State.INACTIVE);\n    }\n  }\n}\n\nav.theExtensionManager.registerExtension('Autodesk.VisualClusters', VisualClustersExtension);\n\nnamespace.buildClustersFromAttribute = _Cluster_js__WEBPACK_IMPORTED_MODULE_0__.buildClustersFromAttribute;\nnamespace.Cluster = _Cluster_js__WEBPACK_IMPORTED_MODULE_0__.Cluster;\nnamespace.createShapeId = _Cluster_js__WEBPACK_IMPORTED_MODULE_0__.createShapeId;\nnamespace.createClusterSetLayout = _RowLayoutBuilder_js__WEBPACK_IMPORTED_MODULE_1__.createClusterSetLayout;\nnamespace.ShapeBoxes = _ShapeBoxes_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\nnamespace.AnimConstroller = _AnimController_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\nnamespace.hasVisibleFragments = _Cluster_js__WEBPACK_IMPORTED_MODULE_0__.hasVisibleFragments;\nnamespace.ObjectAnimState = _AnimState_js__WEBPACK_IMPORTED_MODULE_4__.ObjectAnimState;\nnamespace.ModelAnimState = _AnimState_js__WEBPACK_IMPORTED_MODULE_4__.ModelAnimState;\nnamespace.SceneAnimState = _AnimState_js__WEBPACK_IMPORTED_MODULE_4__.SceneAnimState;\nnamespace.getBoxCorner = _RotationAlignment_js__WEBPACK_IMPORTED_MODULE_6__.getBoxCorner;\nnamespace.findAlignmentRotation = _RotationAlignment_js__WEBPACK_IMPORTED_MODULE_6__.findAlignmentRotation;\nnamespace.computeObjectAlignment = _RotationAlignment_js__WEBPACK_IMPORTED_MODULE_6__.computeObjectAlignment;\nnamespace.RotationAlignment = _RotationAlignment_js__WEBPACK_IMPORTED_MODULE_6__.RotationAlignment;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leHRlbnNpb25zL1Zpc3VhbENsdXN0ZXJzL1Zpc3VhbENsdXN0ZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUNhOztBQUUwRjtBQUN4QztBQUNkO0FBQ1I7QUFDd0M7QUFDdEI7QUFDNkQ7O0FBRXhILE1BQU1lLEVBQUUsR0FBR0MsUUFBUSxDQUFDQyxPQUFPO0FBQzNCLE1BQU1DLEdBQUcsR0FBR0gsRUFBRSxDQUFDSSxFQUFFOztBQUVqQixNQUFNQyxTQUFTLEdBQUdDLGlCQUFpQixDQUFDLDRDQUE0QyxDQUFDOztBQUVqRjtBQUNBLE1BQU1DLGtCQUFrQixHQUFHLFlBQVk7O0FBRXZDLE1BQU1DLGlCQUFpQixHQUFHQSxDQUFBLEtBQU07RUFDNUIsT0FBTztFQUNILGdFQUFnRTtFQUM1RCx5QkFBeUI7RUFDckIsNEVBQTRFO0VBQzVFLHFGQUFxRjtFQUNyRiwwRUFBMEU7RUFDMUUsZ0ZBQWdGO0VBQ3BGLE1BQU07RUFDVixRQUFRLENBQ1g7RUFBQ0MsSUFBSSxDQUFDLEVBQUUsQ0FBQztBQUNkLENBQUM7O0FBRUQ7QUFDQSxNQUFNQyxtQkFBbUIsR0FBRyxNQUFBQSxDQUFPQyxNQUFNLEVBQUVDLGtCQUFrQixFQUFFQyxVQUFVLEVBQUVDLGVBQWUsS0FBSzs7RUFFM0Y7RUFDQSxNQUFNQyxjQUFjLEdBQUdBLENBQUFDLEtBQUssS0FBSUEsS0FBSyxDQUFDQyxJQUFJLENBQUMsQ0FBQyxJQUFJQyxPQUFPLENBQUNGLEtBQUssQ0FBQ0csZUFBZSxDQUFDLENBQUMsQ0FBQztFQUNoRlIsTUFBTSxHQUFHQSxNQUFNLENBQUNTLE1BQU0sQ0FBQ0wsY0FBYyxDQUFDOztFQUV0QztFQUNBLElBQUlNLFFBQVEsR0FBRyxNQUFNcEMsdUVBQTBCLENBQUMwQixNQUFNLEVBQUVFLFVBQVUsRUFBRUMsZUFBZSxDQUFDOztFQUVwRjtFQUNBLE1BQU1NLE1BQU0sR0FBR0EsQ0FBQUUsQ0FBQyxLQUFLQSxDQUFDLENBQUNDLElBQUksSUFBSSxrQkFBa0IsSUFB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SjtBQUNKOztBQUVBN0csRUFBRSxDQUFDOEcsbUJBQW1CLENBQUNDLGlCQUFpQixDQUFDLHlCQUF5QixFQUFFckYsdUJBQXVCLENBQUM7O0FBRTVGckIsU0FBUyxDQUFDcEIsMEJBQTBCLEdBQUdBLG1FQUEwQjtBQUNqRW9CLFNBQVMsQ0FBQ25CLE9BQU8sR0FBR0EsZ0RBQU87QUFDM0JtQixTQUFTLENBQUNsQixhQUFhLEdBQUdBLHNEQUFhO0FBQ3ZDa0IsU0FBUyxDQUFDaEIsc0JBQXNCLEdBQUdBLHdFQUFzQjtBQUN6RGdCLFNBQVMsQ0FBQ2QsVUFBVSxHQUFHQSxzREFBVTtBQUNqQ2MsU0FBUyxDQUFDMkcsZUFBZSxHQUFHMUgsMERBQWM7QUFDMUNlLFNBQVMsQ0FBQ2pCLG1CQUFtQixHQUFHQSw0REFBbUI7QUFDbkRpQixTQUFTLENBQUNiLGVBQWUsR0FBR0EsMERBQWU7QUFDM0NhLFNBQVMsQ0FBQ1osY0FBYyxHQUFHQSx5REFBYztBQUN6Q1ksU0FBUyxDQUFDWCxjQUFjLEdBQUdBLHlEQUFjO0FBQ3pDVyxTQUFTLENBQUNSLFlBQVksR0FBR0EsK0RBQVk7QUFDckNRLFNBQVMsQ0FBQ1AscUJBQXFCLEdBQUdBLHdFQUFxQjtBQUN2RE8sU0FBUyxDQUFDTixzQkFBc0IsR0FBR0EseUVBQXNCO0FBQ3pETSxTQUFTLENBQUNULGlCQUFpQixHQUFHQSxvRUFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdXRvZGVzay5FeHRlbnNpb25zLy4vZXh0ZW5zaW9ucy9WaXN1YWxDbHVzdGVycy9WaXN1YWxDbHVzdGVycy5qcz9iOTNhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBidWlsZENsdXN0ZXJzRnJvbUF0dHJpYnV0ZSwgQ2x1c3RlciwgY3JlYXRlU2hhcGVJZCwgaGFzVmlzaWJsZUZyYWdtZW50cyB9IGZyb20gJy4vQ2x1c3Rlci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDbHVzdGVyU2V0TGF5b3V0IH0gZnJvbSAnLi9Sb3dMYXlvdXRCdWlsZGVyLmpzJztcbmltcG9ydCBBbmltQ29udHJvbGxlciBmcm9tICcuL0FuaW1Db250cm9sbGVyLmpzJztcbmltcG9ydCBTaGFwZUJveGVzIGZyb20gJy4vU2hhcGVCb3hlcy5qcyc7XG5pbXBvcnQgeyBPYmplY3RBbmltU3RhdGUsIE1vZGVsQW5pbVN0YXRlLCBTY2VuZUFuaW1TdGF0ZSB9IGZyb20gJy4vQW5pbVN0YXRlLmpzJztcbmltcG9ydCB7IENsdXN0ZXJHaXptb0NvbnRyb2xsZXIgfSBmcm9tICcuL0NsdXN0ZXJHaXptby5qcyc7XG5pbXBvcnQgeyBSb3RhdGlvbkFsaWdubWVudCwgZ2V0Qm94Q29ybmVyLCBmaW5kQWxpZ25tZW50Um90YXRpb24sIGNvbXB1dGVPYmplY3RBbGlnbm1lbnQgfSBmcm9tICcuL1JvdGF0aW9uQWxpZ25tZW50LmpzJztcblxuY29uc3QgYXYgPSBBdXRvZGVzay5WaWV3aW5nO1xuY29uc3QgYXZ1ID0gYXYuVUk7XG5cbmNvbnN0IG5hbWVzcGFjZSA9IEF1dG9kZXNrTmFtZXNwYWNlKCdBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuVmlzdWFsQ2x1c3RlcnMnKTtcblxuLy8gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHN0YXRlIHRoYXQgb3JnYW5pemVzIGFsbCBvYmplY3RzIGluIGNsdXN0ZXJzIGJhc2VkIG9uIENhdGVnb3J5IGF0dHJpYnV0ZS5cbmNvbnN0IENsdXN0ZXJlZFN0YXRlTmFtZSA9ICdCeUNhdGVnb3J5JztcblxuY29uc3QgY3JlYXRlQ2x1c3Rlckljb24gPSAoKSA9PiB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMTQzIDEzNVwiPicsXG4gICAgICAgICAgICAnPGcgZmlsbD1cImN1cnJlbnRDb2xvclwiPicsXG4gICAgICAgICAgICAgICAgJzxwb2x5Z29uIHBvaW50cz1cIjI5LjI3NSA1MSA5LjcyNSA1MSAwIDY4LjA1IDkuNzI1IDg1IDI5LjI3NSA4NSAzOSA2OC4wNVwiLz4nLFxuICAgICAgICAgICAgICAgICc8cG9seWdvbiBwb2ludHM9XCIxMzMuMjc1IDUxIDExMy43MjUgNTEgMTA0IDY4LjA1IDExMy43MjUgODUgMTMzLjI3NSA4NSAxNDMgNjguMDVcIi8+JyxcbiAgICAgICAgICAgICAgICAnPHBvbHlnb24gcG9pbnRzPVwiODkuMDUgMCA1NS4wNSAwIDM4IDI5LjU1IDU1LjA1IDU5IDg5LjA1IDU5IDEwNiAyOS41NVwiLz4nLFxuICAgICAgICAgICAgICAgICc8cG9seWdvbiBwb2ludHM9XCI4OS4wNSA3NiA1NS4wNSA3NiAzOCAxMDUuNDUgNTUuMDUgMTM1IDg5LjA1IDEzNSAxMDYgMTA1LjQ1XCIvPicsXG4gICAgICAgICAgICAnPC9nPicsXG4gICAgICAgICc8L3N2Zz4nXG4gICAgXS5qb2luKCcnKTtcbn07XG5cbi8vIENyZWF0ZSBhIGNsdXN0ZXJpbmcgbGF5b3V0IHRoYXQgZm9ybXMgY2x1c3RlcnMgb2Ygb2JqZWN0cyBiYXNlZCBvbiBDYXRlZ29yeSBhdHRyaWJ1dGUuXG5jb25zdCBjcmVhdGVEZWZhdWx0TGF5b3V0ID0gYXN5bmMgKG1vZGVscywgYWxpZ25TaGFwZVJvdGF0aW9uLCBhdHRyaWJOYW1lLCBzZWFyY2hBbmNlc3RvcnMpID0+IHtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIG9ubHkgd29yayBvbiBzdXBwb3J0ZWQgbW9kZWxzXG4gICAgY29uc3QgbW9kZWxTdXBwb3J0ZWQgPSBtb2RlbCA9PiBtb2RlbC5pczNkKCkgJiYgQm9vbGVhbihtb2RlbC5nZXRJbnN0YW5jZVRyZWUoKSk7XG4gICAgbW9kZWxzID0gbW9kZWxzLmZpbHRlcihtb2RlbFN1cHBvcnRlZCk7XG5cbiAgICAvLyBidWlsZCBjbHVzdGVyc1xuICAgIGxldCBjbHVzdGVycyA9IGF3YWl0IGJ1aWxkQ2x1c3RlcnNGcm9tQXR0cmlidXRlKG1vZGVscywgYXR0cmliTmFtZSwgc2VhcmNoQW5jZXN0b3JzKTtcbiAgICBcbiAgICAvLyBFeGNsdWRlIHRvcG9ncmFwaHkgJiByb29tc1xuICAgIGNvbnN0IGZpbHRlciA9IGMgPT4gKGMubmFtZSAhPSAnUmV2aXQgVG9wb2dyYXBoeScgJiYgYy5uYW1lICE9ICdSZXZpdCBSb29tcycgJiYgYy5uYW1lICE9ICdSZXZpdCA8U2tldGNoPicpO1xuICAgIGNsdXN0ZXJzID0gY2x1c3RlcnMuZmlsdGVyKGZpbHRlcik7XG5cbiAgICAvLyBVc2UgUm90YXRpb25MYXlvdXQgdG8gb3JpZW50IGFsbCBzaGFwZXMgaW4gYSB3YXkgdGhhdCB0aGUgcHJvamVjdGVkIHgveS1leHRlbnQgaXMgc21hbGxcbiAgICBjb25zdCByb3RhdGlvbkFsaWdubWVudCA9IGFsaWduU2hhcGVSb3RhdGlvbiA/IG5ldyBSb3RhdGlvbkFsaWdubWVudChtb2RlbHMpIDogbnVsbDtcblxuICAgIC8vIENyZWF0ZSBoZWxwZXIgZm9yIGJib3ggYWNjZXNzXG4gICAgY29uc3Qgc2hhcGVCb3hlcyA9IG5ldyBTaGFwZUJveGVzKG1vZGVscywgcm90YXRpb25BbGlnbm1lbnQpO1xuXG4gICAgLy8gQ29tcHV0ZSBsYXlvdXRzXG4gICAgcmV0dXJuIGNyZWF0ZUNsdXN0ZXJTZXRMYXlvdXQoY2x1c3RlcnMsIHNoYXBlQm94ZXMsIHJvdGF0aW9uQWxpZ25tZW50KTtcbn07XG5cbi8qKlxuICogUHVycG9zZSBvZiBWaXN1YWxDbHVzdGVycyBleHRlbnNpb24gaXMgdG8gZ3JvdXAgb2JqZWN0cyBpbnRvIGNsdXN0ZXJzLlxuICogXG4gKiBUaGlzIG1lYW5zOlxuICogIDEuIENhdGVnb3JpZXM6IEZvcm0gY2F0ZWdvcmllcyBieSBhc3NpZ25pbmcgZWFjaCBzaGFwZSBpbiBhIG1vZGVsIChvciBtdWx0aXBsZSkgdG8gYSB1bmlxdWUgY2F0ZWdvcnksIGUuZy4gYmFzZWQgb24gdmFsdWVzIG9mIGEgZGF0YWJhc2UgcHJvcGVydHkuXG4gKiAgMi4gTGF5b3V0OiAgICAgQ29tcHV0ZSBhIFwibGF5b3V0XCIgdGhhdCBwbGFjZXMgYWxsIHNoYXBlcyBpbiBhIHdheSB0aGF0IHNoYXBlcyBvZiB0aGUgc2FtZSBncm91cCBhcmUgbG9jYXRlZCBjbG9zZWJ5LlxuICogIDMuIEFuaW1hdGlvbjogIEFuaW1hdGUgYmV0d2VlbiBvcmlnaW5hbCBzaGFwZSBwb3NpdGlvbnMgYW5kIG5ldyBwb3NpdGlvbnMgYWNjb3JkaW5nIHRvIGNsdXN0ZXIgbGF5b3V0LlxuICogXG4gKiBFeGFtcGxlOiBCeSBkZWZhdWx0LCB0aGUgY2x1c3RlcmluZyBleHRlbnNpb24gZm9ybXMgY2x1c3RlcnMgYmFzZWQgb24gdGhlIFwiQ2F0ZWdvcnlcIiBHaXZlbiBhIGJ1aWxkaW5nIG1vZGVsIGFuZCAyIGdyb3VwcyAtIHdpbmRvd3MgYW5kIGRvb3JzIC0gdGhlIHJlc3VsdCBpcyB0aGF0IGFsbCB3aW5kb3dzIGFuZCBkb29ycyBhcmUgbW92ZWQgYXdheSBmcm9tIHRoZWlyXG4gKiAgICAgICAgICBvcmlnaW5hbCBwb3NpdGlvbnMsIHNvIHRoYXQgeW91IGhhdmUgb25lIGNsdXN0ZXIgb2Ygd2luZG93cyBhbmQgb25lIGNsdXN0ZXIgb2YgZG9vcnMgbG9jYXRlZCBvdXRzaWRlIHRoZSBvcmlnaW5hbCBidWlsZGluZy5cbiAqIFxuICogVGhlIGV4dGVuc2lvbiBpZCBpczogYEF1dG9kZXNrLlZpc3VhbENsdXN0ZXJzYFxuICogXG4gKiBAZXhhbXBsZVxuICogICB2aWV3ZXIubG9hZEV4dGVuc2lvbignQXV0b2Rlc2suVmlzdWFsQ2x1c3RlcnMnKVxuICogXG4gKiAgIElmIHlvdSBoYXZlIGEgM0QgbW9kZWwgd2l0aCBwcm9wZXJ0eURiIGxvYWRlZCwgeW91IHNob3VsZCBub3cgc2VlIGEgYnV0dG9uIGluIHRoZSB0b29sYmFyIHRvIHRyaWdnZXIgY2x1c3RlcmluZyBiYXNlZCBvbiBDYXRlZ29yeSBhdHRyaWJ1dGUuXG4gKiAgXG4gKiBAbWVtYmVyb2YgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zXG4gKiBAYWxpYXMgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLlZpc3VhbENsdXN0ZXJzXG4gKiBAc2VlIHtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbn0gZm9yIGNvbW1vbiBpbmhlcml0ZWQgbWV0aG9kcy5cbiAqIEBjb25zdHJ1Y3RvclxuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpc3VhbENsdXN0ZXJzRXh0ZW5zaW9uIGV4dGVuZHMgYXYuRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIodmlld2VyLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBJZiB0cnVlLCB0aGUgdG9nZ2xlIGJ1dHRvbiBmb3IgdGhlIGxheW91dCBpcyBwcmVzc2VkIGFuZCBhbGwgb2JqZWN0c1xuICAgICAgICAvLyBhcmUgYXJyYW5nZWQgaW4gY2x1c3RlcnMgKG9yIGJlaW5nIGNvbXB1dGVkIG9yIGFuaW1hdGluZyB0b3dhcmRzIHRoYXQgc3RhdGUpXG4gICAgICAgIHRoaXMubGF5b3V0QWN0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gVXNlZCB0byBkZXRlY3QgaWYgYW4gYXN5bmMgbGF5b3V0IGNvbXB1dGF0aW9uIGlzIG1lYW53aGlsZSBvdXRkYXRlZC5cbiAgICAgICAgdGhpcy5sYXlvdXRUaW1lU3RhbXAgPSAwO1xuXG4gICAgICAgIC8vIENvbnRyb2xzIHRyYW5zaXRpb25zIGJldHdlZW4gY2x1c3RlcmVkIGFuZCBvcmlnaW5hbCBzdGF0ZVxuICAgICAgICB0aGlzLmFuaW1Db250cm9sbGVyID0gbmV3IEFuaW1Db250cm9sbGVyKHRoaXMudmlld2VyKTtcblxuICAgICAgICAvLyBDb250cm9scyBnaXptb3MgYW5kIGxhYmVscyBmb3IgY2x1c3RlcnNcbiAgICAgICAgdGhpcy5naXptb0NvbnRyb2xsZXIgPSBuZXcgQ2x1c3Rlckdpem1vQ29udHJvbGxlcih0aGlzLnZpZXdlcik7XG5cbiAgICAgICAgLy8gQmluZCBldmVudCBsaXN0ZW5lciBjYWxsYmFja3NcbiAgICAgICAgdGhpcy5vbk1vZGVsQWRkZWRDYiAgID0gdGhpcy5vbk1vZGVsQWRkZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vZGVsUmVtb3ZlZENiID0gdGhpcy5vbk1vZGVsUmVtb3ZlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRiTG9hZGVkQ2IgICAgICAgPSB0aGlzLm9uRGJMb2FkZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmRlZENiICAgPSB0aGlzLm9uVHJhbnNpdGlvbkVuZGVkLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZCgpIHtcblxuICAgICAgICBhd2FpdCB0aGlzLnZpZXdlci5sb2FkRXh0ZW5zaW9uKCdBdXRvZGVzay5FZGl0M0QnKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNraXBEZWZhdWx0TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoYXYuTU9ERUxfQURERURfRVZFTlQsIHRoaXMub25Nb2RlbEFkZGVkQ2IpO1xuICAgICAgICB0aGlzLnZpZXdlci5hZGRFdmVudExpc3RlbmVyKGF2Lk1PREVMX1JFTU9WRURfRVZFTlQsIHRoaXMub25Nb2RlbFJlbW92ZWRDYik7XG4gICAgICAgIHRoaXMudmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoYXYuT0JKRUNUX1RSRUVfQ1JFQVRFRF9FVkVOVCwgdGhpcy5kYkxvYWRlZENiKTtcbiAgICAgICAgdGhpcy52aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihhdi5BTklNX0VOREVELCB0aGlzLm9uVHJhbnNpdGlvbkVuZGVkQ2IpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB1bmxvYWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnNraXBEZWZhdWx0TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdlci5yZW1vdmVFdmVudExpc3RlbmVyKGF2Lk1PREVMX0FEREVEX0VWRU5ULCB0aGlzLm9uTW9kZWxBZGRlZENiKTtcbiAgICAgICAgICAgIHRoaXMudmlld2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoYXYuTU9ERUxfUkVNT1ZFRF9FVkVOVCwgdGhpcy5vbk1vZGVsUmVtb3ZlZENiKTtcbiAgICAgICAgICAgIHRoaXMudmlld2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoYXYuT0JKRUNUX1RSRUVfQ1JFQVRFRF9FVkVOVCwgdGhpcy5vbkRiTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMudmlld2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoYXYuQU5JTV9FTkRFRCwgdGhpcy5vblRyYW5zaXRpb25FbmRlZENiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldmVydCBhbGwgYW5pbSB0cmFuc2Zvcm0gY2hhbmdlcy5cbiAgICAgICAgdGhpcy5hbmltQ29udHJvbGxlci5yZXNldCgpO1xuXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lVSSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCB0byBpbml0aWFsIHN0YXRlLlxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmFuaW1Db250cm9sbGVyLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZ2l6bW9Db250cm9sbGVyLnJlc2V0KCk7XG4gICAgICAgIHRoaXMubGF5b3V0QWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlQnV0dG9uKCk7XG4gICAgfVxuXG4gICAgb25Nb2RlbEFkZGVkKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUJ1dHRvbigpO1xuICAgIH1cblxuICAgIG9uTW9kZWxSZW1vdmVkKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUJ1dHRvbigpO1xuXG4gICAgICAgIC8vIEF1dG8tcmVzZXQ6IFdoZW4gcmVzZXQgYWxsIGFuaW1hdGlvbiB0cmFuc2Zvcm1zIGFuZCBleHRlbnNpb24gc3RhdGUuXG4gICAgICAgIC8vIFRoaXMgYXZvaWRzIGxlYWtpbmcgYW55IHN0YXRlIGluZm9ybWF0aW9uIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gdmlld3MuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGU6IFdoZW4gdGVtcG9yYXJpbHkgc3dpdGNoaW5nIGFsbCBtb2RlbHMgb2ZmIGluIGEgbXVsdGktbW9kZWwgc2NlbmFyaW8sIGF1dG8tcmVzZXQgbWlnaHRcbiAgICAgICAgLy8gICAgICAgbm90IGJlIHdhbnRlZC4gSWYgd2UgbmVlZCB0byBzdXBwb3J0IHRoYXQgY2FzZSwgd2UgbmVlZCBhIGNvbmNlcHQgdG8gdGVsbCB0aGUgZXh0ZW5zaW9uXG4gICAgICAgIC8vICAgICAgIGV4cGxpY2l0bHkgd2hldGhlciBhIHZpZXctc3dpdGNoIG9jY3VycmVkIG9yIGxlYXZlIHRoZSByZXNldCB0byB0aGUgY2xpZW50LlxuICAgICAgICBjb25zdCBsYXN0TW9kZWxSZW1vdmVkID0gIXRoaXMudmlld2VyLmdldFZpc2libGVNb2RlbHMoKS5sZW5ndGg7XG4gICAgICAgIGlmIChsYXN0TW9kZWxSZW1vdmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkRiTG9hZGVkKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUJ1dHRvbigpO1xuICAgIH1cblxuICAgIG9uVG9vbGJhckNyZWF0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2tpcERlZmF1bHRCdXR0b24pe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbHVzdGVyQnV0dG9uID0gbmV3IGF2dS5CdXR0b24oXCJ0b29sYmFyLWNsdXN0ZXJUb29sXCIpO1xuICAgICAgICB0aGlzLmNsdXN0ZXJCdXR0b24uaWNvbi5pbm5lckhUTUwgPSBjcmVhdGVDbHVzdGVySWNvbigpO1xuXG4gICAgICAgIC8vIGFkZCBidXR0b24gdG8gdG9vbGJhciBzZWN0aW9uICdNb2RlbCBUb29scydcbiAgICAgICAgbGV0IHRvb2xiYXIgPSB0aGlzLnZpZXdlci5nZXRUb29sYmFyICYmIHRoaXMudmlld2VyLmdldFRvb2xiYXIoKTtcbiAgICAgICAgaWYgKHRvb2xiYXIpIHtcbiAgICAgICAgICAgIGxldCBtb2RlbFRvb2xzID0gdG9vbGJhci5nZXRDb250cm9sKGF2LlRPT0xCQVIuTU9ERUxUT09MU0lEKTtcblxuICAgICAgICAgICAgLy8gQWRkIG91ciBidXR0b24gdG8gdGhlIHRvb2xiYXJcbiAgICAgICAgICAgIGlmIChtb2RlbFRvb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVG9vbHMuYWRkQ29udHJvbCh0aGlzLmNsdXN0ZXJCdXR0b24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbHVzdGVyQnV0dG9uLm9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldExheW91dEFjdGl2ZSghdGhpcy5sYXlvdXRBY3RpdmUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudXBkYXRlQnV0dG9uKCk7XG4gICAgfVxuXG4gICAgb25UcmFuc2l0aW9uU3RhcnRlZCgpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgYW5pbWF0aW9uIHN0YXRlIGlzIGF2YWlsYWJsZSBhbmQgd2hldGhlciB0aGVyZSBhcmUgY2x1c3RlcnNcbiAgICAgICAgLy8gKG1vZGVscyB3aXRoIGNsdXN0ZXJzIGhhdmUgYW4gYW5pbVN0YXRlcyBhcnJheSB3aXRoIGxlbmd0aCBiaWdnZXIgdGhhbiAwKVxuICAgICAgICBpZiAoQ2x1c3RlcmVkU3RhdGVOYW1lIGluIHRoaXMuYW5pbUNvbnRyb2xsZXIuc3RhdGVzICYmXG4gICAgICAgICAgICB0aGlzLmFuaW1Db250cm9sbGVyLnN0YXRlc1tDbHVzdGVyZWRTdGF0ZU5hbWVdLmFuaW1TdGF0ZXMuZmlsdGVyKEJvb2xlYW4pWzBdLmFuaW1TdGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy52aWV3ZXIuZmlyZUV2ZW50KHsgdHlwZTogYXYuVFJBTlNJVElPTl9TVEFSVEVELCBzY2VuZUFuaW1TdGF0ZTogdGhpcy5hbmltQ29udHJvbGxlci5zdGF0ZXNbQ2x1c3RlcmVkU3RhdGVOYW1lXX0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52aWV3ZXIuZmlyZUV2ZW50KHsgdHlwZTogYXYuVFJBTlNJVElPTl9TVEFSVEVELCBzY2VuZUFuaW1TdGF0ZTogbnVsbH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25UcmFuc2l0aW9uRW5kZWQoKSB7XG4gICAgICAgIGlmIChDbHVzdGVyZWRTdGF0ZU5hbWUgaW4gdGhpcy5hbmltQ29udHJvbGxlci5zdGF0ZXMgJiZcbiAgICAgICAgICAgIHRoaXMuYW5pbUNvbnRyb2xsZXIuc3RhdGVzW0NsdXN0ZXJlZFN0YXRlTmFtZV0uYW5pbVN0YXRlcy5maWx0ZXIoQm9vbGVhbilbMF0uYW5pbVN0YXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdlci5maXJlRXZlbnQoeyB0eXBlOiBhdi5UUkFOU0lUSU9OX0VOREVELCBzY2VuZUFuaW1TdGF0ZTogdGhpcy5hbmltQ29udHJvbGxlci5zdGF0ZXNbQ2x1c3RlcmVkU3RhdGVOYW1lXX0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52aWV3ZXIuZmlyZUV2ZW50KHsgdHlwZTogYXYuVFJBTlNJVElPTl9FTkRFRCwgc2NlbmVBbmltU3RhdGU6IG51bGx9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9kZXN0cm95VUkoKSB7XG4gICAgICAgIC8vIFJlbW92ZSBidXR0b24gZnJvbSB0b29sYmFyXG4gICAgICAgIGlmICh0aGlzLmNsdXN0ZXJCdXR0b24pIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xiYXIgPSB0aGlzLnZpZXdlci5nZXRUb29sYmFyICYmIHRoaXMudmlld2VyLmdldFRvb2xiYXIoKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsVG9vbHMgPSB0b29sYmFyICYmIHRvb2xiYXIuZ2V0Q29udHJvbChhdi5UT09MQkFSLk1PREVMVE9PTFNJRCk7XG4gICAgICAgICAgICBpZiAobW9kZWxUb29scykge1xuICAgICAgICAgICAgICAgIG1vZGVsVG9vbHMucmVtb3ZlQ29udHJvbCh0aGlzLmNsdXN0ZXJCdXR0b24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbHVzdGVyQnV0dG9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldExheW91dEFjdGl2ZShmYWxzZSk7XG4gICAgfVxuXG4gICAgc2V0TGF5b3V0QWN0aXZlKGFjdGl2ZSwgYXR0cmlidXRlTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5sYXlvdXRBY3RpdmUgPT09IGFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5kaWNhdGUgdGhhdCBsYXlvdXQgaXMgYWN0aXZhdGVkXG4gICAgICAgIHRoaXMubGF5b3V0QWN0aXZlID0gYWN0aXZlO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQnV0dG9uKCk7XG5cbiAgICAgICAgLy8gTGF5b3V0IGRpc2FibGVkOiBBbmltYXRlIGJhY2sgdG8gb3JpZ2luYWwgc3RhdGVcbiAgICAgICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMub25UcmFuc2l0aW9uU3RhcnRlZCgpO1xuICAgICAgICAgICAgdGhpcy5hbmltQ29udHJvbGxlci5hbmltYXRlVG8obnVsbCk7XG4gICAgICAgICAgICB0aGlzLmdpem1vQ29udHJvbGxlci5vbkxheW91dENoYW5nZWQobnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFwcGx5TGF5b3V0KGF0dHJpYnV0ZU5hbWUpO1xuICAgIH1cblxuICAgIGFzeW5jIGFwcGx5TGF5b3V0KGF0dHJpYnV0ZU5hbWUpIHtcblxuICAgICAgICAvLyBnZXQgY3VycmVudGx5IHZpc2libGUvbG9hZGVkIG1vZGVsc1xuICAgICAgICBjb25zdCBtb2RlbHMgPSB0aGlzLnZpZXdlci5nZXRWaXNpYmxlTW9kZWxzKCk7XG5cbiAgICAgICAgLy8gSWYgYSBsYXlvdXQgY29tcHV0YXRpb24gaXMgYWN0aXZlLCBtYXJrIGl0IGFzIG91dGRhdGVkLlxuICAgICAgICB0aGlzLmxheW91dFRpbWVTdGFtcCsrO1xuXG4gICAgICAgIC8vIFJlbWVtYmVyIHRpbWVzdGFtcCBzbyB0aGF0IHdlIGNhbiBjaGVjayBsYXRlciBpZiByZXN1bHQgaXMgc3RpbGwgd2FudGVkXG4gICAgICAgIGNvbnN0IGxheW91dFRpbWVTdGFtcCA9IHRoaXMubGF5b3V0VGltZVN0YW1wO1xuXG4gICAgICAgIGNvbnN0IHNjZW5lTGF5b3V0ID0gdGhpcy5jdXN0b21TY2VuZUxheW91dFxuICAgICAgICAgICAgPyB0aGlzLmN1c3RvbVNjZW5lTGF5b3V0XG4gICAgICAgICAgICA6IGF3YWl0IGNyZWF0ZURlZmF1bHRMYXlvdXQoXG4gICAgICAgICAgICAgICAgICBtb2RlbHMsXG4gICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPyBhdHRyaWJ1dGVOYW1lIDogdGhpcy5vcHRpb25zLmF0dHJpYk5hbWUsXG4gICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2VhcmNoQW5jZXN0b3JzXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgLy8gSWYgdGhpcy5sYXlvdXRUaW1lU3RhbXAgaGFzIGNoYW5nZWQsIHRoZSByZXN1bHQgaXMgb3V0ZGF0ZWQuXG4gICAgICAgIGlmICghdGhpcy5sYXlvdXRBY3RpdmUgfHwgbGF5b3V0VGltZVN0YW1wICE9PSB0aGlzLmxheW91dFRpbWVTdGFtcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY2VuZUxheW91dCA9IHNjZW5lTGF5b3V0O1xuXG4gICAgICAgIC8vIENyZWF0ZSBhbmltYXRpb24gc3RhdGUgdGhhdCByZXByZXNlbnRzIHRoaXMgbGF5b3V0XG4gICAgICAgIHRoaXMuc2NlbmVBbmltU3RhdGUgPSBzY2VuZUxheW91dC5jcmVhdGVTY2VuZVN0YXRlKG1vZGVscyk7XG5cbiAgICAgICAgLy8gTWFrZSBhbmltYXRpb24gc3RhdGUgYXZhaWxhYmxlXG4gICAgICAgIHRoaXMuYW5pbUNvbnRyb2xsZXIucmVnaXN0ZXJTdGF0ZShDbHVzdGVyZWRTdGF0ZU5hbWUsIHRoaXMuc2NlbmVBbmltU3RhdGUpO1xuXG4gICAgICAgIHRoaXMub25UcmFuc2l0aW9uU3RhcnRlZCgpO1xuXG4gICAgICAgIC8vIEFuaW1hdGUgdG8gY2x1c3RlcmVkIGxheW91dFxuICAgICAgICB0aGlzLmFuaW1Db250cm9sbGVyLmFuaW1hdGVUbyhDbHVzdGVyZWRTdGF0ZU5hbWUpO1xuICAgICAgICB0aGlzLmdpem1vQ29udHJvbGxlci5vbkxheW91dENoYW5nZWQodGhpcy5zY2VuZUxheW91dCk7XG4gICAgfVxuXG4gICAgdXBkYXRlQnV0dG9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2x1c3RlckJ1dHRvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW9kZWxzID0gdGhpcy52aWV3ZXIuZ2V0VmlzaWJsZU1vZGVscygpO1xuXG4gICAgICAgIC8vIE9ubHkgc2hvdyBidXR0b24gaWYgd2UgaGF2ZSA+PTEgM0QgbW9kZWwuIE5vdGUgdGhhdCB3ZSBjYW5ub3QgcmVseSBvbiB0aGlzLnZpZXdlci5pbXBsLmlzMmQsIGJlY2F1c2UgaXRcbiAgICAgICAgLy8gaXMgc2V0IGFmdGVyIGFkZE1vZGVsIGV2ZW50IGlzIGZpcmVkLlxuICAgICAgICBjb25zdCBzaG93QnV0dG9uID0gbW9kZWxzLnNvbWUobW9kZWwgPT4gbW9kZWwuaXMzZCgpKTtcbiAgICAgICAgdGhpcy5jbHVzdGVyQnV0dG9uLnNldFZpc2libGUoc2hvd0J1dHRvbik7XG4gICAgICAgIGlmICghc2hvd0J1dHRvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlzYWJsZSBidXR0b24gaWYgc29tZSBwcm9wRGIgaXMgc3RpbGwgbG9hZGluZyBvciBpZiB3ZSBkb24ndCBoYXZlIGFueSBwcm9wRGIgYXQgYWxsLlxuICAgICAgICBjb25zdCBwcm9wRGJMb2FkaW5nID0gKG1vZGVsKSA9PiBtb2RlbC5nZXRQcm9wZXJ0eURiKCkgJiYgIW1vZGVsLmdldFByb3BlcnR5RGIoKS5pc0xvYWREb25lKCk7XG4gICAgICAgIGNvbnN0IHByb3BEYk1pc3NpbmcgPSAobW9kZWwpID0+ICFwcm9wRGJMb2FkaW5nKG1vZGVsKSAmJiAhbW9kZWwuZ2V0SW5zdGFuY2VUcmVlKCk7XG4gICAgICAgIGNvbnN0IHdhaXRGb3JEYiA9IG1vZGVscy5zb21lKHByb3BEYkxvYWRpbmcpO1xuICAgICAgICBjb25zdCBub1Byb3BEYiAgPSBtb2RlbHMuc29tZShwcm9wRGJNaXNzaW5nKTtcbiAgICAgICAgY29uc3QgZGlzYWJsZSAgID0gd2FpdEZvckRiIHx8IG5vUHJvcERiO1xuXG4gICAgICAgIC8vIENob29zZSBidXR0b24gdG9vbHRpcC4gSWYgd2UgZGlzYWJsZSwgZXhwbGFpbiB3aHkuXG4gICAgICAgIGxldCB0b29sdGlwICA9ICdGb3JtIENsdXN0ZXJzIGJ5IENhdGVnb3J5JztcbiAgICAgICAgaWYgKGRpc2FibGUpIHtcbiAgICAgICAgICAgIHRvb2x0aXAgPSB3YWl0Rm9yRGIgPyAnV2FpdGluZyBmb3IgZGF0YWJhc2UgdG8gbG9hZCcgOiAnVmlzdWFsIENsdXN0ZXJpbmcgY2FuIG9ubHkgYmUgdXNlZCBpZiBhIGRhdGFiYXNlIGlzIGF2YWlsYWJsZSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbHVzdGVyQnV0dG9uLnNldFRvb2xUaXAodG9vbHRpcCk7XG5cbiAgICAgICAgLy8gU2V0IGJ1dHRvbiBzdGF0ZVxuICAgICAgICBpZiAoZGlzYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5jbHVzdGVyQnV0dG9uLnNldFN0YXRlKGF2dS5CdXR0b24uU3RhdGUuRElTQUJMRUQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbHVzdGVyQnV0dG9uLnNldFN0YXRlKHRoaXMubGF5b3V0QWN0aXZlID8gYXZ1LkJ1dHRvbi5TdGF0ZS5BQ1RJVkUgOiBhdnUuQnV0dG9uLlN0YXRlLklOQUNUSVZFKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuYXYudGhlRXh0ZW5zaW9uTWFuYWdlci5yZWdpc3RlckV4dGVuc2lvbignQXV0b2Rlc2suVmlzdWFsQ2x1c3RlcnMnLCBWaXN1YWxDbHVzdGVyc0V4dGVuc2lvbik7XG5cbm5hbWVzcGFjZS5idWlsZENsdXN0ZXJzRnJvbUF0dHJpYnV0ZSA9IGJ1aWxkQ2x1c3RlcnNGcm9tQXR0cmlidXRlO1xubmFtZXNwYWNlLkNsdXN0ZXIgPSBDbHVzdGVyO1xubmFtZXNwYWNlLmNyZWF0ZVNoYXBlSWQgPSBjcmVhdGVTaGFwZUlkO1xubmFtZXNwYWNlLmNyZWF0ZUNsdXN0ZXJTZXRMYXlvdXQgPSBjcmVhdGVDbHVzdGVyU2V0TGF5b3V0O1xubmFtZXNwYWNlLlNoYXBlQm94ZXMgPSBTaGFwZUJveGVzO1xubmFtZXNwYWNlLkFuaW1Db25zdHJvbGxlciA9IEFuaW1Db250cm9sbGVyO1xubmFtZXNwYWNlLmhhc1Zpc2libGVGcmFnbWVudHMgPSBoYXNWaXNpYmxlRnJhZ21lbnRzO1xubmFtZXNwYWNlLk9iamVjdEFuaW1TdGF0ZSA9IE9iamVjdEFuaW1TdGF0ZTtcbm5hbWVzcGFjZS5Nb2RlbEFuaW1TdGF0ZSA9IE1vZGVsQW5pbVN0YXRlO1xubmFtZXNwYWNlLlNjZW5lQW5pbVN0YXRlID0gU2NlbmVBbmltU3RhdGU7XG5uYW1lc3BhY2UuZ2V0Qm94Q29ybmVyID0gZ2V0Qm94Q29ybmVyO1xubmFtZXNwYWNlLmZpbmRBbGlnbm1lbnRSb3RhdGlvbiA9IGZpbmRBbGlnbm1lbnRSb3RhdGlvbjtcbm5hbWVzcGFjZS5jb21wdXRlT2JqZWN0QWxpZ25tZW50ID0gY29tcHV0ZU9iamVjdEFsaWdubWVudDtcbm5hbWVzcGFjZS5Sb3RhdGlvbkFsaWdubWVudCA9IFJvdGF0aW9uQWxpZ25tZW50O1xuIl0sIm5hbWVzIjpbImJ1aWxkQ2x1c3RlcnNGcm9tQXR0cmlidXRlIiwiQ2x1c3RlciIsImNyZWF0ZVNoYXBlSWQiLCJoYXNWaXNpYmxlRnJhZ21lbnRzIiwiY3JlYXRlQ2x1c3RlclNldExheW91dCIsIkFuaW1Db250cm9sbGVyIiwiU2hhcGVCb3hlcyIsIk9iamVjdEFuaW1TdGF0ZSIsIk1vZGVsQW5pbVN0YXRlIiwiU2NlbmVBbmltU3RhdGUiLCJDbHVzdGVyR2l6bW9Db250cm9sbGVyIiwiUm90YXRpb25BbGlnbm1lbnQiLCJnZXRCb3hDb3JuZXIiLCJmaW5kQWxpZ25tZW50Um90YXRpb24iLCJjb21wdXRlT2JqZWN0QWxpZ25tZW50IiwiYXYiLCJBdXRvZGVzayIsIlZpZXdpbmciLCJhdnUiLCJVSSIsIm5hbWVzcGFjZSIsIkF1dG9kZXNrTmFtZXNwYWNlIiwiQ2x1c3RlcmVkU3RhdGVOYW1lIiwiY3JlYXRlQ2x1c3Rlckljb24iLCJqb2luIiwiY3JlYXRlRGVmYXVsdExheW91dCIsIm1vZGVscyIsImFsaWduU2hhcGVSb3RhdGlvbiIsImF0dHJpYk5hbWUiLCJzZWFyY2hBbmNlc3RvcnMiLCJtb2RlbFN1cHBvcnRlZCIsIm1vZGVsIiwiaXMzZCIsIkJvb2xlYW4iLCJnZXRJbnN0YW5jZVRyZWUiLCJmaWx0ZXIiLCJjbHVzdGVycyIsImMiLCJuYW1lIiwicm90YXRpb25BbGlnbm1lbnQiLCJzaGFwZUJveGVzIiwiVmlzdWFsQ2x1c3RlcnNFeHRlbnNpb24iLCJFeHRlbnNpb24iLCJjb25zdHJ1Y3RvciIsInZpZXdlciIsIm9wdGlvbnMiLCJsYXlvdXRBY3RpdmUiLCJsYXlvdXRUaW1lU3RhbXAiLCJhbmltQ29udHJvbGxlciIsImdpem1vQ29udHJvbGxlciIsIm9uTW9kZWxBZGRlZENiIiwib25Nb2RlbEFkZGVkIiwiYmluZCIsIm9uTW9kZWxSZW1vdmVkQ2IiLCJvbk1vZGVsUmVtb3ZlZCIsImRiTG9hZGVkQ2IiLCJvbkRiTG9hZGVkIiwib25UcmFuc2l0aW9uRW5kZWRDYiIsIm9uVHJhbnNpdGlvbkVuZGVkIiwibG9hZCIsImxvYWRFeHRlbnNpb24iLCJza2lwRGVmYXVsdExpc3RlbmVycyIsImFkZEV2ZW50TGlzdGVuZXIiLCJNT0RFTF9BRERFRF9FVkVOVCIsIk1PREVMX1JFTU9WRURfRVZFTlQiLCJPQkpFQ1RfVFJFRV9DUkVBVEVEX0VWRU5UIiwiQU5JTV9FTkRFRCIsInVubG9hZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZXNldCIsIl9kZXN0cm95VUkiLCJ1cGRhdGVCdXR0b24iLCJsYXN0TW9kZWxSZW1vdmVkIiwiZ2V0VmlzaWJsZU1vZGVscyIsImxlbmd0aCIsIm9uVG9vbGJhckNyZWF0ZWQiLCJza2lwRGVmYXVsdEJ1dHRvbiIsImNsdXN0ZXJCdXR0b24iLCJCdXR0b24iLCJpY29uIiwiaW5uZXJIVE1MIiwidG9vbGJhciIsImdldFRvb2xiYXIiLCJtb2RlbFRvb2xzIiwiZ2V0Q29udHJvbCIsIlRPT0xCQVIiLCJNT0RFTFRPT0xTSUQiLCJhZGRDb250cm9sIiwib25DbGljayIsInNldExheW91dEFjdGl2ZSIsIm9uVHJhbnNpdGlvblN0YXJ0ZWQiLCJzdGF0ZXMiLCJhbmltU3RhdGVzIiwiZmlyZUV2ZW50IiwidHlwZSIsIlRSQU5TSVRJT05fU1RBUlRFRCIsInNjZW5lQW5pbVN0YXRlIiwiVFJBTlNJVElPTl9FTkRFRCIsInJlbW92ZUNvbnRyb2wiLCJhY3RpdmUiLCJhdHRyaWJ1dGVOYW1lIiwiYW5pbWF0ZVRvIiwib25MYXlvdXRDaGFuZ2VkIiwiYXBwbHlMYXlvdXQiLCJzY2VuZUxheW91dCIsImN1c3RvbVNjZW5lTGF5b3V0IiwiY3JlYXRlU2NlbmVTdGF0ZSIsInJlZ2lzdGVyU3RhdGUiLCJzaG93QnV0dG9uIiwic29tZSIsInNldFZpc2libGUiLCJwcm9wRGJMb2FkaW5nIiwiZ2V0UHJvcGVydHlEYiIsImlzTG9hZERvbmUiLCJwcm9wRGJNaXNzaW5nIiwid2FpdEZvckRiIiwibm9Qcm9wRGIiLCJkaXNhYmxlIiwidG9vbHRpcCIsInNldFRvb2xUaXAiLCJzZXRTdGF0ZSIsIlN0YXRlIiwiRElTQUJMRUQiLCJBQ1RJVkUiLCJJTkFDVElWRSIsInRoZUV4dGVuc2lvbk1hbmFnZXIiLCJyZWdpc3RlckV4dGVuc2lvbiIsIkFuaW1Db25zdHJvbGxlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./extensions/VisualClusters/VisualClusters.js\n");

                /***/
            })

        /******/
    });
    /************************************************************************/
    /******/ // The module cache
    /******/
    var __webpack_module_cache__ = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/
        var cachedModule = __webpack_module_cache__[moduleId];
        /******/
        if (cachedModule !== undefined) {
            /******/
            return cachedModule.exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = __webpack_module_cache__[moduleId] = {
            /******/ // no module.id needed
            /******/ // no module.loaded needed
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /************************************************************************/
    /******/
    /* webpack/runtime/define property getters */
    /******/
    (() => {
        /******/ // define getter functions for harmony exports
        /******/
        __webpack_require__.d = (exports, definition) => {
            /******/
            for (var key in definition) {
                /******/
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                    /******/
                    Object.defineProperty(exports, key, {
                        enumerable: true,
                        get: definition[key]
                    });
                    /******/
                }
                /******/
            }
            /******/
        };
        /******/
    })();
    /******/
    /******/
    /* webpack/runtime/hasOwnProperty shorthand */
    /******/
    (() => {
        /******/
        __webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
        /******/
    })();
    /******/
    /******/
    /* webpack/runtime/make namespace object */
    /******/
    (() => {
        /******/ // define __esModule on exports
        /******/
        __webpack_require__.r = (exports) => {
            /******/
            if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                /******/
                Object.defineProperty(exports, Symbol.toStringTag, {
                    value: 'Module'
                });
                /******/
            }
            /******/
            Object.defineProperty(exports, '__esModule', {
                value: true
            });
            /******/
        };
        /******/
    })();
    /******/
    /************************************************************************/
    /******/
    /******/ // startup
    /******/ // Load entry module and return exports
    /******/ // This entry module can't be inlined because the eval-source-map devtool is used.
    /******/
    var __webpack_exports__ = __webpack_require__("./extensions/VisualClusters/VisualClusters.js");
    /******/
    Autodesk.Extensions.VisualClusters = __webpack_exports__;
    /******/
    /******/
})();