/*!
 * LMV v7.96.0
 *
 * Copyright 2024 Autodesk, Inc.
 * All rights reserved.
 *
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 *
 * Autodesk Viewer SDK Usage Limitations:
 *
 * The Autodesk Viewer SDK JavaScript must be delivered from an
 * Autodesk-hosted URL.
 */
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/
(() => { // webpackBootstrap
    /******/
    var __webpack_modules__ = ({

        /***/
        "./extensions/Snapping/SnapMath.js":
            /*!*****************************************!*\
              !*** ./extensions/Snapping/SnapMath.js ***!
              \*****************************************/
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   intersectLines: () => (/* binding */ intersectLines),\n/* harmony export */   nearestPointOnCircularArc: () => (/* binding */ nearestPointOnCircularArc)\n/* harmony export */ });\n\n// Collection of static math functions used for snapping implementation\n\n// Find closest point to p on a circular arc. \n//  @param {Vector2} center\n//  @param {number} radius\n//  @param {number} startAngle, endAngle - ccw angles in radians. 0 means direction x+\n//  @param {Vector2} [outPoint]\n//  @param {Vector2}\nconst nearestPointOnCircularArc = (p, center, radius, startAngle, endAngle, outPoint) => {\n\n  outPoint = outPoint || new THREE.Vector2();\n\n  // get normalized direction from circle center to p.\n  // dir = (p-center).normalized()\n  const dir = outPoint.copy(p).sub(center).normalize();\n\n  // If the point is within the arc, we are done\n  const angle = Math.atan2(dir.y, dir.x);\n  const insideArc = Autodesk.Extensions.CompGeom.angleInsideArc(angle, startAngle, endAngle);\n  if (insideArc) {\n    // The ray from center towards p intersects the circle arc.\n    // So, we obtain the closest point by projecting p onto the circle.\n    //\n    // Since dir is the normalized direction from center to p, we obtain the circle projection by:\n    //  onCircleArc = center + dir * radius\n    return dir.multiplyScalar(radius).add(center);\n  }\n\n  // The closest point on the circle is not on the arc.\n  // Then the closest point must be one of the arc ends. Note that this conclusion\n  // can only be made for circles, but not for ellipses with different radii.\n  const pStart = Autodesk.Extensions.CompGeom.getEllipsePoint(startAngle, center.x, center.y, radius, radius);\n  const pEnd = Autodesk.Extensions.CompGeom.getEllipsePoint(endAngle, center.x, center.y, radius, radius);\n\n  const d2Start = pStart.distanceToSquared(p);\n  const d2End = pEnd.distanceToSquared(p);\n  const startIsCloser = d2Start <= d2End;\n\n  outPoint.copy(startIsCloser ? pStart : pEnd);\n  return outPoint;\n};\n\n// Compute intersection of two line segments\n// based on http://www.paulbourke.net/geometry/pointlineplane/\n//  @param {Vector2} p1, p2               - First line segment\n//  @param {Vector2} p3, p4               - Second line segment\n//  @param {bool}    [checkInsideSegment] - If true, we reject line intersections outside the segment ranges\n//  @param {Vector2} [outPoint]           - Optional target vector\n//  @param {number}  [epsilon]            - Nearly-zero threshold used to determine \"nearly-parallel\" resp. \"nearly-zero-length line\"\n//  @param {Vector2|null}\nconst intersectLines = function (p1, p2, p3, p4, checkInsideSegment, outPoint) {let epsilon = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0.00001;\n\n  const denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n\n  // Reject if lines are parallel or one of them has zero-length\n  if (Math.abs(denom) < epsilon) {\n    return null;\n  }\n\n  // ua denotes where to find the intersection point p along segment (p1, p2):\n  //   For ua = 0, we have p = p1\n  //   For ua = 1, we have p = p2\n  let ua = (p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x);\n  ua /= denom;\n\n  // Apply segment check\n  if (checkInsideSegment) {\n\n    // ub denotes where to find the intersection point p along segment (p3, p4)\n    let ub = (p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x);\n    ub /= denom;\n\n    // Intersection is within the segments if ua and ub are both in [0,1]\n    if (ua < 0.0 || ua > 1.0 ||\n    ub < 0.0 || ub > 1.0) {\n      return null;\n    }\n  }\n\n  outPoint = outPoint || new THREE.Vector2();\n\n  outPoint.x = p1.x + ua * (p2.x - p1.x);\n  outPoint.y = p1.y + ua * (p2.y - p1.y);\n  return outPoint;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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NEIsRUFBRSxJQUFJVixFQUFFLENBQUNsQixDQUFDLEdBQUdpQixFQUFFLENBQUNqQixDQUFDLENBQUM7RUFDdEMsT0FBT1YsUUFBUTtBQUNuQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQXV0b2Rlc2suRXh0ZW5zaW9ucy8uL2V4dGVuc2lvbnMvU25hcHBpbmcvU25hcE1hdGguanM/YmFkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8vIENvbGxlY3Rpb24gb2Ygc3RhdGljIG1hdGggZnVuY3Rpb25zIHVzZWQgZm9yIHNuYXBwaW5nIGltcGxlbWVudGF0aW9uXG5cbi8vIEZpbmQgY2xvc2VzdCBwb2ludCB0byBwIG9uIGEgY2lyY3VsYXIgYXJjLiBcbi8vICBAcGFyYW0ge1ZlY3RvcjJ9IGNlbnRlclxuLy8gIEBwYXJhbSB7bnVtYmVyfSByYWRpdXNcbi8vICBAcGFyYW0ge251bWJlcn0gc3RhcnRBbmdsZSwgZW5kQW5nbGUgLSBjY3cgYW5nbGVzIGluIHJhZGlhbnMuIDAgbWVhbnMgZGlyZWN0aW9uIHgrXG4vLyAgQHBhcmFtIHtWZWN0b3IyfSBbb3V0UG9pbnRdXG4vLyAgQHBhcmFtIHtWZWN0b3IyfVxuZXhwb3J0IGNvbnN0IG5lYXJlc3RQb2ludE9uQ2lyY3VsYXJBcmMgPSAocCwgY2VudGVyLCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBvdXRQb2ludCkgPT4ge1xuXG4gICAgb3V0UG9pbnQgPSBvdXRQb2ludCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgLy8gZ2V0IG5vcm1hbGl6ZWQgZGlyZWN0aW9uIGZyb20gY2lyY2xlIGNlbnRlciB0byBwLlxuICAgIC8vIGRpciA9IChwLWNlbnRlcikubm9ybWFsaXplZCgpXG4gICAgY29uc3QgZGlyID0gb3V0UG9pbnQuY29weShwKS5zdWIoY2VudGVyKS5ub3JtYWxpemUoKTtcblxuICAgIC8vIElmIHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGFyYywgd2UgYXJlIGRvbmVcbiAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoZGlyLnksIGRpci54KTtcbiAgICBjb25zdCBpbnNpZGVBcmMgPSBBdXRvZGVzay5FeHRlbnNpb25zLkNvbXBHZW9tLmFuZ2xlSW5zaWRlQXJjKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgaWYgKGluc2lkZUFyYykge1xuICAgICAgICAvLyBUaGUgcmF5IGZyb20gY2VudGVyIHRvd2FyZHMgcCBpbnRlcnNlY3RzIHRoZSBjaXJjbGUgYXJjLlxuICAgICAgICAvLyBTbywgd2Ugb2J0YWluIHRoZSBjbG9zZXN0IHBvaW50IGJ5IHByb2plY3RpbmcgcCBvbnRvIHRoZSBjaXJjbGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNpbmNlIGRpciBpcyB0aGUgbm9ybWFsaXplZCBkaXJlY3Rpb24gZnJvbSBjZW50ZXIgdG8gcCwgd2Ugb2J0YWluIHRoZSBjaXJjbGUgcHJvamVjdGlvbiBieTpcbiAgICAgICAgLy8gIG9uQ2lyY2xlQXJjID0gY2VudGVyICsgZGlyICogcmFkaXVzXG4gICAgICAgIHJldHVybiBkaXIubXVsdGlwbHlTY2FsYXIocmFkaXVzKS5hZGQoY2VudGVyKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgY2lyY2xlIGlzIG5vdCBvbiB0aGUgYXJjLlxuICAgIC8vIFRoZW4gdGhlIGNsb3Nlc3QgcG9pbnQgbXVzdCBiZSBvbmUgb2YgdGhlIGFyYyBlbmRzLiBOb3RlIHRoYXQgdGhpcyBjb25jbHVzaW9uXG4gICAgLy8gY2FuIG9ubHkgYmUgbWFkZSBmb3IgY2lyY2xlcywgYnV0IG5vdCBmb3IgZWxsaXBzZXMgd2l0aCBkaWZmZXJlbnQgcmFkaWkuXG4gICAgY29uc3QgcFN0YXJ0ID0gQXV0b2Rlc2suRXh0ZW5zaW9ucy5Db21wR2VvbS5nZXRFbGxpcHNlUG9pbnQoc3RhcnRBbmdsZSwgY2VudGVyLngsIGNlbnRlci55LCByYWRpdXMsIHJhZGl1cyk7XG4gICAgY29uc3QgcEVuZCAgID0gQXV0b2Rlc2suRXh0ZW5zaW9ucy5Db21wR2VvbS5nZXRFbGxpcHNlUG9pbnQoZW5kQW5nbGUsIGNlbnRlci54LCBjZW50ZXIueSwgcmFkaXVzLCByYWRpdXMpO1xuXG4gICAgY29uc3QgZDJTdGFydCA9IHBTdGFydC5kaXN0YW5jZVRvU3F1YXJlZChwKTtcbiAgICBjb25zdCBkMkVuZCAgID0gcEVuZC5kaXN0YW5jZVRvU3F1YXJlZChwKTtcbiAgICBjb25zdCBzdGFydElzQ2xvc2VyID0gZDJTdGFydCA8PSBkMkVuZDtcblxuICAgIG91dFBvaW50LmNvcHkoc3RhcnRJc0Nsb3NlciA/IHBTdGFydCA6IHBFbmQpO1xuICAgIHJldHVybiBvdXRQb2ludDtcbn07XG5cbi8vIENvbXB1dGUgaW50ZXJzZWN0aW9uIG9mIHR3byBsaW5lIHNlZ21lbnRzXG4vLyBiYXNlZCBvbiBodHRwOi8vd3d3LnBhdWxib3Vya2UubmV0L2dlb21ldHJ5L3BvaW50bGluZXBsYW5lL1xuLy8gIEBwYXJhbSB7VmVjdG9yMn0gcDEsIHAyICAgICAgICAgICAgICAgLSBGaXJzdCBsaW5lIHNlZ21lbnRcbi8vICBAcGFyYW0ge1ZlY3RvcjJ9IHAzLCBwNCAgICAgICAgICAgICAgIC0gU2Vjb25kIGxpbmUgc2VnbWVudFxuLy8gIEBwYXJhbSB7Ym9vbH0gICAgW2NoZWNrSW5zaWRlU2VnbWVudF0gLSBJZiB0cnVlLCB3ZSByZWplY3QgbGluZSBpbnRlcnNlY3Rpb25zIG91dHNpZGUgdGhlIHNlZ21lbnQgcmFuZ2VzXG4vLyAgQHBhcmFtIHtWZWN0b3IyfSBbb3V0UG9pbnRdICAgICAgICAgICAtIE9wdGlvbmFsIHRhcmdldCB2ZWN0b3Jcbi8vICBAcGFyYW0ge251bWJlcn0gIFtlcHNpbG9uXSAgICAgICAgICAgIC0gTmVhcmx5LXplcm8gdGhyZXNob2xkIHVzZWQgdG8gZGV0ZXJtaW5lIFwibmVhcmx5LXBhcmFsbGVsXCIgcmVzcC4gXCJuZWFybHktemVyby1sZW5ndGggbGluZVwiXG4vLyAgQHBhcmFtIHtWZWN0b3IyfG51bGx9XG5leHBvcnQgY29uc3QgaW50ZXJzZWN0TGluZXMgPSAocDEsIHAyLCBwMywgcDQsIGNoZWNrSW5zaWRlU2VnbWVudCwgb3V0UG9pbnQsIGVwc2lsb24gPSAwLjAwMDAxKSA9PiB7XG4gICAgXG4gICAgY29uc3QgZGVub20gPSAocDQueSAtIHAzLnkpICogKHAyLnggLSBwMS54KSAtIChwNC54IC0gcDMueCkgKiAocDIueSAtIHAxLnkpO1xuICAgIFxuICAgIC8vIFJlamVjdCBpZiBsaW5lcyBhcmUgcGFyYWxsZWwgb3Igb25lIG9mIHRoZW0gaGFzIHplcm8tbGVuZ3RoXG4gICAgaWYgKE1hdGguYWJzKGRlbm9tKSA8IGVwc2lsb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gdWEgZGVub3RlcyB3aGVyZSB0byBmaW5kIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgcCBhbG9uZyBzZWdtZW50IChwMSwgcDIpOlxuICAgIC8vICAgRm9yIHVhID0gMCwgd2UgaGF2ZSBwID0gcDFcbiAgICAvLyAgIEZvciB1YSA9IDEsIHdlIGhhdmUgcCA9IHAyXG4gICAgbGV0IHVhID0gKHA0LnggLSBwMy54KSAqIChwMS55IC0gcDMueSkgLSAocDQueSAtIHAzLnkpICogKHAxLnggLSBwMy54KTtcbiAgICB1YSAvPSBkZW5vbTtcbiAgICBcbiAgICAvLyBBcHBseSBzZWdtZW50IGNoZWNrXG4gICAgaWYgKGNoZWNrSW5zaWRlU2VnbWVudCkge1xuXG4gICAgICAgIC8vIHViIGRlbm90ZXMgd2hlcmUgdG8gZmluZCB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IHAgYWxvbmcgc2VnbWVudCAocDMsIHA0KVxuICAgICAgICBsZXQgdWIgPSAocDIueCAtIHAxLngpICogKHAxLnkgLSBwMy55KSAtIChwMi55IC0gcDEueSkgKiAocDEueCAtIHAzLngpO1xuICAgICAgICB1YiAvPSBkZW5vbTtcblxuICAgICAgICAvLyBJbnRlcnNlY3Rpb24gaXMgd2l0aGluIHRoZSBzZWdtZW50cyBpZiB1YSBhbmQgdWIgYXJlIGJvdGggaW4gWzAsMV1cbiAgICAgICAgaWYgKHVhIDwgMC4wIHx8IHVhID4gMS4wIHx8IFxuICAgICAgICAgICAgdWIgPCAwLjAgfHwgdWIgPiAxLjApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIG91dFBvaW50ID0gb3V0UG9pbnQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICBcbiAgICBvdXRQb2ludC54ID0gcDEueCArIHVhICogKHAyLnggLSBwMS54KTtcbiAgICBvdXRQb2ludC55ID0gcDEueSArIHVhICogKHAyLnkgLSBwMS55KTtcbiAgICByZXR1cm4gb3V0UG9pbnQ7XG59O1xuXG5cblxuIl0sIm5hbWVzIjpbIm5lYXJlc3RQb2ludE9uQ2lyY3VsYXJBcmMiLCJwIiwiY2VudGVyIiwicmFkaXVzIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwib3V0UG9pbnQiLCJUSFJFRSIsIlZlY3RvcjIiLCJkaXIiLCJjb3B5Iiwic3ViIiwibm9ybWFsaXplIiwiYW5nbGUiLCJNYXRoIiwiYXRhbjIiLCJ5IiwieCIsImluc2lkZUFyYyIsIkF1dG9kZXNrIiwiRXh0ZW5zaW9ucyIsIkNvbXBHZW9tIiwiYW5nbGVJbnNpZGVBcmMiLCJtdWx0aXBseVNjYWxhciIsImFkZCIsInBTdGFydCIsImdldEVsbGlwc2VQb2ludCIsInBFbmQiLCJkMlN0YXJ0IiwiZGlzdGFuY2VUb1NxdWFyZWQiLCJkMkVuZCIsInN0YXJ0SXNDbG9zZXIiLCJpbnRlcnNlY3RMaW5lcyIsInAxIiwicDIiLCJwMyIsInA0IiwiY2hlY2tJbnNpZGVTZWdtZW50IiwiZXBzaWxvbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImRlbm9tIiwiYWJzIiwidWEiLCJ1YiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./extensions/Snapping/SnapMath.js\n");

                /***/
            }),

        /***/
        "./extensions/Snapping/Snapper.js":
            /*!****************************************!*\
              !*** ./extensions/Snapping/Snapper.js ***!
              \****************************************/
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Snapper: () => (/* binding */ Snapper)\n/* harmony export */ });\n/* harmony import */ var _SnapperIndicator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SnapperIndicator.js */ \"./extensions/Snapping/SnapperIndicator.js\");\n/* harmony import */ var _SnapMath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SnapMath.js */ \"./extensions/Snapping/SnapMath.js\");\n\n\n\n\nconst MeasureCommon = Autodesk.Viewing.MeasureCommon;\nconst EPSILON = MeasureCommon.EPSILON;\nconst SnapType = MeasureCommon.SnapType;\nconst SnapResult = MeasureCommon.SnapResult;\n\nvar SNAP_PRECISION = 0.001;\n\nconst av = Autodesk.Viewing;\nconst avp = av.Private;\nconst VertexBufferReader = avp.VertexBufferReader;\n\n/**\n * @param {number} a - First value to compare\n * @param {number} b - Second value to compare\n * @private\n */\nfunction isEqualWithPrecision(a, b) {\n  return Math.abs(a - b) <= SNAP_PRECISION;\n}\n\n/**\n * Are the vectors equal within SNAP_PRECISION?\n * @param {THREE.Vector3} v1 - vector\n * @param {THREE.Vector3} v2 - vector\n * @returns {boolean} - true when they are equal\n * @private\n */\nfunction isEqualVectorsWithPrecision(v1, v2) {\n  return Math.abs(v1.x - v2.x) <= SNAP_PRECISION &&\n  Math.abs(v1.y - v2.y) <= SNAP_PRECISION &&\n  Math.abs(v1.z - v2.z) <= SNAP_PRECISION;\n}\n\n/**\n * Are the vectors inverse of each other within SNAP_PRECISION?\n * @param {THREE.Vector3} v1 - vector\n * @param {THREE.Vector3} v2 - vector\n * @returns {boolean} - true when they are inverse of each other\n * @private\n */\nfunction isInverseVectorsWithPrecision(v1, v2) {\n  return Math.abs(v1.x + v2.x) <= SNAP_PRECISION &&\n  Math.abs(v1.y + v2.y) <= SNAP_PRECISION &&\n  Math.abs(v1.z + v2.z) <= SNAP_PRECISION;\n}\n\n/**\n * @param {THREE.Vector3} point - Point\n * @param {THREE.Vector3} lineStart - Start of the line\n * @param {THREE.Vector3} lineEnd - End of the line\n * @returns {number} - distance from point to the line\n * @private\n */\nfunction distancePointToLine(point, lineStart, lineEnd) {\n\n  if (lineStart.equals(lineEnd)) {// Degenerate line\n    return point.distanceTo(lineStart);\n  }\n\n  var X0 = new THREE.Vector3();\n  var X1 = new THREE.Vector3();\n  var distance;\n  var param;\n\n  X0.subVectors(lineStart, point);\n  X1.subVectors(lineEnd, lineStart);\n  param = X0.dot(X1);\n  X0.subVectors(lineEnd, lineStart);\n  param = -param / X0.dot(X0);\n\n  if (param < 0) {\n    distance = point.distanceTo(lineStart);\n  } else if (param > 1) {\n    distance = point.distanceTo(lineEnd);\n  } else {\n    X0.subVectors(point, lineStart);\n    X1.subVectors(point, lineEnd);\n    X0.cross(X1);\n    X1.subVectors(lineEnd, lineStart);\n\n    distance = Math.sqrt(X0.dot(X0)) / Math.sqrt(X1.dot(X1));\n  }\n\n  return distance;\n}\n\nconst SnapCandidateType = {\n  Unknown: 0,\n  Line: 1,\n  CircularArc: 2,\n  EllipticalArc: 3\n};\n\n// A SnapCandidate references a single segment (line or arc) that we could snap to.\nclass SnapCandidate {\n  constructor(viewportId) {\n\n    this.type = SnapCandidateType.Unknown;\n    this.viewportId = viewportId;\n\n    // 2d distance between original (unsnapped) position and the geometry of this candidate.\n    this.distance = 0;\n\n    // {Vector2} Start/Endpoint - only for line segments\n    this.lineStart = null;\n    this.lineEnd = null;\n\n    // Fixed radius - only for CircularArcs\n    this.radius = 0;\n\n    // Separate radii - only for ellipse arcs\n    this.radiusX = 0; // = major radius - by convention\n    this.radiusY = 0;\n\n    // Center point as Vector2 (for arcs)\n    this.center = null;\n\n    // Start/end angle for arcs: Ccw angle in radians. Angle 0 corresponds to direction x+.\n    this.startAngle = 0;\n    this.endAngle = 0;\n  }\n\n  fromLine(p1, p2) {\n    this.type = SnapCandidateType.Line;\n    this.lineStart = p1.clone();\n    this.lineEnd = p2.clone();\n    return this;\n  }\n\n  fromCircularArc(center, radius, start, end) {\n    this.type = SnapCandidateType.CircularArc;\n    this.center = center.clone();\n    this.radius = radius;\n    this.start = start;\n    this.end = end;\n    return this;\n  }\n\n  fromEllipticalArc(center, radiusX, radiusY, start, end) {\n    this.type = SnapCandidateType.EllipticalArc;\n    this.center = center.clone();\n    this.radiusX = radiusX;\n    this.radiusY = radiusY;\n    this.start = start;\n    this.end = end;\n    return this;\n  }\n\n  isLine() {return this.type === SnapCandidateType.Line;}\n  isCircularArc() {return this.type === SnapCandidateType.CirularArc;}\n  isEllipticalArc() {return this.type === SnapCandidateType.EllipticalArc;}\n\n  // Checks if the snapGeometry of this candidate intersects with another one.\n  //  @param {SnapCandidate} other\n  //  @param {Vector2} [optionalTarget]\n  //  @returns {THREE.Vector2|null} Returns intersection point if there is one.\n  getIntersection(other, optionalTarget) {\n\n    if (this.isLine() && other.isLine()) {\n      // Note: We do the intersections on the whole line - not just the intersections.\n      // Reason is:\n      //  a) Otherwise, it would not snap if you are slightly outline of one line segment\n      //  b) By definition, we get only very close segment candidates anyway\n      return (0,_SnapMath_js__WEBPACK_IMPORTED_MODULE_1__.intersectLines)(this.lineStart, this.lineEnd, other.lineStart, other.lineEnd, false, optionalTarget);\n    }\n\n    // TODO: Currently, we only support snapping to line-line intersections\n  }\n}\n\n// Checks if we can snap to an intersection of two close segments (each can be a line or arcs).\n//  @param {SnapCandidate[]} candidates     - Snap candidate geometries collected in GeometryCallback. Assumed to be within snapRadius.\n//  @param {TREE.Vector3}    intersectPoint - Unsnapped original position\n//  @param {number}          snapRadius\n//  @returns {Object|null} If an intersection snap is found, the result contains:\n//                    {\n//                        viewportId  // number\n//                        snapPoint   // (THREE.Vector3)\n//                    }\nconst findIntersectionSnap = (candidates, intersectPoint, snapRadius) => {\n\n  // Sort snapping candidates by increasing distance\n  // Strictly speaking, we just need the best two ones. But the number of candidates within the snapping\n  // distance is generally small anyway - and working with a sorted array is more flexible to incrementally\n  // make the snapping smarter later.\n  const byDistance = (ca, cb) => ca.distance - cb.distance;\n  candidates.sort(byDistance);\n\n  // Stop here if we don't have enough candidates for an intersection\n  if (candidates.length < 2) {\n    return null;\n  }\n\n  // Init result object\n  const result = {\n    // Just use the one of the first candidate. There is no unique viewportId when using an intersection.\n    viewportId: candidates[0].viewportId,\n\n    // Snapping happens in 2d - so we set z in advance and just keep the original value.\n    // Note: Snapper generally needs some revision if we use it for planes that are not perpendicular to the viewing direction.\n    snapPoint: new THREE.Vector3(0, 0, intersectPoint.z)\n  };\n\n  // Check for any candidate that intersects with the closest one we found\n  const first = candidates[0];\n  for (let i = 1; i < candidates.length; i++) {\n    const second = candidates[i];\n\n    // Do intersection test. If found, write it to result.snapPoint\n    const found = first.getIntersection(second, result.snapPoint);\n    if (!found) {\n      continue;\n    }\n\n    // We found an intersection. Although we assume all candidates to be within\n    // snap radius already, the intersection may still be somewhere else.\n    // => Check if intersection is still within the snapRadius.\n    const dist = THREE.Vector2.prototype.distanceTo.call(result.snapPoint, intersectPoint);\n    if (dist < snapRadius) {\n      // We found a valid intersection snap\n      return result;\n    }\n  }\n  return null;\n};\n\n\n/**\n * A tool that lets users attach pointer events to vertices and edges. It supports 2D and 3D models.\n *\n * @param {Viewer3D} viewer - Viewer instance\n * @param {object} options - Configurations for the extension\n * @memberof Autodesk.Viewing.Extensions.Snapping\n * @alias Autodesk.Viewing.Extensions.Snapping.Snapper\n * @class\n */\nfunction Snapper(viewer, options) {\n\n  var _snapResult = new SnapResult();\n\n  var _viewer = viewer;\n  this.setGlobalManager(viewer.globalManager);\n\n  var _options = options || {};\n  var _names;\n\n  if (_options.markupMode) {\n    _names = [\"snapper-markup\"];\n  } else if (_options.toolName) {\n    // Allow tools to use their own snapper\n    _names = [_options.toolName];\n  } else {\n    _names = [\"snapper\"];\n  }\n\n  var _priority = 60;\n\n  var _active = false;\n\n  var _distanceToEdge = Number.MAX_VALUE;\n  var _distanceToVertex = null;\n\n  var _isDragging = false;\n  var _isPressing = false;\n  var _isSnapped = false;\n\n  var _forcedVpId = null; // the viewport index of the first selection for 2D\n\n  var _snapToPixel = false;\n\n  var _snapFilter = null; // Optional snapping filter, based on snapResult. (snapResult) => boolean.\n\n  this.indicator = new _SnapperIndicator_js__WEBPACK_IMPORTED_MODULE_0__.SnapperIndicator(viewer, this);\n\n  this.markupMode = _options.markupMode;\n  this.renderSnappedGeometry = _options.renderSnappedGeometry;\n  this.renderSnappedTopology = _options.renderSnappedTopology;\n\n  //Notice: The pixelSize should correspond to the amount of pixels per line in idAtPixels, the shape of\n  //detection area is square in idAtPixels, but circle in snapper, should make their areas match roughly.\n  this.detectRadiusInPixels = av.isMobileDevice() ? 50 : 10;\n\n  /**\n   * @returns {boolean} true when the tool is active\n   *\n   * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isActive\n   */\n  this.isActive = function () {\n    return _active;\n  };\n\n  this.getNames = function () {\n    return _names;\n  };\n\n  this.getName = function () {\n    return _names[0];\n  };\n\n  this.getPriority = function () {\n    return _priority;\n  };\n\n  /**\n   * Starts intercepting pointer events.\n   * Invoked automatically by the {@link ToolController}.\n   *\n   * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#activate\n   */\n  this.activate = function () {\n    _active = true;\n\n    if (this.indicator.isNull()) {\n      this.indicator = new _SnapperIndicator_js__WEBPACK_IMPORTED_MODULE_0__.SnapperIndicator(viewer, this);\n    }\n  };\n\n\n  /**\n   * Stops intercepting pointer events.\n   * Invoked automatically by the {@link ToolController}.\n   *\n   * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#deactivate\n   */\n  this.deactivate = function () {\n    _active = false;\n\n    if (!this.indicator.isNull()) {\n      this.indicator.destroy();\n      this.indicator = new _SnapperIndicator_js__WEBPACK_IMPORTED_MODULE_0__.NullSnapperIndicator();\n    }\n  };\n\n  this.copyResults = function (destiny) {\n    _snapResult.copyTo(destiny);\n  };\n\n  this.getEdge = function () {\n    return _snapResult.geomEdge;\n  };\n\n  this.getVertex = function () {\n    return _snapResult.geomVertex;\n  };\n\n  this.getGeometry = function () {\n    return _snapResult.getGeometry();\n  };\n\n  this.getGeometryType = function () {\n    return _snapResult.geomType;\n  };\n\n  this.getIntersectPoint = function () {\n    return _snapResult.intersectPoint;\n  };\n\n\n  /**\n   * @returns {SnapResult} The snapping status of the last pointer event performed.\n   *\n   * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#getSnapResult\n   */\n  this.getSnapResult = function () {\n    return _snapResult;\n  };\n\n  /**\n   * Checks whether the tool's last update resulted on a snap.\n   *\n   * @returns {boolean} true when the last pointer event got snapped.\n   *\n   * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isSnapped\n   */\n  this.isSnapped = function () {\n    return _isSnapped;\n  };\n\n  this.clearSnapped = function () {\n    _snapResult.clear();\n    _isSnapped = false;\n  };\n\n  this.setViewportId = function (vpId) {\n    _forcedVpId = vpId;\n  };\n\n  this.setSnapToPixel = function (enable) {\n    _snapToPixel = enable;\n  };\n\n  this.getSnapToPixel = function () {\n    return _snapToPixel;\n  };\n\n  this.setSnapToArc = function (enable) {\n    _snapResult.snapToArc = enable;\n  };\n\n  this.getSnapToArc = function () {\n    return _snapResult.snapToArc;\n  };\n\n  this.setArc = function (isArc) {\n    _snapResult.isArc = isArc;\n  };\n\n  this.getArc = function () {\n    return _snapResult.isArc;\n  };\n\n  this.setSnapFilter = function (filter) {\n    _snapFilter = filter;\n  };\n\n  /**\n   * 3D Snapping\n   *\n   * @param result -Result of Hit Test.\n   */\n  this.snapping3D = function (result) {\n\n    _snapResult.snapNode = result.dbId;\n    _snapResult.intersectPoint = result.intersectPoint;\n    _snapResult.modelId = result.model ? result.model.id : null;\n\n    var face = result.face;\n\n    if (!result.model || result.fragId === undefined) {\n      // some non-model geometry was hit\n      if (result.object instanceof THREE.Mesh) {\n        // if it was a mesh, try to snap to it\n        this.meshSnapping(face, result.object);\n      }\n    } else {\n      var fragIds;\n\n      if (result.fragId.length === undefined) {\n        fragIds = [result.fragId];\n      } else {\n        fragIds = result.fragId;\n      }\n\n      // This is for Fusion model with topology data\n      _snapResult.hasTopology = result.model.hasTopology();\n      if (_snapResult.hasTopology) {\n        this.snapping3DwithTopology(face, fragIds, result.model);\n      } else {\n        this.snapping3DtoMesh(face, fragIds, result.model);\n      }\n    }\n  };\n\n\n  /**\n   * Returns a function that sets a vertex (Vector3 or LmvVector3) to the data read from a vertex buffer at idx\n   * Signature: func(idx, vertex) -> vertex\n   *            if vertex is null/undefined, a new THREE.Vector3 is created\n   *\n   * @param {BufferGeometry} geometry - the geometry of mesh\n   *\n   * @private\n   */\n\n  this.makeReadVertexFunc = function (geometry) {\n    const attributes = geometry.attributes;\n    let positions, stride;\n    // Get the offset to positions in the buffer. Be careful, 2D buffers\n    // don't use the 'position' attribute for positions. Reject those.\n    // meshes use vblayout for describing the buffer structure, BufferGeometry uses attributes.xx\n    let poffset;\n\n    if (geometry.vblayout) {\n      if (!geometry.vblayout.position) {\n        return function () {}; // No positions, what to do??\n      }\n      poffset = geometry.vblayout.position.offset;\n    } else if (!attributes.position) {\n      return function () {}; // No positions, what to do??\n    } else {\n      poffset = attributes.position.offset || 0;\n    }\n\n    positions = geometry.vb ? geometry.vb : geometry.attributes.position.array;\n    stride = geometry.vb ? geometry.vbstride : 3;\n\n    return function (idx, v) {\n      const p = idx * stride + poffset;\n      v = v || new THREE.Vector3();\n      v.set(\n        positions[p],\n        positions[p + 1],\n        positions[p + 2]\n      );\n      return v;\n    };\n  };\n\n  /**\n   * Snapping order is: 1st vertices, 2nd edges, 3rd and final faces.\n   *\n   * @param face\n   * @param fragIds\n   * @param model\n   * @private\n   */\n  this.snapping3DwithTopology = function (face, fragIds, model) {\n\n    // Because edge topology data may be in other fragments with same dbId, need to iterate all of them.\n    if (_snapResult.snapNode) {\n      fragIds = [];\n\n      model.getData().instanceTree.enumNodeFragments(_snapResult.snapNode, function (fragId) {\n        fragIds.push(fragId);\n      }, true);\n    }\n\n    _snapResult.geomFace = _snapResult.geomEdge = _snapResult.geomVertex = null;\n    _distanceToEdge = Number.MAX_VALUE;\n\n    for (var fi = 0; fi < fragIds.length; ++fi) {var _model$getFragmentLis, _model$getFragmentLis2;\n\n      var fragId = fragIds[fi];\n\n      const matrixWorld = new THREE.Matrix4();\n      (_model$getFragmentLis = model.getFragmentList()) === null || _model$getFragmentLis === void 0 || _model$getFragmentLis.getWorldMatrix(fragId, matrixWorld);\n      var geometry = (_model$getFragmentLis2 = model.getFragmentList()) === null || _model$getFragmentLis2 === void 0 ? void 0 : _model$getFragmentLis2.getGeometry(fragId);\n\n      var topoIndex = model.getTopoIndex(fragId);\n      var topology = model.getTopology(topoIndex);\n      var facesTopology = topology.faces;\n      var edgesTopology = topology.edges;\n\n      if (!_snapResult.geomFace) {\n        _snapResult.geomFace = this.faceSnappingWithTopology(face, geometry, facesTopology, { matrixWorld });\n\n        if (_snapResult.geomFace) {\n          _snapResult.geomFace.fragId = fragId;\n        }\n\n        var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrixWorld);\n        _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();\n      }\n\n      // Need to iterate all frags with same dbId, because when meshes are attached with each other,\n      // edge-topology data will only be on one mesh.\n      this.edgeSnappingWithTopology(_snapResult.intersectPoint, geometry, edgesTopology, { matrixWorld });\n\n    }\n\n    _snapResult.geomVertex = this.vertexSnappingWithTopology(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n    if (_snapResult.geomFace) {\n\n      // Determine which one should be drawn: face , edge or vertex\n      _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n      if ((_options.forceSnapVertices || _distanceToVertex < _snapResult.radius) && _snapResult.geomVertex) {\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      if ((_options.forceSnapEdges || _distanceToEdge < _snapResult.radius) && _snapResult.geomEdge) {\n\n        var center = this.edgeIsCircle(_snapResult.geomEdge);\n        if (center) {\n          _snapResult.circularArcCenter = center;\n          _snapResult.circularArcRadius = center.distanceTo(_snapResult.geomEdge.vertices[0]);\n          _snapResult.geomEdge.center = _snapResult.circularArcCenter;\n          _snapResult.geomEdge.radius = _snapResult.circularArcRadius;\n          _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n        } else\n        if (this.edgeIsCurved(_snapResult.geomEdge)) {\n          _snapResult.geomType = SnapType.SNAP_CURVEDEDGE;\n        } else\n        {\n          _snapResult.geomType = SnapType.SNAP_EDGE;\n        }\n\n      } else\n      {\n\n        if (this.faceIsCurved(_snapResult.geomFace)) {\n          _snapResult.geomType = SnapType.SNAP_CURVEDFACE;\n        } else\n        {\n          _snapResult.geomType = SnapType.SNAP_FACE;\n        }\n\n      }\n\n      _isSnapped = true;\n    }\n  };\n\n  this.meshSnapping = function (face, _ref) {let { geometry, matrixWorld } = _ref;\n\n    // Handle 3D line geometry\n    const isLine = geometry.isLines || geometry.isWideLines;\n    if (isLine && face) {\n\n      // For line meshes, face is a line {a, b} instead of a Face3 instance (see lineRayCast(..) in VBIntersector.js,\n      // where a, b are vertex indices into the line mesh vertex array.\n      //\n      // Note: Unlike edge intersection for faces, we just use the line segment itself and don't search for topology\n      //       of connected line segments to identify polylines as one item. If we need this, we have to add the corresponding code first.\n      _snapResult.geomEdge = this.extractLineGeometry(face, geometry);\n      _snapResult.geomEdge.applyMatrix4(matrixWorld);\n\n      _snapResult.geomVertex = this.vertexSnapping(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n      _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n      // Determine which one should be drawn: edge or vertex\n      if (_options.forceSnapVertices || _distanceToVertex < _snapResult.radius) {\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      {\n        // Note: Since we got the edge as hit result, we can already assume the intersection to be close to the line.\n        _snapResult.geomType = SnapType.SNAP_EDGE;\n      }\n\n      _isSnapped = true;\n      return true;\n    }\n\n    // Note that face may also be a line {a, b} (see lineRayCast(..) in VBIntersector.js\n    if (face instanceof THREE.Face3) {\n      _snapResult.geomFace = this.faceSnapping(face, geometry);\n    }\n\n    if (!_snapResult.geomFace)\n    return false;\n\n    _snapResult.geomFace.applyMatrix4(matrixWorld);\n    _snapResult.geomEdge = this.edgeSnapping(_snapResult.geomFace, _snapResult.intersectPoint);\n    _snapResult.geomVertex = this.vertexSnapping(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n    var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrixWorld);\n    _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();\n\n    _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n    // Determine which one should be drawn: face, edge or vertex\n    if (_options.forceSnapVertices || _distanceToVertex < _snapResult.radius) {\n      _snapResult.geomType = SnapType.SNAP_VERTEX;\n    } else\n    if (_options.forceSnapEdges || _distanceToEdge < _snapResult.radius) {\n      _snapResult.geomType = SnapType.SNAP_EDGE;\n    } else\n    {\n      _snapResult.geomType = SnapType.SNAP_FACE;\n    }\n\n    _isSnapped = true;\n    return true;\n  };\n\n  this.snapping3DtoMesh = function (face, fragIds, model) {\n    for (var fi = 0; fi < fragIds.length; ++fi) {\n\n      var fragId = fragIds[fi];\n\n\n      const geometry = model.getFragmentList().getGeometry(fragId);\n      const matrixWorld = new THREE.Matrix4();\n      model.getFragmentList().getWorldMatrix(fragId, matrixWorld);\n\n      if (this.meshSnapping(face, { geometry, matrixWorld })) {\n        break;\n      }\n    }\n  };\n\n  this.faceSnappingWithTopology = function (face, geometry, facesTopology, _ref2) {let { matrixWorld } = _ref2;\n\n    var vA = new THREE.Vector3();\n    var vB = new THREE.Vector3();\n    var vC = new THREE.Vector3();\n\n    const geom = new THREE.Geometry();\n    const vertices = [];\n\n    if (geometry.index !== undefined) {\n\n      // Find the index of face topology list which includes the intersect face(triangle)\n      for (var i = 0; i < facesTopology.length; i++) {\n\n        var indexList = facesTopology[i].indexList;\n        var faceId = facesTopology[i].id;\n        let j = 0;\n        for (; j < indexList.length; j += 3) {\n\n          if (face.a === indexList[j]) {\n            if (face.b === indexList[j + 1] && face.c === indexList[j + 2] || face.b === indexList[j + 2] && face.c === indexList[j + 1]) {\n              break;\n            }\n          } else\n          if (face.a === indexList[j + 1]) {\n            if (face.b === indexList[j] && face.c === indexList[j + 2] || face.b === indexList[j + 2] && face.c === indexList[j]) {\n              break;\n            }\n          } else\n          if (face.a === indexList[j + 2]) {\n            if (face.b === indexList[j] && face.c === indexList[j + 1] || face.b === indexList[j + 1] && face.c === indexList[j]) {\n              break;\n            }\n          }\n        }\n\n        if (j < indexList.length) {\n          break;\n        }\n      }\n\n      if (i < facesTopology.length) {\n\n        const readVertex = this.makeReadVertexFunc(geometry);\n\n        for (let j = 0; j < indexList.length; j += 3) {\n          readVertex(indexList[j], vA);\n          readVertex(indexList[j + 1], vB);\n          readVertex(indexList[j + 2], vC);\n\n          const vIndex = vertices.length;\n          geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n          vertices.push(vA.clone());\n          vertices.push(vB.clone());\n          vertices.push(vC.clone());\n        }\n        geom.vertices = vertices;\n\n      }\n    }\n\n    if (vertices.length > 0) {\n\n      geom.faceId = faceId;\n      geom.applyMatrix4(matrixWorld);\n      return geom;\n    } else\n    {\n\n      return null;\n    }\n\n  };\n\n  /**\n   * Find the closest face next to the cast ray\n   *\n   * @param {THREE.Face3} face - the intersect triangle of Hit Test.\n   * @param {BufferGeometry} geometry - the geometry of mesh\n   *\n   * @private\n   */\n  this.faceSnapping = function (face, geometry) {\n\n    var vA = new THREE.Vector3();\n    var vB = new THREE.Vector3();\n    var vC = new THREE.Vector3();\n\n    const geom = new THREE.Geometry(); //Geometry which includes all the triangles on the same plane.\n\n    let indices;\n    // @todo: .ib might not be there as expected, e.g., the section tool seems to create incomplete/non-conforming geometries.\n    indices = geometry.index && (geometry.index.array || geometry.ib);\n\n    var offsets = geometry.groups;\n\n    if (!offsets || offsets.length === 0) {\n\n      let positions;\n      // @todo: .vb might not be there as expected, e.g., the section tool seems to create incomplete/non-conforming geometries.\n      positions = geometry.vb ?? geometry.attributes.position.array;\n      offsets = [{ start: 0, count: indices ? indices.length : positions.length, index: 0 }];\n    }\n\n    const readVertex = this.makeReadVertexFunc(geometry);\n\n    const va = readVertex(face.a);\n\n    for (var oi = 0; oi < offsets.length; ++oi) {\n\n      var start = offsets[oi].start;\n      var count = offsets[oi].count;\n      var index = 0;\n      index = offsets[oi].index;\n\n      for (var i = start; i < start + count; i += 3) {\n\n        var a = index + (indices ? indices[i] : i);\n        var b = index + (indices ? indices[i + 1] : i + 1);\n        var c = index + (indices ? indices[i + 2] : i + 2);\n\n        readVertex(a, vA);\n        readVertex(b, vB);\n        readVertex(c, vC);\n\n        var faceNormal = new THREE.Vector3();\n        THREE.Triangle.getNormal(vA, vB, vC, faceNormal);\n\n        if (isEqualVectorsWithPrecision(faceNormal, face.normal) && isEqualWithPrecision(faceNormal.dot(vA), face.normal.dot(va)))\n        {\n\n          const vIndex = geom.vertices.length;\n          geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n          geom.vertices.push(vA.clone());\n          geom.vertices.push(vB.clone());\n          geom.vertices.push(vC.clone());\n        }\n      }\n    }\n\n    if (geom.vertices.length > 0) {\n\n      return this.getTrianglesOnSameFace(geom, face, readVertex);\n    } else\n    {\n\n      return null;\n    }\n  };\n\n  /**\n   * Find triangles on the same face with the triangle intersected with the cast ray\n   *\n   * @param geom -Geometry which includes all the triangles on the same plane.\n   * @param face -Triangle which intersects with the cast ray.\n   * @param readVertexCB -Accessor function to read vertex data (see makeReadVertexFunc)\n   *\n   * @private\n   */\n  this.getTrianglesOnSameFace = function (geom, face, readVertexCB) {\n    const vertices = geom.vertices;\n\n    const faceVertex1 = readVertexCB(face.a);\n    const faceVertex2 = readVertexCB(face.b);\n    const faceVertex3 = readVertexCB(face.c);\n\n    const intersectFace = new THREE.Geometry();\n\n    const precisionPoints = 5; // number of decimal points, eg. 4 for epsilon of 0.0001\n    const precision = Math.pow(10, precisionPoints);\n\n    // Build triangle list\n    // Each triangle will contain a list of its 3 edges\n    // Also maintain an edge map, pointing to the triangles indices that contain it\n    const trianglesArr = [];\n    const edgesMap = {};\n    let firstTriangle = -1; // Will point to index of passed face parameter\n    for (let i = 0; i < vertices.length; i += 3) {\n      // for each triangle\n      const vA = vertices[i];\n      const vB = vertices[i + 1];\n      const vC = vertices[i + 2];\n\n      if (firstTriangle < 0 && faceVertex1.equals(vA) && faceVertex2.equals(vB) && faceVertex3.equals(vC)) {\n        firstTriangle = i / 3;\n      }\n\n      const keys = [\n      Math.round(vA.x * precision) + '_' + Math.round(vA.y * precision) + '_' + Math.round(vA.z * precision),\n      Math.round(vB.x * precision) + '_' + Math.round(vB.y * precision) + '_' + Math.round(vB.z * precision),\n      Math.round(vC.x * precision) + '_' + Math.round(vC.y * precision) + '_' + Math.round(vC.z * precision)];\n\n      const triangle = { edges: [] };\n\n      // Edge map update\n      for (let j = 0; j < 3; j++) {\n        const key1 = keys[j];\n        const key2 = keys[(j + 1) % 3];\n\n        const defaultEdge = key1 + '_' + key2;\n        let edge = edgesMap[defaultEdge] || edgesMap[key2 + '_' + key1];\n        if (!edge) {\n          // If this edge hasn't been added before, add it now\n          edge = edgesMap[defaultEdge] = { triangles: [] };\n        }\n\n        // Add edge to current triangle\n        triangle.edges.push(edge);\n        // Add current triangle to edge\n        edge.triangles.push(i / 3);\n      }\n\n      trianglesArr.push(triangle);\n    }\n\n    if (firstTriangle < 0) {\n      return null;\n    }\n\n    // BFS search for neighbouring triangles\n    const queue = [firstTriangle];\n    const visited = new Set();\n    const connectedFaces = [];\n\n    while (queue.length > 0) {\n      const currentFace = queue.shift();\n\n      if (visited.has(currentFace)) {\n        continue;\n      }\n\n      visited.add(currentFace);\n\n      // Add this face to the list of connected faces\n      connectedFaces.push(currentFace);\n\n      // Add all neighboring faces to the queue\n      const triangle = trianglesArr[currentFace];\n      for (const edge of triangle.edges) {\n        edge.triangles.forEach((t) => t !== currentFace && queue.push(t));\n      }\n    }\n\n    // Copy results of the actual vertices in the connected faces\n    // Since vertices are already cloned in faceSnapping, there's no need to clone them again\n    const finalVertices = [];\n    let vIndex = 0;\n    connectedFaces.forEach((faceIdx) => {\n      intersectFace.faces.push(new THREE.Face3(vIndex++, vIndex++, vIndex++));\n      finalVertices.push(vertices[faceIdx * 3]);\n      finalVertices.push(vertices[faceIdx * 3 + 1]);\n      finalVertices.push(vertices[faceIdx * 3 + 2]);\n    });\n\n    intersectFace.vertices = finalVertices;\n\n    return intersectFace;\n  };\n\n  this.edgeSnappingWithTopology = function (intersectPoint, geometry, edgesTopology, _ref3) {let { matrixWorld } = _ref3;\n\n    const edgeGeom = new THREE.Geometry(); //Geometry which includes all the triangles on the same plane.\n    var minDistTopoIndex;\n    var minDist = Number.MAX_VALUE;\n\n    var vA = new THREE.Vector3();\n    var vB = new THREE.Vector3();\n\n    if (geometry.index !== undefined && edgesTopology != undefined) {\n\n      const readVertex = this.makeReadVertexFunc(geometry);\n      // Find the index of edge topology list which includes the nearest edge segment to the intersect point\n      for (var i = 0; i < edgesTopology.length; i++) {\n\n        var indexList = edgesTopology[i].indexList;\n        // In edges topology index list the type is LineStrip\n        for (var j = 0; j < indexList.length - 1; j++) {\n          readVertex(indexList[j], vA);\n          readVertex(indexList[j + 1], vB);\n\n          vA.applyMatrix4(matrixWorld);\n          vB.applyMatrix4(matrixWorld);\n\n          var dist = distancePointToLine(intersectPoint, vA, vB);\n          if (dist < minDist) {\n            minDist = dist;\n            minDistTopoIndex = i;\n          }\n        }\n      }\n\n      if (minDistTopoIndex) {\n        indexList = edgesTopology[minDistTopoIndex].indexList;\n        for (var k = 0; k < indexList.length - 1; k++) {\n          const vK0 = readVertex(indexList[k]);\n          const vK1 = readVertex(indexList[k + 1]);\n\n          edgeGeom.vertices.push(vK0);\n          // To make the line's type to LinePieces which is used by drawLine function\n          edgeGeom.vertices.push(vK1);\n        }\n      }\n    }\n\n    if (_distanceToEdge >= minDist && edgeGeom.vertices.length > 0) {\n\n      _distanceToEdge = minDist;\n      edgeGeom.applyMatrix4(matrixWorld);\n      _snapResult.geomEdge = edgeGeom;\n    }\n  };\n\n  /**\n   * Get Edge geometry for the case that the hittest result contained a 3D lines. For this case, we have no Face3, so\n   * that faceSnapping and edgeSnapping don't work.\n   *\n   *  @param {Object}         edge     - {a, b} with vertex indices a,b of lineStart/lineEnd vertex\n   *  @param {GeometryBuffer} geometry\n   *  @returns {THREE.Geometry|THREE.BufferGeometry} Geometry with simple line\n   */\n  this.extractLineGeometry = function (edge, geometry) {\n\n    const readVertex = this.makeReadVertexFunc(geometry);\n    const va = readVertex(edge.a);\n    const vb = readVertex(edge.b);\n\n    const edgeGeom = new THREE.Geometry();\n    edgeGeom.vertices.push(va, vb);\n    return edgeGeom;\n  };\n\n  /**\n   * Find the closest edge next to the intersect point\n   *\n   * @param face -Face which is found by faceSnapping.\n   * @param intersectPoint -IntersectPoint between cast ray and face.\n   *\n   * @private\n   */\n  this.edgeSnapping = function (face, intersectPoint) {\n\n    const vertices = [];\n    const verticesLength = face.vertices.length;\n    var isEdge_12 = true;\n    var isEdge_13 = true;\n    var isEdge_23 = true;\n\n    for (var i = 0; i < verticesLength; i += 3) {\n      const pi0 = face.vertices[i];\n      const pi1 = face.vertices[i + 1];\n      const pi2 = face.vertices[i + 2];\n\n      for (var j = 0; j < verticesLength; j += 3) {\n        if (i !== j) {\n          const pj0 = face.vertices[j];\n          const pj1 = face.vertices[j + 1];\n          const pj2 = face.vertices[j + 2];\n          // Check edge 12\n          if ((pi0.equals(pj0) || pi0.equals(pj1) || pi0.equals(pj2)) && (\n          pi1.equals(pj0) || pi1.equals(pj1) || pi1.equals(pj2))) {\n            isEdge_12 = false;\n          }\n          // Check edge 13\n          // Check edge 12\n          if ((pi0.equals(pj0) || pi0.equals(pj1) || pi0.equals(pj2)) && (\n          pi2.equals(pj0) || pi2.equals(pj1) || pi2.equals(pj2))) {\n            isEdge_13 = false;\n          }\n          // Check edge 23\n          // Check edge 12\n          if ((pi1.equals(pj0) || pi1.equals(pj1) || pi1.equals(pj2)) && (\n          pi2.equals(pj0) || pi2.equals(pj1) || pi2.equals(pj2))) {\n            isEdge_23 = false;\n          }\n        }\n      }\n\n      if (isEdge_12) {\n        vertices.push(pi0.clone());\n        vertices.push(pi1.clone());\n      }\n      if (isEdge_13) {\n        vertices.push(pi0.clone());\n        vertices.push(pi2.clone());\n      }\n      if (isEdge_23) {\n        vertices.push(pi1.clone());\n        vertices.push(pi2.clone());\n      }\n\n      isEdge_12 = true;\n      isEdge_13 = true;\n      isEdge_23 = true;\n\n    }\n\n    //return lineGeom;\n\n    const edgeVertices = [];\n    const edgeGeom = new THREE.Geometry();\n    var minDistIndex;\n    var minDist = Number.MAX_VALUE;\n\n    for (var k = 0; k < vertices.length; k += 2) {\n\n      var dist = distancePointToLine(intersectPoint, vertices[k], vertices[k + 1]);\n\n      if (dist < minDist) {\n        minDist = dist;\n        minDistIndex = k;\n      }\n\n    }\n\n    edgeVertices.push(vertices[minDistIndex].clone());\n    edgeVertices.push(vertices[minDistIndex + 1].clone());\n\n    const lineGeom = new THREE.Geometry();\n    lineGeom.vertices = vertices;\n    edgeGeom.vertices = this.getConnectedLineSegmentsOnSameLine(lineGeom, edgeVertices);\n\n    _distanceToEdge = minDist;\n\n    return edgeGeom;\n  };\n\n  this.getConnectedLineSegmentsOnSameLine = function (lineGeom, edgeVertices) {\n\n    const vertices = lineGeom.vertices.slice();\n    var va = edgeVertices[0];\n    var vb = edgeVertices[1];\n\n    var vCount = [];\n\n    do {\n\n      vCount = [];\n\n      for (var j = 0; j < vertices.length; j += 2) {\n\n        // The line which has min distance to intersection point\n        if (vertices[j].equals(va) && vertices[j + 1].equals(vb)) {\n\n          continue;\n        }\n\n        for (var k = 0; k < edgeVertices.length; k += 2) {\n\n          // The line segments which are connected on the same line\n          if (vertices[j].equals(edgeVertices[k]) || vertices[j + 1].equals(edgeVertices[k]) ||\n          vertices[j].equals(edgeVertices[k + 1]) || vertices[j + 1].equals(edgeVertices[k + 1])) {\n\n            var V0 = new THREE.Vector3();\n            var V1 = new THREE.Vector3();\n\n            V0.subVectors(edgeVertices[k], edgeVertices[k + 1]);\n            V0.normalize();\n            V1.subVectors(vertices[j], vertices[j + 1]);\n            V1.normalize();\n\n            //if (V0.equals(V1) || V0.equals(V1.negate())) {\n            if (isEqualVectorsWithPrecision(V0, V1) || isInverseVectorsWithPrecision(V0, V1))\n            {\n\n              vCount.push(j);\n              break;\n\n            }\n          }\n        }\n      }\n\n      for (var ci = vCount.length - 1; ci >= 0; --ci) {\n\n        edgeVertices.push(vertices[vCount[ci]]);\n        edgeVertices.push(vertices[vCount[ci] + 1]);\n        vertices.splice(vCount[ci], 2);\n      }\n\n    } while (vCount.length > 0);\n\n    return edgeVertices;\n\n  };\n\n  this.vertexSnappingWithTopology = function (edge, intersectPoint) {\n\n    var minDist = Number.MAX_VALUE;\n    var point = new THREE.Vector3();\n    if (!edge) {\n      return point;\n    }\n\n    if (edge.vertices.length > 1) {\n      const start = edge.vertices[0];\n      const end = edge.vertices[edge.vertices.length - 1];\n      var dist1 = intersectPoint.distanceTo(start);\n      var dist2 = intersectPoint.distanceTo(end);\n\n      if (dist1 <= dist2) {\n        minDist = dist1;\n        point = start.clone();\n      } else\n      {\n        minDist = dist2;\n        point = end.clone();\n      }\n    }\n\n    _distanceToVertex = minDist;\n\n    return point;\n  };\n\n  /**\n   * Find the closest vertex next to the intersect point\n   *\n   * @param edge -Edge which is found by edgeSnapping.\n   * @param intersectPoint -IntersectPoint between cast ray and face.\n   *\n   * @private\n   */\n  this.vertexSnapping = function (edge, intersectPoint) {\n\n    var minDist = Number.MAX_VALUE;\n    var point = new THREE.Vector3();\n    const verticesLength = edge.vertices.length;\n\n    for (let i = 0; i < verticesLength; ++i) {\n      const pt = edge.vertices[i];\n      const dist = intersectPoint.distanceTo(pt);\n\n      if (dist < minDist - SNAP_PRECISION) {\n\n        minDist = dist;\n        point = pt.clone();\n\n      }\n    }\n\n    _distanceToVertex = minDist;\n\n    return point;\n  };\n\n  // This is only a workaround to detect if an edge is circle\n  this.edgeIsCircle = function (edge) {\n\n    const vertices = edge.vertices;\n\n    // Exclude squares and regular polygons\n    if (vertices.length < 8) {\n      return false;\n    }\n\n    const start = vertices[0];\n    const end = vertices[vertices.length - 1];\n\n    if (start.equals(end)) {\n\n      var center = new THREE.Vector3(0, 0, 0);\n      for (let i = 0; i < vertices.length; i += 2) {\n        center.add(vertices[i]);\n      }\n      center.divideScalar(vertices.length / 2.0);\n\n      var radius = center.distanceTo(start);\n      for (let i = 0; i < vertices.length; i += 2) {\n        if (Math.abs(center.distanceTo(vertices[i]) - radius) <= SNAP_PRECISION) {\n          continue;\n        } else\n        {\n          return false;\n        }\n      }\n      return center;\n    } else\n    {\n      return false;\n    }\n  };\n\n  this.edgeIsCurved = function (edge) {\n\n    const vertices = edge.vertices;\n    const start = vertices[0];\n    const end = vertices[vertices.length - 1];\n\n    if (vertices.length <= 2) {\n      return false;\n    } else\n    if (start.equals(end)) {\n      return true;\n    } else\n    {\n      var V1 = new THREE.Vector3();\n      let pi0;\n      let pi1 = vertices[1];\n\n      V1.subVectors(start, pi1);\n\n      var V2 = new THREE.Vector3();\n      for (var i = 2; i < vertices.length; i += 2) {\n        pi0 = vertices[i];\n        pi1 = vertices[i + i];\n        V2.subVectors(pi0, pi1);\n        if (!isEqualVectorsWithPrecision(V1, V2)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  };\n\n  /**\n   * Checks if the given geometry is curved\n   * @param {THREE.BufferGeometry} face The geometry\n   * @returns {boolean} True if the any of the faces composing the geometry is curved\n   */\n  this.faceIsCurved = function (face) {\n\n    const vertices = face.vertices;\n    const faces = face.faces;\n\n    if (faces.length <= 1) {return false;}\n\n    var fN1 = new THREE.Vector3();\n    const vA1 = vertices[faces[0].a];\n    THREE.Triangle.getNormal(vertices[faces[0].a], vertices[faces[0].b], vertices[faces[0].c], fN1);\n\n    var fN2 = new THREE.Vector3();\n    for (let i = 1; i < faces.length; i++) {\n      const vA2 = vertices[faces[i].a];\n      THREE.Triangle.getNormal(vertices[faces[i].a], vertices[faces[i].b], vertices[faces[i].c], fN2);\n      if (!isEqualVectorsWithPrecision(fN1, fN2) || !isEqualWithPrecision(fN1.dot(vA1), fN2.dot(vA2))) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  this.angleVector2 = function (vector) {\n\n    if (vector.x > 0 && vector.y >= 0) {\n      return Math.atan(vector.y / vector.x);\n    } else\n    if (vector.x >= 0 && vector.y < 0) {\n      return Math.atan(vector.y / vector.x) + Math.PI * 2;\n    } else\n    if (vector.x < 0 && vector.y <= 0) {\n      return Math.atan(vector.y / vector.x) + Math.PI;\n    } else\n    if (vector.x <= 0 && vector.y > 0) {\n      return Math.atan(vector.y / vector.x) + Math.PI;\n    } else\n    {// x = 0, y = 0\n      return null;\n    }\n  };\n\n  // Creates a THREE.Geometry that represents an approximation of a given elliptical arc in {z=0} plane.\n  // Points are obtained by by uniform sampling of a given elliptical arc.\n  //  @param {number} numPoints - The length number of points that the output geometry will contain. segments in which we subdivide the arc. Resulting point count is numSegments+1.\n  // See getEllipseArcPoint() for param details.\n  const createEllipticalArcGeometry = (cx, cy, rx, ry, startAngle, endAngle, numPoints) => {\n    let geometry = new THREE.Geometry();\n    for (let i = 0; i < numPoints; i++) {\n      const p = new THREE.Vector3(0, 0, 0);\n      const t = i / (numPoints - 1);\n      Autodesk.Extensions.CompGeom.getEllipseArcPoint(t, cx, cy, rx, ry, startAngle, endAngle, 0.0, p);\n      geometry.vertices.push(p);\n    }\n    return geometry;\n  };\n\n  /**\n   * @param {Viewer3D} viewer - Viewer instance\n   * @param snapper\n   * @param aDetectRadius\n   * @private\n   */\n  function GeometryCallback(viewer, snapper, aDetectRadius) {\n    this.viewer = viewer;\n    this.snapper = snapper;\n\n    this.lineGeom = new THREE.Geometry();\n    this.circularArc = null;\n    this.circularArcCenter;\n    this.circularArcRadius;\n    this.ellipticalArc = null;\n    this.ellipticalArcCenter;\n\n    this.minDist = Number.MAX_VALUE;\n\n    this.matrix = new THREE.Matrix4();\n\n    this.vpIdLine = null;\n    this.vpIdCircular = null;\n    this.vpIdElliptical = null;\n\n    this.detectRadius = aDetectRadius;\n\n    // Collects candidate segments that we can snap to.\n    // This is used to allow snapping to segment intersections.\n    this.snapCandidates = []; // {SnappingCandidate[]}\n  }\n\n  GeometryCallback.prototype.onLineSegment = function (x1, y1, x2, y2, vpId) {\n    var intersectPoint = this.snapper.getIntersectPoint();\n    var v1 = new THREE.Vector3(x1, y1, intersectPoint.z);\n    var v2 = new THREE.Vector3(x2, y2, intersectPoint.z);\n\n    // LMV-5515: Apply the supplied matrix to the line vector's\n    if (this.matrix) {\n      v1.applyMatrix4(this.matrix);\n      v2.applyMatrix4(this.matrix);\n    }\n\n    // Skip segments outside detectRadius\n    var dist = distancePointToLine(intersectPoint, v1, v2);\n    if (dist > this.detectRadius) {\n      return;\n    }\n\n    // Collect snap candidate\n    this.snapCandidates.push(new SnapCandidate(vpId, dist).fromLine(v1, v2));\n\n    // Track minDist and lineGeometry for best hit so far\n    if (dist < this.minDist) {\n      this.lineGeom.vertices.splice(0, 2, v1, v2);\n      this.minDist = dist;\n\n      this.vpIdLine = vpId;\n    }\n  };\n\n  GeometryCallback.prototype.onCircularArc = function (cx, cy, start, end, radius, vpId) {\n    var intersectPoint = this.snapper.getIntersectPoint();\n    var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);\n\n    var center = new THREE.Vector2(cx, cy);\n    point.sub(center);\n\n    // Compute closest point on arc\n    const pointOnArc = (0,_SnapMath_js__WEBPACK_IMPORTED_MODULE_1__.nearestPointOnCircularArc)(intersectPoint, center, radius, start, end);\n    const dist = pointOnArc.distanceTo(intersectPoint); // 2D distance\n\n    // Collect snap candidate\n    this.snapCandidates.push(new SnapCandidate(vpId, dist).fromCircularArc(center, radius, start, end));\n\n    // Skip arcs outside detectRadius\n    if (dist > this.detectRadius) {\n      return;\n    }\n\n    // TODO: get rid of the CircleGeometry stuff below, because we computed the snapPoint above already.\n    //       But this needs some refactoring, because the Geometry is passed around outside of snapper.\n\n    var angle = this.snapper.angleVector2(point);\n\n    let arc;\n    if (end > start && angle >= start && angle <= end) {\n      arc = new THREE.CircleGeometry(radius, 100, start, end - start);\n    } else\n    if (end < start && (angle >= start || angle <= end)) {\n      arc = new THREE.CircleGeometry(radius, 100, start, Math.PI * 2 - start + end);\n    } else\n    {\n      return;\n    }\n\n    arc.vertices.splice(0, 1);\n\n    arc.applyMatrix4(new THREE.Matrix4().makeTranslation(cx, cy, intersectPoint.z));\n    this.circularArc = arc;\n    this.circularArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);\n    this.circularArcRadius = radius;\n\n    this.snapPoint = new THREE.Vector3(pointOnArc.x, pointOnArc.y, intersectPoint.z);\n\n    this.vpIdCircular = vpId;\n  };\n\n  GeometryCallback.prototype.onEllipticalArc = function (cx, cy, start, end, major, minor, tilt, vpId) {\n    var intersectPoint = this.snapper.getIntersectPoint();\n    var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);\n\n    var major1 = major - this.detectRadius;\n    var minor1 = minor - this.detectRadius;\n    var major2 = major + this.detectRadius;\n    var minor2 = minor + this.detectRadius;\n\n    var equation1 = (point.x - cx) * (point.x - cx) / (major1 * major1) + (point.y - cy) * (point.y - cy) / (minor1 * minor1);\n    var equation2 = (point.x - cx) * (point.x - cx) / (major2 * major2) + (point.y - cy) * (point.y - cy) / (minor2 * minor2);\n\n    var center = new THREE.Vector2(cx, cy);\n    point.sub(center);\n    point.x *= minor;\n    point.y *= major;\n    var angle = this.snapper.angleVector2(point);\n\n    if (end > Math.PI * 2) {\n      end = Math.PI * 2;\n    }\n\n    if (equation1 >= 1 && equation2 <= 1) {\n\n      if (end > start && angle >= start && angle <= end || end < start && (angle >= start || angle <= end)) {\n        var arc = createEllipticalArcGeometry(cx, cy, major, minor, start, end, 50);\n        if (!isEqualWithPrecision(end - start, Math.PI * 2))\n        {\n          arc.vertices.pop();\n        }\n        arc.applyMatrix4(new THREE.Matrix4().makeTranslation(0, 0, intersectPoint.z));\n\n        // Compute distance between geometry and snapped point.\n        // We use the same way here as in getSnapResultPosition(). This will be replaced later by a more accurate solution.\n        const nearestPoint = MeasureCommon.nearestVertexInVertexToEdge(intersectPoint, arc);\n        const dist = THREE.Vector2.prototype.distanceTo.call(nearestPoint, intersectPoint); // only in x/y\n\n        // Collect snap candidate\n        const center = new THREE.Vector2(cx, cy);\n        this.snapCandidates.push(new SnapCandidate(vpId, dist).makeEllipticalArc(center, major, minor, start, end));\n\n        // Todo: Unlike for line-segments, arcs are currently collected by \"last one wins\" rule by the code for single-snapping.\n        //       We should consider the distance here as well.\n        this.ellipticalArc = arc;\n        this.ellipticalArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);\n\n        this.vpIdElliptical = vpId;\n      }\n    }\n  };\n\n  /**\n   * This method sets the matrix to identity if matrix is not supplied;\n   *\n   * @param {THREE.Matrix4} matrix - Matrix to set\n   */\n  GeometryCallback.prototype.setMatrix = function (matrix) {\n    this.matrix = matrix || new THREE.Matrix4();\n  };\n\n  /**\n   * Snap to a 2D model.\n   *\n   * @param {object}      hitResult - a result of a ray intersection.\n   * @param {object}      [options] - Options object.\n   * @param {Function}    [options.enumSegments] - Enumerates all segments within a given bbox in model-space.\n   *\n   */\n  this.snapping2D = function (hitResult) {let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!hitResult) {\n      return;\n    }\n\n    // hitResult is a result of a ray intersection. it may contain the following:\n    let {\n      dbId,\n      fragId,\n      intersectPoint,\n      model = _viewer.model\n    } = hitResult;\n\n    if (model.is3d()) {\n      return;\n    }\n    _snapResult.modelId = hitResult.model ? hitResult.model.id : null;\n    _snapResult.hasTopology = false;\n    _snapResult.intersectPoint = intersectPoint;\n\n    let tr,scale = 1;\n\n    // The model that we are trying to snap is 2D, but the viewer is 3D. It means that we are in hypermodeling scenario!\n    // For that, we'll need to apply the inversed transform of the 2D model to the intersect point first, in order to get it in local model coords.\n    if (!_viewer.impl.is2d) {\n      tr = model.getModelToViewerTransform();\n      // If there's a transform, move point to original location in sheet (will be restored at the end)\n      if (tr) {\n        scale = tr.getMaxScaleOnAxis();\n        _snapResult.intersectPoint = intersectPoint.clone();\n        _snapResult.intersectPoint.applyMatrix4(model.getInverseModelToViewerTransform());\n      }\n    }\n\n    // Determine which one should be drawn: line, circular arc or elliptical arc\n    // Use the un-transformed point, but scale down the radius because we are comparing with the unscaled geometry\n    _snapResult.radius = this.setDetectRadius(intersectPoint) / scale;\n\n    // Geometry snapping is only possible if a fragment list is available to obtain geometry per fragment.\n    var supportsGeomSnapping = model.getFragmentList() != null;\n    if (!supportsGeomSnapping) {\n\n      // If no snapping is available, just accept the hitpoint as a vertex hit. This allows to measure\n      // distances between arbitrary points in rasters.\n      _isSnapped = true;\n      _snapResult.geomType = SnapType.SNAP_VERTEX;\n      _snapResult.geomVertex = intersectPoint; // Use the un-transformed point\n      tr && _snapResult.intersectPoint.applyMatrix4(tr); // Restore to original location\n      return;\n    }\n\n\n    var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n\n    // Performs 2D snapping to segments based on an enumSegments() callback, which enumerates all segments\n    // within in a given bbox in model-space.\n    if (options.enumSegments) {\n      // enum all segments within the snapRadius around intersectPoint\n      const minx = _snapResult.intersectPoint.x - _snapResult.radius;\n      const miny = _snapResult.intersectPoint.y - _snapResult.radius;\n      const maxx = _snapResult.intersectPoint.x + _snapResult.radius;\n      const maxy = _snapResult.intersectPoint.y + _snapResult.radius;\n\n      options.enumSegments(minx, miny, maxx, maxy, gc);\n    } else {\n      // Regular snapping - snap to the 2D model's geometry.\n      var fragIds = fragId;\n\n      if (typeof fragIds === \"undefined\") {\n        // LMV-6082 Do not return out if the snap to pixel flag (free measure) is enabled.\n        if (!_snapToPixel) {\n          return;\n        }\n        fragIds = [];\n      } else if (!Array.isArray(fragIds)) {\n        fragIds = [fragIds];\n      }\n\n      for (var fi = 0; fi < fragIds.length; ++fi) {\n        const mesh = _viewer.impl.getRenderProxy(model, fragIds[fi]);\n        if (mesh !== null && mesh !== void 0 && mesh.geometry) {\n          gc.setMatrix(mesh.matrix);\n          const vbr = new VertexBufferReader(mesh.geometry);\n          vbr.enumGeomsForObject(model.reverseMapDbIdFor2D(dbId), gc);\n          // Set the matrix back to identity after processing a mesh\n          gc.setMatrix();\n        }\n      }\n    }\n\n    // _snapResult.intersectPoint contains the possibly transformed point\n    this.finishSnapping2D(gc, _snapResult.intersectPoint);\n\n    // Snap the unsnapped point only if the snapping fails\n    if (!_isSnapped && _snapToPixel) {\n      _isSnapped = true;\n      _snapResult.geomType = SnapType.RASTER_PIXEL;\n      _snapResult.geomVertex = _snapResult.intersectPoint;\n    }\n\n    // Now apply the transform matrix on the results, so we'll get the results in their final transformed position.\n    if (tr) {var _snapResult$geomEdge, _snapResult$geomEdge2;\n      const start = (_snapResult$geomEdge = _snapResult.geomEdge) === null || _snapResult$geomEdge === void 0 ? void 0 : _snapResult$geomEdge.vertices[0];\n      const end = (_snapResult$geomEdge2 = _snapResult.geomEdge) === null || _snapResult$geomEdge2 === void 0 ? void 0 : _snapResult$geomEdge2.vertices[1];\n\n      let results = [_snapResult.snapPoint, _snapResult.geomVertex, _snapResult.intersectPoint, _snapResult.circularArcCenter,\n      start, end];\n      // Remove undefined and possibly shared vectors\n      results = [...new Set(results.filter((n) => n))];\n      results.forEach((res) => res.applyMatrix4(tr));\n      if (_snapResult.circularArcRadius) {\n        _snapResult.circularArcRadius *= scale;\n      }\n      _snapResult.radius *= scale;\n    }\n  };\n\n  // By default, snapper only considers model geometry that is written to ID buffer.\n  // This function performs the 2D snapping on a set of given 2D meshes instead. It works similar to snapping2D() but\n  // enumerates the given meshes instead of getting them from the fragment list.\n  //\n  //  @param {THREE.Vector3}                 intersectPoint - click position in world-coords\n  //  @param {function(dbId, layerId, vpId)} filter - Defines subset of primitives to be considered.\n  //  @param {THREE.Mesh[]}                  meshes - The triangulated 2D shapes to be checked for snapping\n  //  @param {number}                        [detectRadius] - Same coordinate system as the given geometry. Required if geometry is not in world-coords.\n\n  this.snapping2DOverlay = function (intersectPoint, meshes, filter, detectRadius) {\n    _snapResult.hasTopology = false;\n    _snapResult.intersectPoint = intersectPoint;\n    _snapResult.radius = detectRadius || this.setDetectRadius(intersectPoint);\n\n    var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n\n    for (var i = 0; i < meshes.length; i++) {\n      var mesh = meshes[i];\n      var vbr = new VertexBufferReader(mesh.geometry);\n      vbr.enumGeoms(filter, gc);\n    }\n\n    this.finishSnapping2D(gc, intersectPoint);\n  };\n\n  // Finish 2D snapping operation - assuming that all candidate geometry for snapping has been processed by the geometryCallback gc already.\n  this.finishSnapping2D = function (gc, intersectPoint) {\n\n    // When restricting to a single viewport, exclude candidates of all other viewports\n    if (_forcedVpId !== null) {\n      const isSameViewport = (c) => c.viewportId === _forcedVpId;\n      gc.snapCandidates = gc.snapCandidates.filter(isSameViewport);\n    }\n\n    // Check if we can snap to an intersection of two close segments\n    const intersectSnap = findIntersectionSnap(gc.snapCandidates, intersectPoint, gc.detectRadius);\n    if (intersectSnap) {\n      _snapResult.viewportIndex2d = intersectSnap.viewportId;\n      _snapResult.snapPoint = intersectSnap.snapPoint;\n      _snapResult.geomType = SnapType.SNAP_INTERSECTION;\n      _snapResult.geomVertex = intersectSnap.snapPoint;\n      _isSnapped = true;\n      return;\n    }\n\n    if (gc.circularArc) {\n\n      _snapResult.viewportIndex2d = gc.vpIdCircular;\n\n      _snapResult.snapPoint = gc.snapPoint;\n\n      // Only snap the geometries which belong to the same viewport as the first selection\n      if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n      return;\n\n      const start = gc.circularArc.vertices[0];\n      const end = gc.circularArc.vertices[gc.circularArc.vertices.length - 1];\n\n      if (intersectPoint.distanceTo(start) < _snapResult.radius) {\n\n        _snapResult.geomVertex = start;\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      if (intersectPoint.distanceTo(end) < _snapResult.radius) {\n\n        _snapResult.geomVertex = end;\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      {\n\n        this.lineStripToPieces(gc.circularArc);\n        _snapResult.geomEdge = gc.circularArc;\n        _snapResult.circularArcCenter = gc.circularArcCenter;\n        _snapResult.circularArcRadius = gc.circularArcRadius;\n        _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n      }\n\n      _isSnapped = true;\n\n\n    } else\n    if (gc.ellipticalArc) {\n\n      _snapResult.viewportIndex2d = gc.vpIdElliptical;\n\n      // Only snap the geometries which belong to the same viewport as the first selection\n      if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n      return;\n\n      const start = gc.ellipticalArc.vertices[0];\n      const end = gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1];\n      if (intersectPoint.distanceTo(start) < _snapResult.radius) {\n\n        _snapResult.geomVertex = start;\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      if (intersectPoint.distanceTo(end) < _snapResult.radius) {\n\n        _snapResult.geomVertex = end;\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      {\n\n        this.lineStripToPieces(gc.ellipticalArc);\n        _snapResult.geomEdge = gc.ellipticalArc;\n        // Before we have measure design for elliptical arc, measure the center for now\n        _snapResult.circularArcCenter = gc.ellipticalArcCenter;\n        _snapResult.circularArcRadius = null;\n        _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n      }\n\n      _isSnapped = true;\n\n    } else\n    if (gc.lineGeom instanceof THREE.Geometry && gc.lineGeom.vertices.length ||\n    gc.lineGeom.getAttribute && gc.lineGeom.getAttribute('position').count) {\n\n      _snapResult.viewportIndex2d = gc.vpIdLine;\n\n      // Only snap the geometries which belong to the same viewport as the first selection\n      if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n      return;\n\n      // Always expose edge segment - no matter whether we snap to the edge or one of its vertices.\n      // This allows us to combine it with other snap constraints later - as done by Edit2D.\n      _snapResult.geomEdge = gc.lineGeom;\n      const start = gc.lineGeom.vertices[0];\n      const end = gc.lineGeom.vertices[1];\n\n      if (this.markupMode) {// Markup mode\n        var mid = new THREE.Vector3();\n        mid.addVectors(start, end);\n        mid.divideScalar(2);\n        var md = intersectPoint.distanceTo(mid);\n        var sd = intersectPoint.distanceTo(start);\n        var ed = intersectPoint.distanceTo(end);\n\n        // Store it for snapping to parallel/perpendicular of underlying vectors\n        _snapResult.geomEdge = gc.lineGeom;\n\n        if (md < _snapResult.radius) {\n          _snapResult.geomVertex = mid;\n          _snapResult.geomType = SnapType.SNAP_VERTEX;\n        } else\n        if (sd < _snapResult.radius) {\n          _snapResult.geomVertex = start;\n          _snapResult.geomType = SnapType.SNAP_VERTEX;\n        } else\n        if (ed < _snapResult.radius) {\n          _snapResult.geomVertex = end;\n          _snapResult.geomType = SnapType.SNAP_VERTEX;\n        } else\n        {\n          _snapResult.geomType = SnapType.SNAP_EDGE;\n        }\n\n        // Circle center\n        if (start.distanceTo(end) < EPSILON) {\n          _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;\n        }\n      } else\n      {// Measure mode\n        if (intersectPoint.distanceTo(start) < _snapResult.radius) {\n\n          if (start.distanceTo(end) < EPSILON) {\n            _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;\n          } else {\n            _snapResult.geomType = SnapType.SNAP_VERTEX;\n          }\n\n          _snapResult.geomVertex = start;\n        } else\n        if (_options.forceSnapVertices || intersectPoint.distanceTo(end) < _snapResult.radius) {\n\n          _snapResult.geomVertex = end;\n          _snapResult.geomType = SnapType.SNAP_VERTEX;\n        } else\n        {\n          _snapResult.geomType = SnapType.SNAP_EDGE;\n        }\n      }\n\n      _isSnapped = true;\n    }\n  };\n\n  this.snappingRasterPixel = function (result) {\n    if (!result) {\n      return;\n    }\n\n    var intersectPoint = result.intersectPoint;\n    _snapResult.intersectPoint = intersectPoint;\n    _snapResult.hasTopology = false;\n\n    // Determine which one should be drawn: line, circular arc or elliptical arc\n    _snapResult.radius = this.setDetectRadius(intersectPoint);\n    _snapResult.geomType = SnapType.RASTER_PIXEL;\n    _snapResult.geomVertex = intersectPoint;\n    _isSnapped = true;\n  };\n\n  this.snapMidpoint = function () {\n    _snapResult.isMidpoint = false;\n\n    // Snap midpoint for edge\n    if (_isSnapped) {\n      if (_snapResult.geomType === SnapType.SNAP_EDGE) {\n        const edge = _snapResult.geomEdge;\n        const p1 = edge.vertices[0];\n        const p2 = edge.vertices[1];\n\n        var midpoint = new THREE.Vector3((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, (p1.z + p2.z) / 2);\n\n        var cutPlanes = _viewer.impl.getAllCutPlanes();\n        if (cutPlanes !== null && cutPlanes !== void 0 && cutPlanes.length) {\n          for (let i = 0; i < cutPlanes.length; ++i) {\n            const p = cutPlanes[i];\n            const dot = midpoint.x * p.x + midpoint.y * p.y + midpoint.z * p.z + p.w;\n            if (dot > 1e-5) {\n              // discard midpoint if clipped\n              return;\n            }\n          }\n        }\n\n        if (_snapResult.intersectPoint.distanceTo(midpoint) < 2 * _snapResult.radius) {\n          _snapResult.geomVertex = midpoint;\n          _snapResult.geomType = SnapType.SNAP_MIDPOINT;\n        }\n      }\n    }\n  };\n\n  this.setPerpendicular = function (isPerpendicular) {\n    _snapResult.isPerpendicular = isPerpendicular;\n  };\n\n  this.lineStripToPieces = function (geom) {\n    const vertices = geom.vertices;\n    for (var i = vertices.length - 2; i > 0; i--) {\n      vertices.splice(i, 0, vertices[i]);\n    }\n  };\n\n  this.setDetectRadius = function (point) {\n\n    var navapi = _viewer.navigation;\n    var camera = navapi.getCamera();\n    var position = navapi.getPosition();\n\n    var p = point.clone();\n\n    var distance = camera.isPerspective ? p.sub(position).length() :\n    navapi.getEyeVector().length();\n\n    var fov = navapi.getVerticalFov();\n    var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));\n\n    var viewport = navapi.getScreenViewport();\n    var _window = this.getWindow();\n    var devicePixelRatio = _window.devicePixelRatio || 1;\n    var radius = this.detectRadiusInPixels * worldHeight / (viewport.height * devicePixelRatio);\n\n    return radius;\n  };\n\n  this.handleButtonDown = function () {\n    _isDragging = true;\n    return false;\n  };\n\n  this.handleButtonUp = function () {\n    _isDragging = false;\n    return false;\n  };\n\n  this.handleMouseMove = function (event) {\n\n    if (_isDragging)\n    return false;\n\n    this.onMouseMove({\n      x: event.canvasX,\n      y: event.canvasY\n    });\n\n    return false;\n  };\n\n  this.handleSingleTap = function (event) {\n\n    return this.handleMouseMove(event);\n  };\n\n  this.handlePressHold = function (event) {\n\n    if (av.isMobileDevice()) {\n      switch (event.type) {\n\n        case \"press\":\n          _isPressing = true;\n          this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n          break;\n\n        case \"pressup\":\n          this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n          _isPressing = false;\n          break;\n      }\n    }\n    return false;\n\n  };\n\n  this.handleGesture = function (event)\n  {\n    if (av.isMobileDevice()) {\n      if (_isPressing) {\n        switch (event.type) {\n\n          case \"dragstart\":\n          case \"dragmove\":\n            this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n            break;\n\n          case \"dragend\":\n            this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n            _isPressing = false;\n            break;\n\n          case \"pinchstart\":\n          case \"pinchmove\":\n          case \"pinchend\":\n            break;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  /**\n   * Handler to mouse move events, used to snap in markup edit mode.\n   *\n   * @param mousePosition\n   * @private\n   */\n  this.onMouseDown = function (mousePosition) {\n    return this.onMouseMove(mousePosition);\n  };\n\n  /**\n   * Handler to mouse move events, used to snap in markup edit mode.\n   *\n   * @param mousePosition\n   * @private\n   */\n  this.onMouseMove = function (mousePosition) {var _result$model, _viewer$model;\n\n    this.clearSnapped();\n\n    var result = _viewer.impl.snappingHitTest(mousePosition.x, mousePosition.y, false);\n\n    if (!result && _snapToPixel) {\n      var vpVec = _viewer.impl.clientToViewport(mousePosition.x, mousePosition.y);\n      let point = _viewer.impl.intersectGroundViewport(vpVec);\n      result = { intersectPoint: point };\n    }\n\n    if (!result || !result.intersectPoint)\n    return false;\n\n    const isLeaflet = ((_result$model = result.model) === null || _result$model === void 0 ? void 0 : _result$model.isLeaflet()) || _viewer.impl.is2d && ((_viewer$model = _viewer.model) === null || _viewer$model === void 0 ? void 0 : _viewer$model.isLeaflet());\n    // 3D Snapping\n    if (result.face) {\n      this.snapping3D(result);\n    }\n    // 2D Snapping\n    else if ((result.dbId || result.dbId === 0) && !isLeaflet) {\n      this.snapping2D(result);\n    }\n    // Pixel Snapping\n    else {\n      const isPixelSnap = _snapToPixel || isLeaflet;\n      if (isPixelSnap) {\n        this.snappingRasterPixel(result);\n      }\n    }\n\n    this.snapMidpoint();\n\n    if (_snapFilter && !_snapFilter(_snapResult)) {\n      this.clearSnapped();\n      return false;\n    }\n\n    return true;\n  };\n}\n\nav.GlobalManagerMixin.call(Snapper.prototype);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFDM0I7SUFDQTtJQUFBLEtBQ0s7TUFDRCxNQUFNNFksV0FBVyxHQUFHN1csWUFBWSxJQUFJNFcsU0FBUztNQUM3QyxJQUFJQyxXQUFXLEVBQUU7UUFDYixJQUFJLENBQUMvQyxtQkFBbUIsQ0FBQzdWLE1BQU0sQ0FBQztNQUNwQztJQUNKOztJQUVBLElBQUksQ0FBQzhWLFlBQVksQ0FBQyxDQUFDOztJQUVuQixJQUFJOVQsV0FBVyxJQUFJLENBQUNBLFdBQVcsQ0FBQ25CLFdBQVcsQ0FBQyxFQUFFO01BQzFDLElBQUksQ0FBQzhDLFlBQVksQ0FBQyxDQUFDO01BQ25CLE9BQU8sS0FBSztJQUNoQjs7SUFFQSxPQUFPLElBQUk7RUFDZixDQUFDO0FBQ0w7O0FBRUFsSSxFQUFFLENBQUNvZCxrQkFBa0IsQ0FBQ3BZLElBQUksQ0FBQ0MsT0FBTyxDQUFDRixTQUFTLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdXRvZGVzay5FeHRlbnNpb25zLy4vZXh0ZW5zaW9ucy9TbmFwcGluZy9TbmFwcGVyLmpzPzkxYzciXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyBOdWxsU25hcHBlckluZGljYXRvciwgU25hcHBlckluZGljYXRvciB9IGZyb20gXCIuL1NuYXBwZXJJbmRpY2F0b3IuanNcIjtcbmltcG9ydCB7IG5lYXJlc3RQb2ludE9uQ2lyY3VsYXJBcmMsIGludGVyc2VjdExpbmVzIH0gZnJvbSBcIi4vU25hcE1hdGguanNcIjtcblxuY29uc3QgTWVhc3VyZUNvbW1vbiA9IEF1dG9kZXNrLlZpZXdpbmcuTWVhc3VyZUNvbW1vbjtcbmNvbnN0IEVQU0lMT04gPSBNZWFzdXJlQ29tbW9uLkVQU0lMT047XG5jb25zdCBTbmFwVHlwZSA9IE1lYXN1cmVDb21tb24uU25hcFR5cGU7XG5jb25zdCBTbmFwUmVzdWx0ID0gTWVhc3VyZUNvbW1vbi5TbmFwUmVzdWx0O1xuXG52YXIgU05BUF9QUkVDSVNJT04gPSAwLjAwMTtcblxuY29uc3QgYXYgPSBBdXRvZGVzay5WaWV3aW5nO1xuY29uc3QgYXZwID0gYXYuUHJpdmF0ZTtcbmNvbnN0IFZlcnRleEJ1ZmZlclJlYWRlciA9IGF2cC5WZXJ0ZXhCdWZmZXJSZWFkZXI7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGEgLSBGaXJzdCB2YWx1ZSB0byBjb21wYXJlXG4gKiBAcGFyYW0ge251bWJlcn0gYiAtIFNlY29uZCB2YWx1ZSB0byBjb21wYXJlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0VxdWFsV2l0aFByZWNpc2lvbihhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSBTTkFQX1BSRUNJU0lPTjtcbn1cblxuLyoqXG4gKiBBcmUgdGhlIHZlY3RvcnMgZXF1YWwgd2l0aGluIFNOQVBfUFJFQ0lTSU9OP1xuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSB2MSAtIHZlY3RvclxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSB2MiAtIHZlY3RvclxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSB3aGVuIHRoZXkgYXJlIGVxdWFsXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0VxdWFsVmVjdG9yc1dpdGhQcmVjaXNpb24odjEsIHYyKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHYxLnggLSB2Mi54KSA8PSBTTkFQX1BSRUNJU0lPTlxuICAgICAgICAmJiBNYXRoLmFicyh2MS55IC0gdjIueSkgPD0gU05BUF9QUkVDSVNJT05cbiAgICAgICAgJiYgTWF0aC5hYnModjEueiAtIHYyLnopIDw9IFNOQVBfUFJFQ0lTSU9OO1xufVxuXG4vKipcbiAqIEFyZSB0aGUgdmVjdG9ycyBpbnZlcnNlIG9mIGVhY2ggb3RoZXIgd2l0aGluIFNOQVBfUFJFQ0lTSU9OP1xuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSB2MSAtIHZlY3RvclxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSB2MiAtIHZlY3RvclxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSB3aGVuIHRoZXkgYXJlIGludmVyc2Ugb2YgZWFjaCBvdGhlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNJbnZlcnNlVmVjdG9yc1dpdGhQcmVjaXNpb24odjEsIHYyKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHYxLnggKyB2Mi54KSA8PSBTTkFQX1BSRUNJU0lPTlxuICAgICAgICAmJiBNYXRoLmFicyh2MS55ICsgdjIueSkgPD0gU05BUF9QUkVDSVNJT05cbiAgICAgICAgJiYgTWF0aC5hYnModjEueiArIHYyLnopIDw9IFNOQVBfUFJFQ0lTSU9OO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gcG9pbnQgLSBQb2ludFxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBsaW5lU3RhcnQgLSBTdGFydCBvZiB0aGUgbGluZVxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBsaW5lRW5kIC0gRW5kIG9mIHRoZSBsaW5lXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIGRpc3RhbmNlIGZyb20gcG9pbnQgdG8gdGhlIGxpbmVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlUG9pbnRUb0xpbmUocG9pbnQsIGxpbmVTdGFydCwgbGluZUVuZCkge1xuXG4gICAgaWYgKGxpbmVTdGFydC5lcXVhbHMobGluZUVuZCkpIHsgLy8gRGVnZW5lcmF0ZSBsaW5lXG4gICAgICAgIHJldHVybiBwb2ludC5kaXN0YW5jZVRvKGxpbmVTdGFydCk7XG4gICAgfVxuXG4gICAgdmFyIFgwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgWDEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBkaXN0YW5jZTtcbiAgICB2YXIgcGFyYW07XG5cbiAgICBYMC5zdWJWZWN0b3JzKGxpbmVTdGFydCwgcG9pbnQpO1xuICAgIFgxLnN1YlZlY3RvcnMobGluZUVuZCwgbGluZVN0YXJ0KTtcbiAgICBwYXJhbSA9IFgwLmRvdChYMSk7XG4gICAgWDAuc3ViVmVjdG9ycyhsaW5lRW5kLCBsaW5lU3RhcnQpO1xuICAgIHBhcmFtID0gLXBhcmFtIC8gWDAuZG90KFgwKTtcblxuICAgIGlmIChwYXJhbSA8IDApIHtcbiAgICAgICAgZGlzdGFuY2UgPSBwb2ludC5kaXN0YW5jZVRvKGxpbmVTdGFydCk7XG4gICAgfSBlbHNlIGlmIChwYXJhbSA+IDEpIHtcbiAgICAgICAgZGlzdGFuY2UgPSBwb2ludC5kaXN0YW5jZVRvKGxpbmVFbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFgwLnN1YlZlY3RvcnMocG9pbnQsIGxpbmVTdGFydCk7XG4gICAgICAgIFgxLnN1YlZlY3RvcnMocG9pbnQsIGxpbmVFbmQpO1xuICAgICAgICBYMC5jcm9zcyhYMSk7XG4gICAgICAgIFgxLnN1YlZlY3RvcnMobGluZUVuZCwgbGluZVN0YXJ0KTtcblxuICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChYMC5kb3QoWDApKSAvIE1hdGguc3FydChYMS5kb3QoWDEpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlzdGFuY2U7XG59XG5cbmNvbnN0IFNuYXBDYW5kaWRhdGVUeXBlID0ge1xuICAgIFVua25vd246ICAgICAgIDAsXG4gICAgTGluZTogICAgICAgICAgMSxcbiAgICBDaXJjdWxhckFyYzogICAyLFxuICAgIEVsbGlwdGljYWxBcmM6IDNcbn07XG5cbi8vIEEgU25hcENhbmRpZGF0ZSByZWZlcmVuY2VzIGEgc2luZ2xlIHNlZ21lbnQgKGxpbmUgb3IgYXJjKSB0aGF0IHdlIGNvdWxkIHNuYXAgdG8uXG5jbGFzcyBTbmFwQ2FuZGlkYXRlIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3cG9ydElkKSB7XG5cbiAgICAgICAgdGhpcy50eXBlID0gU25hcENhbmRpZGF0ZVR5cGUuVW5rbm93bjtcbiAgICAgICAgdGhpcy52aWV3cG9ydElkID0gdmlld3BvcnRJZDtcblxuICAgICAgICAvLyAyZCBkaXN0YW5jZSBiZXR3ZWVuIG9yaWdpbmFsICh1bnNuYXBwZWQpIHBvc2l0aW9uIGFuZCB0aGUgZ2VvbWV0cnkgb2YgdGhpcyBjYW5kaWRhdGUuXG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSAwO1xuXG4gICAgICAgIC8vIHtWZWN0b3IyfSBTdGFydC9FbmRwb2ludCAtIG9ubHkgZm9yIGxpbmUgc2VnbWVudHNcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLmxpbmVFbmQgICA9IG51bGw7XG5cbiAgICAgICAgLy8gRml4ZWQgcmFkaXVzIC0gb25seSBmb3IgQ2lyY3VsYXJBcmNzXG4gICAgICAgIHRoaXMucmFkaXVzID0gMDtcblxuICAgICAgICAvLyBTZXBhcmF0ZSByYWRpaSAtIG9ubHkgZm9yIGVsbGlwc2UgYXJjc1xuICAgICAgICB0aGlzLnJhZGl1c1ggPSAwOyAvLyA9IG1ham9yIHJhZGl1cyAtIGJ5IGNvbnZlbnRpb25cbiAgICAgICAgdGhpcy5yYWRpdXNZID0gMDtcblxuICAgICAgICAvLyBDZW50ZXIgcG9pbnQgYXMgVmVjdG9yMiAoZm9yIGFyY3MpXG4gICAgICAgIHRoaXMuY2VudGVyID0gbnVsbDtcblxuICAgICAgICAvLyBTdGFydC9lbmQgYW5nbGUgZm9yIGFyY3M6IENjdyBhbmdsZSBpbiByYWRpYW5zLiBBbmdsZSAwIGNvcnJlc3BvbmRzIHRvIGRpcmVjdGlvbiB4Ky5cbiAgICAgICAgdGhpcy5zdGFydEFuZ2xlID0gMDtcbiAgICAgICAgdGhpcy5lbmRBbmdsZSAgID0gMDtcbiAgICB9XG5cbiAgICBmcm9tTGluZShwMSwgcDIpIHtcbiAgICAgICAgdGhpcy50eXBlID0gU25hcENhbmRpZGF0ZVR5cGUuTGluZTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSBwMS5jbG9uZSgpO1xuICAgICAgICB0aGlzLmxpbmVFbmQgICA9IHAyLmNsb25lKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZyb21DaXJjdWxhckFyYyhjZW50ZXIsIHJhZGl1cywgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnR5cGUgICA9IFNuYXBDYW5kaWRhdGVUeXBlLkNpcmN1bGFyQXJjO1xuICAgICAgICB0aGlzLmNlbnRlciA9IGNlbnRlci5jbG9uZSgpO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgICAgICAgdGhpcy5zdGFydCAgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgICAgPSBlbmQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZyb21FbGxpcHRpY2FsQXJjKGNlbnRlciwgcmFkaXVzWCwgcmFkaXVzWSwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnR5cGUgPSBTbmFwQ2FuZGlkYXRlVHlwZS5FbGxpcHRpY2FsQXJjO1xuICAgICAgICB0aGlzLmNlbnRlciA9IGNlbnRlci5jbG9uZSgpO1xuICAgICAgICB0aGlzLnJhZGl1c1ggPSByYWRpdXNYO1xuICAgICAgICB0aGlzLnJhZGl1c1kgPSByYWRpdXNZO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpc0xpbmUoKSAgICAgICAgICB7IHJldHVybiB0aGlzLnR5cGUgPT09IFNuYXBDYW5kaWRhdGVUeXBlLkxpbmU7IH1cbiAgICBpc0NpcmN1bGFyQXJjKCkgICB7IHJldHVybiB0aGlzLnR5cGUgPT09IFNuYXBDYW5kaWRhdGVUeXBlLkNpcnVsYXJBcmM7IH1cbiAgICBpc0VsbGlwdGljYWxBcmMoKSB7IHJldHVybiB0aGlzLnR5cGUgPT09IFNuYXBDYW5kaWRhdGVUeXBlLkVsbGlwdGljYWxBcmM7IH1cblxuICAgIC8vIENoZWNrcyBpZiB0aGUgc25hcEdlb21ldHJ5IG9mIHRoaXMgY2FuZGlkYXRlIGludGVyc2VjdHMgd2l0aCBhbm90aGVyIG9uZS5cbiAgICAvLyAgQHBhcmFtIHtTbmFwQ2FuZGlkYXRlfSBvdGhlclxuICAgIC8vICBAcGFyYW0ge1ZlY3RvcjJ9IFtvcHRpb25hbFRhcmdldF1cbiAgICAvLyAgQHJldHVybnMge1RIUkVFLlZlY3RvcjJ8bnVsbH0gUmV0dXJucyBpbnRlcnNlY3Rpb24gcG9pbnQgaWYgdGhlcmUgaXMgb25lLlxuICAgIGdldEludGVyc2VjdGlvbihvdGhlciwgb3B0aW9uYWxUYXJnZXQpIHtcblxuICAgICAgICBpZiAodGhpcy5pc0xpbmUoKSAmJiBvdGhlci5pc0xpbmUoKSkge1xuICAgICAgICAgICAgLy8gTm90ZTogV2UgZG8gdGhlIGludGVyc2VjdGlvbnMgb24gdGhlIHdob2xlIGxpbmUgLSBub3QganVzdCB0aGUgaW50ZXJzZWN0aW9ucy5cbiAgICAgICAgICAgIC8vIFJlYXNvbiBpczpcbiAgICAgICAgICAgIC8vICBhKSBPdGhlcndpc2UsIGl0IHdvdWxkIG5vdCBzbmFwIGlmIHlvdSBhcmUgc2xpZ2h0bHkgb3V0bGluZSBvZiBvbmUgbGluZSBzZWdtZW50XG4gICAgICAgICAgICAvLyAgYikgQnkgZGVmaW5pdGlvbiwgd2UgZ2V0IG9ubHkgdmVyeSBjbG9zZSBzZWdtZW50IGNhbmRpZGF0ZXMgYW55d2F5XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0TGluZXModGhpcy5saW5lU3RhcnQsIHRoaXMubGluZUVuZCwgb3RoZXIubGluZVN0YXJ0LCBvdGhlci5saW5lRW5kLCBmYWxzZSwgb3B0aW9uYWxUYXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogQ3VycmVudGx5LCB3ZSBvbmx5IHN1cHBvcnQgc25hcHBpbmcgdG8gbGluZS1saW5lIGludGVyc2VjdGlvbnNcbiAgICB9XG59XG5cbi8vIENoZWNrcyBpZiB3ZSBjYW4gc25hcCB0byBhbiBpbnRlcnNlY3Rpb24gb2YgdHdvIGNsb3NlIHNlZ21lbnRzIChlYWNoIGNhbiBiZSBhIGxpbmUgb3IgYXJjcykuXG4vLyAgQHBhcmFtIHtTbmFwQ2FuZGlkYXRlW119IGNhbmRpZGF0ZXMgICAgIC0gU25hcCBjYW5kaWRhdGUgZ2VvbWV0cmllcyBjb2xsZWN0ZWQgaW4gR2VvbWV0cnlDYWxsYmFjay4gQXNzdW1lZCB0byBiZSB3aXRoaW4gc25hcFJhZGl1cy5cbi8vICBAcGFyYW0ge1RSRUUuVmVjdG9yM30gICAgaW50ZXJzZWN0UG9pbnQgLSBVbnNuYXBwZWQgb3JpZ2luYWwgcG9zaXRpb25cbi8vICBAcGFyYW0ge251bWJlcn0gICAgICAgICAgc25hcFJhZGl1c1xuLy8gIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gSWYgYW4gaW50ZXJzZWN0aW9uIHNuYXAgaXMgZm91bmQsIHRoZSByZXN1bHQgY29udGFpbnM6XG4vLyAgICAgICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydElkICAvLyBudW1iZXJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgc25hcFBvaW50ICAgLy8gKFRIUkVFLlZlY3RvcjMpXG4vLyAgICAgICAgICAgICAgICAgICAgfVxuY29uc3QgZmluZEludGVyc2VjdGlvblNuYXAgPSAoY2FuZGlkYXRlcywgaW50ZXJzZWN0UG9pbnQsIHNuYXBSYWRpdXMpID0+IHtcblxuICAgIC8vIFNvcnQgc25hcHBpbmcgY2FuZGlkYXRlcyBieSBpbmNyZWFzaW5nIGRpc3RhbmNlXG4gICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHdlIGp1c3QgbmVlZCB0aGUgYmVzdCB0d28gb25lcy4gQnV0IHRoZSBudW1iZXIgb2YgY2FuZGlkYXRlcyB3aXRoaW4gdGhlIHNuYXBwaW5nXG4gICAgLy8gZGlzdGFuY2UgaXMgZ2VuZXJhbGx5IHNtYWxsIGFueXdheSAtIGFuZCB3b3JraW5nIHdpdGggYSBzb3J0ZWQgYXJyYXkgaXMgbW9yZSBmbGV4aWJsZSB0byBpbmNyZW1lbnRhbGx5XG4gICAgLy8gbWFrZSB0aGUgc25hcHBpbmcgc21hcnRlciBsYXRlci5cbiAgICBjb25zdCBieURpc3RhbmNlID0gKGNhLCBjYikgPT4gY2EuZGlzdGFuY2UgLSBjYi5kaXN0YW5jZTtcbiAgICBjYW5kaWRhdGVzLnNvcnQoYnlEaXN0YW5jZSk7XG5cbiAgICAvLyBTdG9wIGhlcmUgaWYgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggY2FuZGlkYXRlcyBmb3IgYW4gaW50ZXJzZWN0aW9uXG4gICAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBJbml0IHJlc3VsdCBvYmplY3RcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIC8vIEp1c3QgdXNlIHRoZSBvbmUgb2YgdGhlIGZpcnN0IGNhbmRpZGF0ZS4gVGhlcmUgaXMgbm8gdW5pcXVlIHZpZXdwb3J0SWQgd2hlbiB1c2luZyBhbiBpbnRlcnNlY3Rpb24uXG4gICAgICAgIHZpZXdwb3J0SWQ6IGNhbmRpZGF0ZXNbMF0udmlld3BvcnRJZCxcblxuICAgICAgICAvLyBTbmFwcGluZyBoYXBwZW5zIGluIDJkIC0gc28gd2Ugc2V0IHogaW4gYWR2YW5jZSBhbmQganVzdCBrZWVwIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAgICAgICAgLy8gTm90ZTogU25hcHBlciBnZW5lcmFsbHkgbmVlZHMgc29tZSByZXZpc2lvbiBpZiB3ZSB1c2UgaXQgZm9yIHBsYW5lcyB0aGF0IGFyZSBub3QgcGVycGVuZGljdWxhciB0byB0aGUgdmlld2luZyBkaXJlY3Rpb24uXG4gICAgICAgIHNuYXBQb2ludDogIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIGludGVyc2VjdFBvaW50LnopXG4gICAgfTtcblxuICAgIC8vIENoZWNrIGZvciBhbnkgY2FuZGlkYXRlIHRoYXQgaW50ZXJzZWN0cyB3aXRoIHRoZSBjbG9zZXN0IG9uZSB3ZSBmb3VuZFxuICAgIGNvbnN0IGZpcnN0ID0gY2FuZGlkYXRlc1swXTtcbiAgICBmb3IgKGxldCBpPTE7IGk8Y2FuZGlkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzZWNvbmQgPSBjYW5kaWRhdGVzW2ldO1xuXG4gICAgICAgIC8vIERvIGludGVyc2VjdGlvbiB0ZXN0LiBJZiBmb3VuZCwgd3JpdGUgaXQgdG8gcmVzdWx0LnNuYXBQb2ludFxuICAgICAgICBjb25zdCBmb3VuZCA9IGZpcnN0LmdldEludGVyc2VjdGlvbihzZWNvbmQsIHJlc3VsdC5zbmFwUG9pbnQpO1xuICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGZvdW5kIGFuIGludGVyc2VjdGlvbi4gQWx0aG91Z2ggd2UgYXNzdW1lIGFsbCBjYW5kaWRhdGVzIHRvIGJlIHdpdGhpblxuICAgICAgICAvLyBzbmFwIHJhZGl1cyBhbHJlYWR5LCB0aGUgaW50ZXJzZWN0aW9uIG1heSBzdGlsbCBiZSBzb21ld2hlcmUgZWxzZS5cbiAgICAgICAgLy8gPT4gQ2hlY2sgaWYgaW50ZXJzZWN0aW9uIGlzIHN0aWxsIHdpdGhpbiB0aGUgc25hcFJhZGl1cy5cbiAgICAgICAgY29uc3QgZGlzdCA9IFRIUkVFLlZlY3RvcjIucHJvdG90eXBlLmRpc3RhbmNlVG8uY2FsbChyZXN1bHQuc25hcFBvaW50LCBpbnRlcnNlY3RQb2ludCk7XG4gICAgICAgIGlmIChkaXN0IDwgc25hcFJhZGl1cykge1xuICAgICAgICAgICAgLy8gV2UgZm91bmQgYSB2YWxpZCBpbnRlcnNlY3Rpb24gc25hcFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBBIHRvb2wgdGhhdCBsZXRzIHVzZXJzIGF0dGFjaCBwb2ludGVyIGV2ZW50cyB0byB2ZXJ0aWNlcyBhbmQgZWRnZXMuIEl0IHN1cHBvcnRzIDJEIGFuZCAzRCBtb2RlbHMuXG4gKlxuICogQHBhcmFtIHtWaWV3ZXIzRH0gdmlld2VyIC0gVmlld2VyIGluc3RhbmNlXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb25zIGZvciB0aGUgZXh0ZW5zaW9uXG4gKiBAbWVtYmVyb2YgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLlNuYXBwaW5nXG4gKiBAYWxpYXMgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLlNuYXBwaW5nLlNuYXBwZXJcbiAqIEBjbGFzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU25hcHBlcih2aWV3ZXIsIG9wdGlvbnMpIHtcblxuICAgIHZhciBfc25hcFJlc3VsdCA9IG5ldyBTbmFwUmVzdWx0KCk7XG5cbiAgICB2YXIgX3ZpZXdlciA9IHZpZXdlcjtcbiAgICB0aGlzLnNldEdsb2JhbE1hbmFnZXIodmlld2VyLmdsb2JhbE1hbmFnZXIpO1xuXG4gICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgX25hbWVzO1xuXG4gICAgaWYgKF9vcHRpb25zLm1hcmt1cE1vZGUpIHtcbiAgICAgICAgX25hbWVzID0gW1wic25hcHBlci1tYXJrdXBcIl07XG4gICAgfSBlbHNlIGlmIChfb3B0aW9ucy50b29sTmFtZSkge1xuICAgICAgICAvLyBBbGxvdyB0b29scyB0byB1c2UgdGhlaXIgb3duIHNuYXBwZXJcbiAgICAgICAgX25hbWVzID0gW19vcHRpb25zLnRvb2xOYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfbmFtZXMgPSBbXCJzbmFwcGVyXCJdO1xuICAgIH1cblxuICAgIHZhciBfcHJpb3JpdHkgPSA2MDtcblxuICAgIHZhciBfYWN0aXZlID0gZmFsc2U7XG5cbiAgICB2YXIgX2Rpc3RhbmNlVG9FZGdlID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgX2Rpc3RhbmNlVG9WZXJ0ZXggPSBudWxsO1xuXG4gICAgdmFyIF9pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgdmFyIF9pc1ByZXNzaW5nID0gZmFsc2U7XG4gICAgdmFyIF9pc1NuYXBwZWQgPSBmYWxzZTtcblxuICAgIHZhciBfZm9yY2VkVnBJZCA9IG51bGw7IC8vIHRoZSB2aWV3cG9ydCBpbmRleCBvZiB0aGUgZmlyc3Qgc2VsZWN0aW9uIGZvciAyRFxuXG4gICAgdmFyIF9zbmFwVG9QaXhlbCA9IGZhbHNlO1xuXG4gICAgdmFyIF9zbmFwRmlsdGVyID0gbnVsbDsgLy8gT3B0aW9uYWwgc25hcHBpbmcgZmlsdGVyLCBiYXNlZCBvbiBzbmFwUmVzdWx0LiAoc25hcFJlc3VsdCkgPT4gYm9vbGVhbi5cblxuICAgIHRoaXMuaW5kaWNhdG9yID0gbmV3IFNuYXBwZXJJbmRpY2F0b3Iodmlld2VyLCB0aGlzKTtcblxuICAgIHRoaXMubWFya3VwTW9kZSA9IF9vcHRpb25zLm1hcmt1cE1vZGU7XG4gICAgdGhpcy5yZW5kZXJTbmFwcGVkR2VvbWV0cnkgPSBfb3B0aW9ucy5yZW5kZXJTbmFwcGVkR2VvbWV0cnk7XG4gICAgdGhpcy5yZW5kZXJTbmFwcGVkVG9wb2xvZ3kgPSBfb3B0aW9ucy5yZW5kZXJTbmFwcGVkVG9wb2xvZ3k7XG5cbiAgICAvL05vdGljZTogVGhlIHBpeGVsU2l6ZSBzaG91bGQgY29ycmVzcG9uZCB0byB0aGUgYW1vdW50IG9mIHBpeGVscyBwZXIgbGluZSBpbiBpZEF0UGl4ZWxzLCB0aGUgc2hhcGUgb2ZcbiAgICAvL2RldGVjdGlvbiBhcmVhIGlzIHNxdWFyZSBpbiBpZEF0UGl4ZWxzLCBidXQgY2lyY2xlIGluIHNuYXBwZXIsIHNob3VsZCBtYWtlIHRoZWlyIGFyZWFzIG1hdGNoIHJvdWdobHkuXG4gICAgdGhpcy5kZXRlY3RSYWRpdXNJblBpeGVscyA9IGF2LmlzTW9iaWxlRGV2aWNlKCkgPyA1MCA6IDEwO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgd2hlbiB0aGUgdG9vbCBpcyBhY3RpdmVcbiAgICAgKlxuICAgICAqIEBhbGlhcyBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuU25hcHBpbmcuU25hcHBlciNpc0FjdGl2ZVxuICAgICAqL1xuICAgIHRoaXMuaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9hY3RpdmU7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0TmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9uYW1lcztcbiAgICB9O1xuXG4gICAgdGhpcy5nZXROYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfbmFtZXNbMF07XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0UHJpb3JpdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9wcmlvcml0eTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIGludGVyY2VwdGluZyBwb2ludGVyIGV2ZW50cy5cbiAgICAgKiBJbnZva2VkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIHtAbGluayBUb29sQ29udHJvbGxlcn0uXG4gICAgICpcbiAgICAgKiBAYWxpYXMgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLlNuYXBwaW5nLlNuYXBwZXIjYWN0aXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIF9hY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLmluZGljYXRvci5pc051bGwoKSkge1xuICAgICAgICAgICAgdGhpcy5pbmRpY2F0b3IgPSBuZXcgU25hcHBlckluZGljYXRvcih2aWV3ZXIsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogU3RvcHMgaW50ZXJjZXB0aW5nIHBvaW50ZXIgZXZlbnRzLlxuICAgICAqIEludm9rZWQgYXV0b21hdGljYWxseSBieSB0aGUge0BsaW5rIFRvb2xDb250cm9sbGVyfS5cbiAgICAgKlxuICAgICAqIEBhbGlhcyBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuU25hcHBpbmcuU25hcHBlciNkZWFjdGl2YXRlXG4gICAgICovXG4gICAgdGhpcy5kZWFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIF9hY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXRoaXMuaW5kaWNhdG9yLmlzTnVsbCgpKSB7XG4gICAgICAgICAgICB0aGlzLmluZGljYXRvci5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmluZGljYXRvciA9IG5ldyBOdWxsU25hcHBlckluZGljYXRvcigpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuY29weVJlc3VsdHMgPSBmdW5jdGlvbihkZXN0aW55KSB7XG4gICAgICAgIF9zbmFwUmVzdWx0LmNvcHlUbyhkZXN0aW55KTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRFZGdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc25hcFJlc3VsdC5nZW9tRWRnZTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRWZXJ0ZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwUmVzdWx0Lmdlb21WZXJ0ZXg7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0R2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwUmVzdWx0LmdldEdlb21ldHJ5KCk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0R2VvbWV0cnlUeXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc25hcFJlc3VsdC5nZW9tVHlwZTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRJbnRlcnNlY3RQb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQ7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1NuYXBSZXN1bHR9IFRoZSBzbmFwcGluZyBzdGF0dXMgb2YgdGhlIGxhc3QgcG9pbnRlciBldmVudCBwZXJmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAYWxpYXMgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLlNuYXBwaW5nLlNuYXBwZXIjZ2V0U25hcFJlc3VsdFxuICAgICAqL1xuICAgIHRoaXMuZ2V0U25hcFJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NuYXBSZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSB0b29sJ3MgbGFzdCB1cGRhdGUgcmVzdWx0ZWQgb24gYSBzbmFwLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgd2hlbiB0aGUgbGFzdCBwb2ludGVyIGV2ZW50IGdvdCBzbmFwcGVkLlxuICAgICAqXG4gICAgICogQGFsaWFzIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5TbmFwcGluZy5TbmFwcGVyI2lzU25hcHBlZFxuICAgICAqL1xuICAgIHRoaXMuaXNTbmFwcGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfaXNTbmFwcGVkO1xuICAgIH07XG5cbiAgICB0aGlzLmNsZWFyU25hcHBlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBfc25hcFJlc3VsdC5jbGVhcigpO1xuICAgICAgICBfaXNTbmFwcGVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0Vmlld3BvcnRJZCA9IGZ1bmN0aW9uKHZwSWQpIHtcbiAgICAgICAgX2ZvcmNlZFZwSWQgPSB2cElkO1xuICAgIH07XG5cbiAgICB0aGlzLnNldFNuYXBUb1BpeGVsID0gZnVuY3Rpb24oZW5hYmxlKSB7XG4gICAgICAgIF9zbmFwVG9QaXhlbCA9IGVuYWJsZTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRTbmFwVG9QaXhlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NuYXBUb1BpeGVsO1xuICAgIH07XG5cbiAgICB0aGlzLnNldFNuYXBUb0FyYyA9IGZ1bmN0aW9uKGVuYWJsZSkge1xuICAgICAgICBfc25hcFJlc3VsdC5zbmFwVG9BcmMgPSBlbmFibGU7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0U25hcFRvQXJjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc25hcFJlc3VsdC5zbmFwVG9BcmM7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0QXJjID0gZnVuY3Rpb24oaXNBcmMpIHtcbiAgICAgICAgX3NuYXBSZXN1bHQuaXNBcmMgPSBpc0FyYztcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRBcmMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwUmVzdWx0LmlzQXJjO1xuICAgIH07XG5cbiAgICB0aGlzLnNldFNuYXBGaWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgIF9zbmFwRmlsdGVyID0gZmlsdGVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAzRCBTbmFwcGluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHJlc3VsdCAtUmVzdWx0IG9mIEhpdCBUZXN0LlxuICAgICAqL1xuICAgIHRoaXMuc25hcHBpbmczRCA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuXG4gICAgICAgIF9zbmFwUmVzdWx0LnNuYXBOb2RlID0gcmVzdWx0LmRiSWQ7XG4gICAgICAgIF9zbmFwUmVzdWx0LmludGVyc2VjdFBvaW50ID0gcmVzdWx0LmludGVyc2VjdFBvaW50O1xuICAgICAgICBfc25hcFJlc3VsdC5tb2RlbElkID0gcmVzdWx0Lm1vZGVsID8gcmVzdWx0Lm1vZGVsLmlkIDogbnVsbDtcblxuICAgICAgICB2YXIgZmFjZSA9IHJlc3VsdC5mYWNlO1xuXG4gICAgICAgIGlmICghcmVzdWx0Lm1vZGVsIHx8IHJlc3VsdC5mcmFnSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc29tZSBub24tbW9kZWwgZ2VvbWV0cnkgd2FzIGhpdFxuICAgICAgICAgICAgaWYgKHJlc3VsdC5vYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgd2FzIGEgbWVzaCwgdHJ5IHRvIHNuYXAgdG8gaXRcbiAgICAgICAgICAgICAgICB0aGlzLm1lc2hTbmFwcGluZyhmYWNlLCByZXN1bHQub2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmcmFnSWRzO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0LmZyYWdJZC5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZyYWdJZHMgPSBbcmVzdWx0LmZyYWdJZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyYWdJZHMgPSByZXN1bHQuZnJhZ0lkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGZvciBGdXNpb24gbW9kZWwgd2l0aCB0b3BvbG9neSBkYXRhXG4gICAgICAgICAgICBfc25hcFJlc3VsdC5oYXNUb3BvbG9neSA9IHJlc3VsdC5tb2RlbC5oYXNUb3BvbG9neSgpO1xuICAgICAgICAgICAgaWYgKF9zbmFwUmVzdWx0Lmhhc1RvcG9sb2d5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zbmFwcGluZzNEd2l0aFRvcG9sb2d5KGZhY2UsIGZyYWdJZHMsIHJlc3VsdC5tb2RlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc25hcHBpbmczRHRvTWVzaChmYWNlLCBmcmFnSWRzLCByZXN1bHQubW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgc2V0cyBhIHZlcnRleCAoVmVjdG9yMyBvciBMbXZWZWN0b3IzKSB0byB0aGUgZGF0YSByZWFkIGZyb20gYSB2ZXJ0ZXggYnVmZmVyIGF0IGlkeFxuICAgICAqIFNpZ25hdHVyZTogZnVuYyhpZHgsIHZlcnRleCkgLT4gdmVydGV4XG4gICAgICogICAgICAgICAgICBpZiB2ZXJ0ZXggaXMgbnVsbC91bmRlZmluZWQsIGEgbmV3IFRIUkVFLlZlY3RvcjMgaXMgY3JlYXRlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtCdWZmZXJHZW9tZXRyeX0gZ2VvbWV0cnkgLSB0aGUgZ2VvbWV0cnkgb2YgbWVzaFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMubWFrZVJlYWRWZXJ0ZXhGdW5jID0gZnVuY3Rpb24oZ2VvbWV0cnkpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgICAgIGxldCBwb3NpdGlvbnMsIHN0cmlkZTtcbiAgICAgICAgLy8gR2V0IHRoZSBvZmZzZXQgdG8gcG9zaXRpb25zIGluIHRoZSBidWZmZXIuIEJlIGNhcmVmdWwsIDJEIGJ1ZmZlcnNcbiAgICAgICAgLy8gZG9uJ3QgdXNlIHRoZSAncG9zaXRpb24nIGF0dHJpYnV0ZSBmb3IgcG9zaXRpb25zLiBSZWplY3QgdGhvc2UuXG4gICAgICAgIC8vIG1lc2hlcyB1c2UgdmJsYXlvdXQgZm9yIGRlc2NyaWJpbmcgdGhlIGJ1ZmZlciBzdHJ1Y3R1cmUsIEJ1ZmZlckdlb21ldHJ5IHVzZXMgYXR0cmlidXRlcy54eFxuICAgICAgICBsZXQgcG9mZnNldDtcblxuICAgICAgICBpZiAoZ2VvbWV0cnkudmJsYXlvdXQpIHtcbiAgICAgICAgICAgIGlmICghZ2VvbWV0cnkudmJsYXlvdXQucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTsgICAgIC8vIE5vIHBvc2l0aW9ucywgd2hhdCB0byBkbz8/XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2Zmc2V0ID0gZ2VvbWV0cnkudmJsYXlvdXQucG9zaXRpb24ub2Zmc2V0O1xuICAgICAgICB9IGVsc2UgaWYgKCFhdHRyaWJ1dGVzLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTsgICAgIC8vIE5vIHBvc2l0aW9ucywgd2hhdCB0byBkbz8/XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb2Zmc2V0ID0gYXR0cmlidXRlcy5wb3NpdGlvbi5vZmZzZXQgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvc2l0aW9ucyA9IGdlb21ldHJ5LnZiID8gZ2VvbWV0cnkudmIgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuICAgICAgICBzdHJpZGUgPSBnZW9tZXRyeS52YiA/IGdlb21ldHJ5LnZic3RyaWRlIDogMztcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaWR4LCB2KSB7XG4gICAgICAgICAgICBjb25zdCBwID0gaWR4ICogc3RyaWRlICsgcG9mZnNldDtcbiAgICAgICAgICAgIHYgPSB2IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICB2LnNldChcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnNbcF0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb25zW3AgKyAxXSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnNbcCArIDJdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNuYXBwaW5nIG9yZGVyIGlzOiAxc3QgdmVydGljZXMsIDJuZCBlZGdlcywgM3JkIGFuZCBmaW5hbCBmYWNlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmYWNlXG4gICAgICogQHBhcmFtIGZyYWdJZHNcbiAgICAgKiBAcGFyYW0gbW9kZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc25hcHBpbmczRHdpdGhUb3BvbG9neSA9IGZ1bmN0aW9uKGZhY2UsIGZyYWdJZHMsIG1vZGVsKSB7XG5cbiAgICAgICAgLy8gQmVjYXVzZSBlZGdlIHRvcG9sb2d5IGRhdGEgbWF5IGJlIGluIG90aGVyIGZyYWdtZW50cyB3aXRoIHNhbWUgZGJJZCwgbmVlZCB0byBpdGVyYXRlIGFsbCBvZiB0aGVtLlxuICAgICAgICBpZiAoX3NuYXBSZXN1bHQuc25hcE5vZGUpIHtcbiAgICAgICAgICAgIGZyYWdJZHMgPSBbXTtcblxuICAgICAgICAgICAgbW9kZWwuZ2V0RGF0YSgpLmluc3RhbmNlVHJlZS5lbnVtTm9kZUZyYWdtZW50cyhfc25hcFJlc3VsdC5zbmFwTm9kZSwgZnVuY3Rpb24oZnJhZ0lkKSB7XG4gICAgICAgICAgICAgICAgZnJhZ0lkcy5wdXNoKGZyYWdJZCk7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zbmFwUmVzdWx0Lmdlb21GYWNlID0gX3NuYXBSZXN1bHQuZ2VvbUVkZ2UgPSBfc25hcFJlc3VsdC5nZW9tVmVydGV4ID0gbnVsbDtcbiAgICAgICAgX2Rpc3RhbmNlVG9FZGdlID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgZnJhZ0lkcy5sZW5ndGg7ICsrZmkpIHtcblxuICAgICAgICAgICAgdmFyIGZyYWdJZCA9IGZyYWdJZHNbZmldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBtYXRyaXhXb3JsZCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgICAgICAgICBtb2RlbC5nZXRGcmFnbWVudExpc3QoKT8uZ2V0V29ybGRNYXRyaXgoZnJhZ0lkLCBtYXRyaXhXb3JsZCk7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBtb2RlbC5nZXRGcmFnbWVudExpc3QoKT8uZ2V0R2VvbWV0cnkoZnJhZ0lkKTtcblxuICAgICAgICAgICAgdmFyIHRvcG9JbmRleCA9IG1vZGVsLmdldFRvcG9JbmRleChmcmFnSWQpO1xuICAgICAgICAgICAgdmFyIHRvcG9sb2d5ID0gbW9kZWwuZ2V0VG9wb2xvZ3kodG9wb0luZGV4KTtcbiAgICAgICAgICAgIHZhciBmYWNlc1RvcG9sb2d5ID0gdG9wb2xvZ3kuZmFjZXM7XG4gICAgICAgICAgICB2YXIgZWRnZXNUb3BvbG9neSA9IHRvcG9sb2d5LmVkZ2VzO1xuXG4gICAgICAgICAgICBpZiAoIV9zbmFwUmVzdWx0Lmdlb21GYWNlKSB7XG4gICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbUZhY2UgPSB0aGlzLmZhY2VTbmFwcGluZ1dpdGhUb3BvbG9neShmYWNlLCBnZW9tZXRyeSwgZmFjZXNUb3BvbG9neSwge21hdHJpeFdvcmxkfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoX3NuYXBSZXN1bHQuZ2VvbUZhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbUZhY2UuZnJhZ0lkID0gZnJhZ0lkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeChtYXRyaXhXb3JsZCk7XG4gICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmFwcGx5TWF0cml4Myhub3JtYWxNYXRyaXgpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOZWVkIHRvIGl0ZXJhdGUgYWxsIGZyYWdzIHdpdGggc2FtZSBkYklkLCBiZWNhdXNlIHdoZW4gbWVzaGVzIGFyZSBhdHRhY2hlZCB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgICAgICAvLyBlZGdlLXRvcG9sb2d5IGRhdGEgd2lsbCBvbmx5IGJlIG9uIG9uZSBtZXNoLlxuICAgICAgICAgICAgdGhpcy5lZGdlU25hcHBpbmdXaXRoVG9wb2xvZ3koX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQsIGdlb21ldHJ5LCBlZGdlc1RvcG9sb2d5LCB7bWF0cml4V29ybGR9KTtcblxuICAgICAgICB9XG5cbiAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVZlcnRleCA9IHRoaXMudmVydGV4U25hcHBpbmdXaXRoVG9wb2xvZ3koX3NuYXBSZXN1bHQuZ2VvbUVkZ2UsIF9zbmFwUmVzdWx0LmludGVyc2VjdFBvaW50KTtcblxuICAgICAgICBpZiAoX3NuYXBSZXN1bHQuZ2VvbUZhY2UpIHtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIG9uZSBzaG91bGQgYmUgZHJhd246IGZhY2UgLCBlZGdlIG9yIHZlcnRleFxuICAgICAgICAgICAgX3NuYXBSZXN1bHQucmFkaXVzID0gdGhpcy5zZXREZXRlY3RSYWRpdXMoX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQpO1xuXG4gICAgICAgICAgICBpZiAoKF9vcHRpb25zLmZvcmNlU25hcFZlcnRpY2VzIHx8IF9kaXN0YW5jZVRvVmVydGV4IDwgX3NuYXBSZXN1bHQucmFkaXVzKSAmJiBfc25hcFJlc3VsdC5nZW9tVmVydGV4KSB7XG4gICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5TTkFQX1ZFUlRFWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChfb3B0aW9ucy5mb3JjZVNuYXBFZGdlcyB8fCBfZGlzdGFuY2VUb0VkZ2UgPCBfc25hcFJlc3VsdC5yYWRpdXMpICYmIF9zbmFwUmVzdWx0Lmdlb21FZGdlKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5lZGdlSXNDaXJjbGUoX3NuYXBSZXN1bHQuZ2VvbUVkZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChjZW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuY2lyY3VsYXJBcmNDZW50ZXIgPSBjZW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0LmNpcmN1bGFyQXJjUmFkaXVzID0gY2VudGVyLmRpc3RhbmNlVG8oX3NuYXBSZXN1bHQuZ2VvbUVkZ2UudmVydGljZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tRWRnZS5jZW50ZXIgPSBfc25hcFJlc3VsdC5jaXJjdWxhckFyY0NlbnRlcjtcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbUVkZ2UucmFkaXVzID0gX3NuYXBSZXN1bHQuY2lyY3VsYXJBcmNSYWRpdXM7XG4gICAgICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9DSVJDVUxBUkFSQztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5lZGdlSXNDdXJ2ZWQoX3NuYXBSZXN1bHQuZ2VvbUVkZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9DVVJWRURFREdFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5TTkFQX0VER0U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZhY2VJc0N1cnZlZChfc25hcFJlc3VsdC5nZW9tRmFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5TTkFQX0NVUlZFREZBQ0U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfRkFDRTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2lzU25hcHBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5tZXNoU25hcHBpbmcgPSBmdW5jdGlvbihmYWNlLCB7Z2VvbWV0cnksIG1hdHJpeFdvcmxkfSkge1xuXG4gICAgICAgIC8vIEhhbmRsZSAzRCBsaW5lIGdlb21ldHJ5XG4gICAgICAgIGNvbnN0IGlzTGluZSA9IGdlb21ldHJ5LmlzTGluZXMgfHwgZ2VvbWV0cnkuaXNXaWRlTGluZXM7XG4gICAgICAgIGlmIChpc0xpbmUgJiYgZmFjZSkge1xuXG4gICAgICAgICAgICAvLyBGb3IgbGluZSBtZXNoZXMsIGZhY2UgaXMgYSBsaW5lIHthLCBifSBpbnN0ZWFkIG9mIGEgRmFjZTMgaW5zdGFuY2UgKHNlZSBsaW5lUmF5Q2FzdCguLikgaW4gVkJJbnRlcnNlY3Rvci5qcyxcbiAgICAgICAgICAgIC8vIHdoZXJlIGEsIGIgYXJlIHZlcnRleCBpbmRpY2VzIGludG8gdGhlIGxpbmUgbWVzaCB2ZXJ0ZXggYXJyYXkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gTm90ZTogVW5saWtlIGVkZ2UgaW50ZXJzZWN0aW9uIGZvciBmYWNlcywgd2UganVzdCB1c2UgdGhlIGxpbmUgc2VnbWVudCBpdHNlbGYgYW5kIGRvbid0IHNlYXJjaCBmb3IgdG9wb2xvZ3lcbiAgICAgICAgICAgIC8vICAgICAgIG9mIGNvbm5lY3RlZCBsaW5lIHNlZ21lbnRzIHRvIGlkZW50aWZ5IHBvbHlsaW5lcyBhcyBvbmUgaXRlbS4gSWYgd2UgbmVlZCB0aGlzLCB3ZSBoYXZlIHRvIGFkZCB0aGUgY29ycmVzcG9uZGluZyBjb2RlIGZpcnN0LlxuICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbUVkZ2UgPSB0aGlzLmV4dHJhY3RMaW5lR2VvbWV0cnkoZmFjZSwgZ2VvbWV0cnkpO1xuICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbUVkZ2UuYXBwbHlNYXRyaXg0KG1hdHJpeFdvcmxkKTtcblxuICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVZlcnRleCA9IHRoaXMudmVydGV4U25hcHBpbmcoX3NuYXBSZXN1bHQuZ2VvbUVkZ2UsIF9zbmFwUmVzdWx0LmludGVyc2VjdFBvaW50KTtcblxuICAgICAgICAgICAgX3NuYXBSZXN1bHQucmFkaXVzID0gdGhpcy5zZXREZXRlY3RSYWRpdXMoX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQpO1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggb25lIHNob3VsZCBiZSBkcmF3bjogZWRnZSBvciB2ZXJ0ZXhcbiAgICAgICAgICAgIGlmICgoX29wdGlvbnMuZm9yY2VTbmFwVmVydGljZXMgfHwgKF9kaXN0YW5jZVRvVmVydGV4IDwgX3NuYXBSZXN1bHQucmFkaXVzKSkpIHtcbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfVkVSVEVYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogU2luY2Ugd2UgZ290IHRoZSBlZGdlIGFzIGhpdCByZXN1bHQsIHdlIGNhbiBhbHJlYWR5IGFzc3VtZSB0aGUgaW50ZXJzZWN0aW9uIHRvIGJlIGNsb3NlIHRvIHRoZSBsaW5lLlxuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9FREdFO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaXNTbmFwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90ZSB0aGF0IGZhY2UgbWF5IGFsc28gYmUgYSBsaW5lIHthLCBifSAoc2VlIGxpbmVSYXlDYXN0KC4uKSBpbiBWQkludGVyc2VjdG9yLmpzXG4gICAgICAgIGlmIChmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTMpIHtcbiAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21GYWNlID0gdGhpcy5mYWNlU25hcHBpbmcoZmFjZSwgZ2VvbWV0cnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFfc25hcFJlc3VsdC5nZW9tRmFjZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBfc25hcFJlc3VsdC5nZW9tRmFjZS5hcHBseU1hdHJpeDQobWF0cml4V29ybGQpO1xuICAgICAgICBfc25hcFJlc3VsdC5nZW9tRWRnZSA9IHRoaXMuZWRnZVNuYXBwaW5nKF9zbmFwUmVzdWx0Lmdlb21GYWNlLCBfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludCk7XG4gICAgICAgIF9zbmFwUmVzdWx0Lmdlb21WZXJ0ZXggPSB0aGlzLnZlcnRleFNuYXBwaW5nKF9zbmFwUmVzdWx0Lmdlb21FZGdlLCBfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludCk7XG5cbiAgICAgICAgdmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KG1hdHJpeFdvcmxkKTtcbiAgICAgICAgX3NuYXBSZXN1bHQuZmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmFwcGx5TWF0cml4Myhub3JtYWxNYXRyaXgpLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIF9zbmFwUmVzdWx0LnJhZGl1cyA9IHRoaXMuc2V0RGV0ZWN0UmFkaXVzKF9zbmFwUmVzdWx0LmludGVyc2VjdFBvaW50KTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggb25lIHNob3VsZCBiZSBkcmF3bjogZmFjZSwgZWRnZSBvciB2ZXJ0ZXhcbiAgICAgICAgaWYgKChfb3B0aW9ucy5mb3JjZVNuYXBWZXJ0aWNlcyB8fCAoX2Rpc3RhbmNlVG9WZXJ0ZXggPCBfc25hcFJlc3VsdC5yYWRpdXMpKSkge1xuICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5TTkFQX1ZFUlRFWDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfb3B0aW9ucy5mb3JjZVNuYXBFZGdlcyB8fCAoX2Rpc3RhbmNlVG9FZGdlIDwgX3NuYXBSZXN1bHQucmFkaXVzKSkge1xuICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5TTkFQX0VER0U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfRkFDRTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9pc1NuYXBwZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdGhpcy5zbmFwcGluZzNEdG9NZXNoID0gZnVuY3Rpb24oZmFjZSwgZnJhZ0lkcywgbW9kZWwpIHtcbiAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGZyYWdJZHMubGVuZ3RoOyArK2ZpKSB7XG5cbiAgICAgICAgICAgIHZhciBmcmFnSWQgPSBmcmFnSWRzW2ZpXTtcblxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG1vZGVsLmdldEZyYWdtZW50TGlzdCgpLmdldEdlb21ldHJ5KGZyYWdJZCk7XG4gICAgICAgICAgICBjb25zdCBtYXRyaXhXb3JsZCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgICAgICAgICBtb2RlbC5nZXRGcmFnbWVudExpc3QoKS5nZXRXb3JsZE1hdHJpeChmcmFnSWQsIG1hdHJpeFdvcmxkKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubWVzaFNuYXBwaW5nKGZhY2UsIHtnZW9tZXRyeSwgbWF0cml4V29ybGR9KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZmFjZVNuYXBwaW5nV2l0aFRvcG9sb2d5ID0gZnVuY3Rpb24oZmFjZSwgZ2VvbWV0cnksIGZhY2VzVG9wb2xvZ3ksIHttYXRyaXhXb3JsZH0pIHtcblxuICAgICAgICB2YXIgdkEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgdkIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgdkMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIGNvbnN0IGdlb20gPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBbXTtcblxuICAgICAgICBpZiAoZ2VvbWV0cnkuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiBmYWNlIHRvcG9sb2d5IGxpc3Qgd2hpY2ggaW5jbHVkZXMgdGhlIGludGVyc2VjdCBmYWNlKHRyaWFuZ2xlKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmYWNlc1RvcG9sb2d5Lmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhMaXN0ID0gZmFjZXNUb3BvbG9neVtpXS5pbmRleExpc3Q7XG4gICAgICAgICAgICAgICAgdmFyIGZhY2VJZCA9IGZhY2VzVG9wb2xvZ3lbaV0uaWQ7XG4gICAgICAgICAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoOyBqIDwgaW5kZXhMaXN0Lmxlbmd0aDsgaiArPSAzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZhY2UuYSA9PT0gaW5kZXhMaXN0W2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGZhY2UuYiA9PT0gaW5kZXhMaXN0W2ogKyAxXSAmJiBmYWNlLmMgPT09IGluZGV4TGlzdFtqICsgMl0pIHx8IChmYWNlLmIgPT09IGluZGV4TGlzdFtqICsgMl0gJiYgZmFjZS5jID09PSBpbmRleExpc3RbaiArIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZhY2UuYSA9PT0gaW5kZXhMaXN0W2ogKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChmYWNlLmIgPT09IGluZGV4TGlzdFtqXSAmJiBmYWNlLmMgPT09IGluZGV4TGlzdFtqICsgMl0pIHx8IChmYWNlLmIgPT09IGluZGV4TGlzdFtqICsgMl0gJiYgZmFjZS5jID09PSBpbmRleExpc3Rbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmFjZS5hID09PSBpbmRleExpc3RbaiArIDJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGZhY2UuYiA9PT0gaW5kZXhMaXN0W2pdICYmIGZhY2UuYyA9PT0gaW5kZXhMaXN0W2ogKyAxXSkgfHwgKGZhY2UuYiA9PT0gaW5kZXhMaXN0W2ogKyAxXSAmJiBmYWNlLmMgPT09IGluZGV4TGlzdFtqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChqIDwgaW5kZXhMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpIDwgZmFjZXNUb3BvbG9neS5sZW5ndGgpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRWZXJ0ZXggPSB0aGlzLm1ha2VSZWFkVmVydGV4RnVuYyhnZW9tZXRyeSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZGV4TGlzdC5sZW5ndGg7IGogKz0gMykge1xuICAgICAgICAgICAgICAgICAgICByZWFkVmVydGV4KGluZGV4TGlzdFtqXSwgdkEpO1xuICAgICAgICAgICAgICAgICAgICByZWFkVmVydGV4KGluZGV4TGlzdFtqICsgMV0sIHZCKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZFZlcnRleChpbmRleExpc3RbaiArIDJdLCB2Qyk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdkluZGV4ID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBnZW9tLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKHZJbmRleCwgdkluZGV4ICsgMSwgdkluZGV4ICsgMikpO1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHZBLmNsb25lKCkpO1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHZCLmNsb25lKCkpO1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHZDLmNsb25lKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW9tLnZlcnRpY2VzID0gdmVydGljZXM7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIGdlb20uZmFjZUlkID0gZmFjZUlkO1xuICAgICAgICAgICAgZ2VvbS5hcHBseU1hdHJpeDQobWF0cml4V29ybGQpO1xuICAgICAgICAgICAgcmV0dXJuIGdlb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgY2xvc2VzdCBmYWNlIG5leHQgdG8gdGhlIGNhc3QgcmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RIUkVFLkZhY2UzfSBmYWNlIC0gdGhlIGludGVyc2VjdCB0cmlhbmdsZSBvZiBIaXQgVGVzdC5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBnZW9tZXRyeSAtIHRoZSBnZW9tZXRyeSBvZiBtZXNoXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZmFjZVNuYXBwaW5nID0gZnVuY3Rpb24oZmFjZSwgZ2VvbWV0cnkpIHtcblxuICAgICAgICB2YXIgdkEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgdkIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgdkMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIGNvbnN0IGdlb20gPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTsgLy9HZW9tZXRyeSB3aGljaCBpbmNsdWRlcyBhbGwgdGhlIHRyaWFuZ2xlcyBvbiB0aGUgc2FtZSBwbGFuZS5cblxuICAgICAgICBsZXQgaW5kaWNlcztcbiAgICAgICAgLy8gQHRvZG86IC5pYiBtaWdodCBub3QgYmUgdGhlcmUgYXMgZXhwZWN0ZWQsIGUuZy4sIHRoZSBzZWN0aW9uIHRvb2wgc2VlbXMgdG8gY3JlYXRlIGluY29tcGxldGUvbm9uLWNvbmZvcm1pbmcgZ2VvbWV0cmllcy5cbiAgICAgICAgaW5kaWNlcyA9IGdlb21ldHJ5LmluZGV4ICYmIChnZW9tZXRyeS5pbmRleC5hcnJheSB8fCBnZW9tZXRyeS5pYik7XG5cbiAgICAgICAgdmFyIG9mZnNldHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cbiAgICAgICAgaWYgKCAhb2Zmc2V0cyB8fCBvZmZzZXRzLmxlbmd0aCA9PT0gMCkge1xuXG4gICAgICAgICAgICBsZXQgcG9zaXRpb25zO1xuICAgICAgICAgICAgLy8gQHRvZG86IC52YiBtaWdodCBub3QgYmUgdGhlcmUgYXMgZXhwZWN0ZWQsIGUuZy4sIHRoZSBzZWN0aW9uIHRvb2wgc2VlbXMgdG8gY3JlYXRlIGluY29tcGxldGUvbm9uLWNvbmZvcm1pbmcgZ2VvbWV0cmllcy5cbiAgICAgICAgICAgIHBvc2l0aW9ucyA9IGdlb21ldHJ5LnZiID8/IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG4gICAgICAgICAgICBvZmZzZXRzID0gW3sgc3RhcnQ6IDAsIGNvdW50OiBpbmRpY2VzID8gaW5kaWNlcy5sZW5ndGggOiBwb3NpdGlvbnMubGVuZ3RoLCBpbmRleDogMCB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlYWRWZXJ0ZXggPSB0aGlzLm1ha2VSZWFkVmVydGV4RnVuYyhnZW9tZXRyeSk7XG5cbiAgICAgICAgY29uc3QgdmEgPSByZWFkVmVydGV4KGZhY2UuYSk7XG5cbiAgICAgICAgZm9yICh2YXIgb2kgPSAwOyBvaSA8IG9mZnNldHMubGVuZ3RoOyArK29pKSB7XG5cbiAgICAgICAgICAgIHZhciBzdGFydCA9IG9mZnNldHNbb2ldLnN0YXJ0O1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gb2Zmc2V0c1tvaV0uY291bnQ7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAgICAgaW5kZXggPSBvZmZzZXRzW29pXS5pbmRleDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSArPSAzKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYSA9IGluZGV4ICsgKGluZGljZXMgPyBpbmRpY2VzW2ldIDogaSk7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBpbmRleCArIChpbmRpY2VzID8gaW5kaWNlc1tpICsgMV0gOiBpICsgMSk7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBpbmRleCArIChpbmRpY2VzID8gaW5kaWNlc1tpICsgMl0gOiBpICsgMik7XG5cbiAgICAgICAgICAgICAgICByZWFkVmVydGV4KGEsIHZBKTtcbiAgICAgICAgICAgICAgICByZWFkVmVydGV4KGIsIHZCKTtcbiAgICAgICAgICAgICAgICByZWFkVmVydGV4KGMsIHZDKTtcblxuICAgICAgICAgICAgICAgIHZhciBmYWNlTm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgICAgICBUSFJFRS5UcmlhbmdsZS5nZXROb3JtYWwodkEsIHZCLCB2QywgZmFjZU5vcm1hbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNFcXVhbFZlY3RvcnNXaXRoUHJlY2lzaW9uKGZhY2VOb3JtYWwsIGZhY2Uubm9ybWFsKSAmJiBpc0VxdWFsV2l0aFByZWNpc2lvbihmYWNlTm9ybWFsLmRvdCh2QSksIGZhY2Uubm9ybWFsLmRvdCh2YSkpKVxuICAgICAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2SW5kZXggPSBnZW9tLnZlcnRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbS5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMyh2SW5kZXgsIHZJbmRleCArIDEsIHZJbmRleCArIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbS52ZXJ0aWNlcy5wdXNoKHZBLmNsb25lKCkpO1xuICAgICAgICAgICAgICAgICAgICBnZW9tLnZlcnRpY2VzLnB1c2godkIuY2xvbmUoKSk7XG4gICAgICAgICAgICAgICAgICAgIGdlb20udmVydGljZXMucHVzaCh2Qy5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2VvbS52ZXJ0aWNlcy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRyaWFuZ2xlc09uU2FtZUZhY2UoZ2VvbSwgZmFjZSwgcmVhZFZlcnRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdHJpYW5nbGVzIG9uIHRoZSBzYW1lIGZhY2Ugd2l0aCB0aGUgdHJpYW5nbGUgaW50ZXJzZWN0ZWQgd2l0aCB0aGUgY2FzdCByYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBnZW9tIC1HZW9tZXRyeSB3aGljaCBpbmNsdWRlcyBhbGwgdGhlIHRyaWFuZ2xlcyBvbiB0aGUgc2FtZSBwbGFuZS5cbiAgICAgKiBAcGFyYW0gZmFjZSAtVHJpYW5nbGUgd2hpY2ggaW50ZXJzZWN0cyB3aXRoIHRoZSBjYXN0IHJheS5cbiAgICAgKiBAcGFyYW0gcmVhZFZlcnRleENCIC1BY2Nlc3NvciBmdW5jdGlvbiB0byByZWFkIHZlcnRleCBkYXRhIChzZWUgbWFrZVJlYWRWZXJ0ZXhGdW5jKVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmdldFRyaWFuZ2xlc09uU2FtZUZhY2UgPSBmdW5jdGlvbihnZW9tLCBmYWNlLCByZWFkVmVydGV4Q0IpIHtcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBnZW9tLnZlcnRpY2VzO1xuXG4gICAgICAgIGNvbnN0IGZhY2VWZXJ0ZXgxID0gcmVhZFZlcnRleENCKGZhY2UuYSk7XG4gICAgICAgIGNvbnN0IGZhY2VWZXJ0ZXgyID0gcmVhZFZlcnRleENCKGZhY2UuYik7XG4gICAgICAgIGNvbnN0IGZhY2VWZXJ0ZXgzID0gcmVhZFZlcnRleENCKGZhY2UuYyk7XG5cbiAgICAgICAgY29uc3QgaW50ZXJzZWN0RmFjZSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG4gICAgICAgIGNvbnN0IHByZWNpc2lvblBvaW50cyA9IDU7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgZWcuIDQgZm9yIGVwc2lsb24gb2YgMC4wMDAxXG5cdFx0Y29uc3QgcHJlY2lzaW9uID0gTWF0aC5wb3coIDEwLCBwcmVjaXNpb25Qb2ludHMgKTtcblxuICAgICAgICAvLyBCdWlsZCB0cmlhbmdsZSBsaXN0XG4gICAgICAgIC8vIEVhY2ggdHJpYW5nbGUgd2lsbCBjb250YWluIGEgbGlzdCBvZiBpdHMgMyBlZGdlc1xuICAgICAgICAvLyBBbHNvIG1haW50YWluIGFuIGVkZ2UgbWFwLCBwb2ludGluZyB0byB0aGUgdHJpYW5nbGVzIGluZGljZXMgdGhhdCBjb250YWluIGl0XG4gICAgICAgIGNvbnN0IHRyaWFuZ2xlc0FyciA9IFtdO1xuICAgICAgICBjb25zdCBlZGdlc01hcCA9IHt9O1xuICAgICAgICBsZXQgZmlyc3RUcmlhbmdsZSA9IC0xOyAvLyBXaWxsIHBvaW50IHRvIGluZGV4IG9mIHBhc3NlZCBmYWNlIHBhcmFtZXRlclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICAvLyBmb3IgZWFjaCB0cmlhbmdsZVxuICAgICAgICAgICAgY29uc3QgdkEgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHZCID0gdmVydGljZXNbaSArIDFdO1xuICAgICAgICAgICAgY29uc3QgdkMgPSB2ZXJ0aWNlc1tpICsgMl07XG5cbiAgICAgICAgICAgIGlmIChmaXJzdFRyaWFuZ2xlIDwgMCAmJiBmYWNlVmVydGV4MS5lcXVhbHModkEpICYmIGZhY2VWZXJ0ZXgyLmVxdWFscyh2QikgJiYgZmFjZVZlcnRleDMuZXF1YWxzKHZDKSkge1xuICAgICAgICAgICAgICAgIGZpcnN0VHJpYW5nbGUgPSBpIC8gMztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHZBLnggKiBwcmVjaXNpb24pICsgJ18nICsgTWF0aC5yb3VuZCh2QS55ICogcHJlY2lzaW9uKSArICdfJyArIE1hdGgucm91bmQodkEueiAqIHByZWNpc2lvbiksXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCh2Qi54ICogcHJlY2lzaW9uKSArICdfJyArIE1hdGgucm91bmQodkIueSAqIHByZWNpc2lvbikgKyAnXycgKyBNYXRoLnJvdW5kKHZCLnogKiBwcmVjaXNpb24pLFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQodkMueCAqIHByZWNpc2lvbikgKyAnXycgKyBNYXRoLnJvdW5kKHZDLnkgKiBwcmVjaXNpb24pICsgJ18nICsgTWF0aC5yb3VuZCh2Qy56ICogcHJlY2lzaW9uKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHRyaWFuZ2xlID0geyBlZGdlczogW10gfTtcblxuICAgICAgICAgICAgLy8gRWRnZSBtYXAgdXBkYXRlXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleTEgPSBrZXlzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleTIgPSBrZXlzWyhqICsgMSkgJSAzXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFZGdlID0ga2V5MSArICdfJyArIGtleTI7XG4gICAgICAgICAgICAgICAgbGV0IGVkZ2UgPSBlZGdlc01hcFtkZWZhdWx0RWRnZV0gfHwgZWRnZXNNYXBba2V5MiArICdfJyArIGtleTFdO1xuICAgICAgICAgICAgICAgIGlmICghZWRnZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGVkZ2UgaGFzbid0IGJlZW4gYWRkZWQgYmVmb3JlLCBhZGQgaXQgbm93XG4gICAgICAgICAgICAgICAgICAgIGVkZ2UgPSBlZGdlc01hcFtkZWZhdWx0RWRnZV0gPSB7IHRyaWFuZ2xlczogW10gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQWRkIGVkZ2UgdG8gY3VycmVudCB0cmlhbmdsZVxuICAgICAgICAgICAgICAgIHRyaWFuZ2xlLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGN1cnJlbnQgdHJpYW5nbGUgdG8gZWRnZVxuICAgICAgICAgICAgICAgIGVkZ2UudHJpYW5nbGVzLnB1c2goaSAvIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIHRyaWFuZ2xlc0Fyci5wdXNoKHRyaWFuZ2xlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaXJzdFRyaWFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCRlMgc2VhcmNoIGZvciBuZWlnaGJvdXJpbmcgdHJpYW5nbGVzXG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW2ZpcnN0VHJpYW5nbGVdO1xuICAgICAgICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBjb25uZWN0ZWRGYWNlcyA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RmFjZSA9IHF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIGlmICh2aXNpdGVkLmhhcyhjdXJyZW50RmFjZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmlzaXRlZC5hZGQoY3VycmVudEZhY2UpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhpcyBmYWNlIHRvIHRoZSBsaXN0IG9mIGNvbm5lY3RlZCBmYWNlc1xuICAgICAgICAgICAgY29ubmVjdGVkRmFjZXMucHVzaChjdXJyZW50RmFjZSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBhbGwgbmVpZ2hib3JpbmcgZmFjZXMgdG8gdGhlIHF1ZXVlXG4gICAgICAgICAgICBjb25zdCB0cmlhbmdsZSA9IHRyaWFuZ2xlc0FycltjdXJyZW50RmFjZV07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdHJpYW5nbGUuZWRnZXMpIHtcbiAgICAgICAgICAgICAgICBlZGdlLnRyaWFuZ2xlcy5mb3JFYWNoKHQgPT4gdCAhPT0gY3VycmVudEZhY2UgJiYgcXVldWUucHVzaCh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb3B5IHJlc3VsdHMgb2YgdGhlIGFjdHVhbCB2ZXJ0aWNlcyBpbiB0aGUgY29ubmVjdGVkIGZhY2VzXG4gICAgICAgIC8vIFNpbmNlIHZlcnRpY2VzIGFyZSBhbHJlYWR5IGNsb25lZCBpbiBmYWNlU25hcHBpbmcsIHRoZXJlJ3Mgbm8gbmVlZCB0byBjbG9uZSB0aGVtIGFnYWluXG4gICAgICAgIGNvbnN0IGZpbmFsVmVydGljZXMgPSBbXTtcbiAgICAgICAgbGV0IHZJbmRleCA9IDA7XG4gICAgICAgIGNvbm5lY3RlZEZhY2VzLmZvckVhY2goZmFjZUlkeCA9PiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RGYWNlLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKHZJbmRleCsrLCB2SW5kZXgrKywgdkluZGV4KyspKTtcbiAgICAgICAgICAgIGZpbmFsVmVydGljZXMucHVzaCh2ZXJ0aWNlc1tmYWNlSWR4ICogM10pO1xuICAgICAgICAgICAgZmluYWxWZXJ0aWNlcy5wdXNoKHZlcnRpY2VzW2ZhY2VJZHggKiAzICsgMV0pO1xuICAgICAgICAgICAgZmluYWxWZXJ0aWNlcy5wdXNoKHZlcnRpY2VzW2ZhY2VJZHggKiAzICsgMl0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpbnRlcnNlY3RGYWNlLnZlcnRpY2VzID0gZmluYWxWZXJ0aWNlcztcblxuICAgICAgICByZXR1cm4gaW50ZXJzZWN0RmFjZTtcbiAgICB9O1xuXG4gICAgdGhpcy5lZGdlU25hcHBpbmdXaXRoVG9wb2xvZ3kgPSBmdW5jdGlvbihpbnRlcnNlY3RQb2ludCwgZ2VvbWV0cnksIGVkZ2VzVG9wb2xvZ3ksIHttYXRyaXhXb3JsZH0pIHtcblxuICAgICAgICBjb25zdCBlZGdlR2VvbSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpOyAvL0dlb21ldHJ5IHdoaWNoIGluY2x1ZGVzIGFsbCB0aGUgdHJpYW5nbGVzIG9uIHRoZSBzYW1lIHBsYW5lLlxuICAgICAgICB2YXIgbWluRGlzdFRvcG9JbmRleDtcbiAgICAgICAgdmFyIG1pbkRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgIHZhciB2QSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciB2QiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgaWYgKGdlb21ldHJ5LmluZGV4ICE9PSB1bmRlZmluZWQgJiYgZWRnZXNUb3BvbG9neSAhPSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgY29uc3QgcmVhZFZlcnRleCA9IHRoaXMubWFrZVJlYWRWZXJ0ZXhGdW5jKGdlb21ldHJ5KTtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIGVkZ2UgdG9wb2xvZ3kgbGlzdCB3aGljaCBpbmNsdWRlcyB0aGUgbmVhcmVzdCBlZGdlIHNlZ21lbnQgdG8gdGhlIGludGVyc2VjdCBwb2ludFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlc1RvcG9sb2d5Lmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhMaXN0ID0gZWRnZXNUb3BvbG9neVtpXS5pbmRleExpc3Q7XG4gICAgICAgICAgICAgICAgLy8gSW4gZWRnZXMgdG9wb2xvZ3kgaW5kZXggbGlzdCB0aGUgdHlwZSBpcyBMaW5lU3RyaXBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGluZGV4TGlzdC5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZFZlcnRleChpbmRleExpc3Rbal0sIHZBKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZFZlcnRleChpbmRleExpc3RbaiArIDFdLCB2Qik7XG5cbiAgICAgICAgICAgICAgICAgICAgdkEuYXBwbHlNYXRyaXg0KG1hdHJpeFdvcmxkKTtcbiAgICAgICAgICAgICAgICAgICAgdkIuYXBwbHlNYXRyaXg0KG1hdHJpeFdvcmxkKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGRpc3RhbmNlUG9pbnRUb0xpbmUoaW50ZXJzZWN0UG9pbnQsIHZBLCB2Qik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgbWluRGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5EaXN0VG9wb0luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1pbkRpc3RUb3BvSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpbmRleExpc3QgPSBlZGdlc1RvcG9sb2d5W21pbkRpc3RUb3BvSW5kZXhdLmluZGV4TGlzdDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGluZGV4TGlzdC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdkswID0gcmVhZFZlcnRleChpbmRleExpc3Rba10pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2SzEgPSByZWFkVmVydGV4KGluZGV4TGlzdFtrICsgMV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VHZW9tLnZlcnRpY2VzLnB1c2godkswKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVG8gbWFrZSB0aGUgbGluZSdzIHR5cGUgdG8gTGluZVBpZWNlcyB3aGljaCBpcyB1c2VkIGJ5IGRyYXdMaW5lIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VHZW9tLnZlcnRpY2VzLnB1c2godksxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2Rpc3RhbmNlVG9FZGdlID49IG1pbkRpc3QgJiYgZWRnZUdlb20udmVydGljZXMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICBfZGlzdGFuY2VUb0VkZ2UgPSBtaW5EaXN0O1xuICAgICAgICAgICAgZWRnZUdlb20uYXBwbHlNYXRyaXg0KG1hdHJpeFdvcmxkKTtcbiAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21FZGdlID0gZWRnZUdlb207XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IEVkZ2UgZ2VvbWV0cnkgZm9yIHRoZSBjYXNlIHRoYXQgdGhlIGhpdHRlc3QgcmVzdWx0IGNvbnRhaW5lZCBhIDNEIGxpbmVzLiBGb3IgdGhpcyBjYXNlLCB3ZSBoYXZlIG5vIEZhY2UzLCBzb1xuICAgICAqIHRoYXQgZmFjZVNuYXBwaW5nIGFuZCBlZGdlU25hcHBpbmcgZG9uJ3Qgd29yay5cbiAgICAgKlxuICAgICAqICBAcGFyYW0ge09iamVjdH0gICAgICAgICBlZGdlICAgICAtIHthLCBifSB3aXRoIHZlcnRleCBpbmRpY2VzIGEsYiBvZiBsaW5lU3RhcnQvbGluZUVuZCB2ZXJ0ZXhcbiAgICAgKiAgQHBhcmFtIHtHZW9tZXRyeUJ1ZmZlcn0gZ2VvbWV0cnlcbiAgICAgKiAgQHJldHVybnMge1RIUkVFLkdlb21ldHJ5fFRIUkVFLkJ1ZmZlckdlb21ldHJ5fSBHZW9tZXRyeSB3aXRoIHNpbXBsZSBsaW5lXG4gICAgICovXG4gICAgdGhpcy5leHRyYWN0TGluZUdlb21ldHJ5ID0gZnVuY3Rpb24oZWRnZSwgZ2VvbWV0cnkpIHtcblxuICAgICAgICBjb25zdCByZWFkVmVydGV4ID0gdGhpcy5tYWtlUmVhZFZlcnRleEZ1bmMoZ2VvbWV0cnkpO1xuICAgICAgICBjb25zdCB2YSA9IHJlYWRWZXJ0ZXgoZWRnZS5hKTtcbiAgICAgICAgY29uc3QgdmIgPSByZWFkVmVydGV4KGVkZ2UuYik7XG5cbiAgICAgICAgY29uc3QgZWRnZUdlb20gPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICAgICAgZWRnZUdlb20udmVydGljZXMucHVzaCh2YSwgdmIpO1xuICAgICAgICByZXR1cm4gZWRnZUdlb207XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGNsb3Nlc3QgZWRnZSBuZXh0IHRvIHRoZSBpbnRlcnNlY3QgcG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmYWNlIC1GYWNlIHdoaWNoIGlzIGZvdW5kIGJ5IGZhY2VTbmFwcGluZy5cbiAgICAgKiBAcGFyYW0gaW50ZXJzZWN0UG9pbnQgLUludGVyc2VjdFBvaW50IGJldHdlZW4gY2FzdCByYXkgYW5kIGZhY2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZWRnZVNuYXBwaW5nID0gZnVuY3Rpb24oZmFjZSwgaW50ZXJzZWN0UG9pbnQpIHtcblxuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuICAgICAgICBjb25zdCB2ZXJ0aWNlc0xlbmd0aCA9IGZhY2UudmVydGljZXMubGVuZ3RoO1xuICAgICAgICB2YXIgaXNFZGdlXzEyID0gdHJ1ZTtcbiAgICAgICAgdmFyIGlzRWRnZV8xMyA9IHRydWU7XG4gICAgICAgIHZhciBpc0VkZ2VfMjMgPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXNMZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgY29uc3QgcGkwID0gZmFjZS52ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHBpMSA9IGZhY2UudmVydGljZXNbaSArIDFdO1xuICAgICAgICAgICAgY29uc3QgcGkyID0gZmFjZS52ZXJ0aWNlc1tpICsgMl07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmVydGljZXNMZW5ndGg7IGogKz0gMykge1xuICAgICAgICAgICAgICAgIGlmICggaSAhPT0gaiApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGowID0gZmFjZS52ZXJ0aWNlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGoxID0gZmFjZS52ZXJ0aWNlc1tqICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBqMiA9IGZhY2UudmVydGljZXNbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBlZGdlIDEyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocGkwLmVxdWFscyhwajApIHx8IHBpMC5lcXVhbHMocGoxKSB8fCBwaTAuZXF1YWxzKHBqMikpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAocGkxLmVxdWFscyhwajApIHx8IHBpMS5lcXVhbHMocGoxKSB8fCBwaTEuZXF1YWxzKHBqMikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VkZ2VfMTIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBlZGdlIDEzXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGVkZ2UgMTJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwaTAuZXF1YWxzKHBqMCkgfHwgcGkwLmVxdWFscyhwajEpIHx8IHBpMC5lcXVhbHMocGoyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChwaTIuZXF1YWxzKHBqMCkgfHwgcGkyLmVxdWFscyhwajEpIHx8IHBpMi5lcXVhbHMocGoyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRWRnZV8xMyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGVkZ2UgMjNcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZWRnZSAxMlxuICAgICAgICAgICAgICAgICAgICBpZiAoKHBpMS5lcXVhbHMocGowKSB8fCBwaTEuZXF1YWxzKHBqMSkgfHwgcGkxLmVxdWFscyhwajIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHBpMi5lcXVhbHMocGowKSB8fCBwaTIuZXF1YWxzKHBqMSkgfHwgcGkyLmVxdWFscyhwajIpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNFZGdlXzIzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0VkZ2VfMTIpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHBpMC5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHBpMS5jbG9uZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0VkZ2VfMTMpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHBpMC5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHBpMi5jbG9uZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0VkZ2VfMjMpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHBpMS5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHBpMi5jbG9uZSgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXNFZGdlXzEyID0gdHJ1ZTtcbiAgICAgICAgICAgIGlzRWRnZV8xMyA9IHRydWU7XG4gICAgICAgICAgICBpc0VkZ2VfMjMgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvL3JldHVybiBsaW5lR2VvbTtcblxuICAgICAgICBjb25zdCBlZGdlVmVydGljZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZWRnZUdlb20gPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICAgICAgdmFyIG1pbkRpc3RJbmRleDtcbiAgICAgICAgdmFyIG1pbkRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdmVydGljZXMubGVuZ3RoOyBrICs9IDIpIHtcblxuICAgICAgICAgICAgdmFyIGRpc3QgPSBkaXN0YW5jZVBvaW50VG9MaW5lKGludGVyc2VjdFBvaW50LCB2ZXJ0aWNlc1trXSwgdmVydGljZXNbayArIDFdKTtcblxuICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgbWluRGlzdEluZGV4ID0gaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZWRnZVZlcnRpY2VzLnB1c2godmVydGljZXNbIG1pbkRpc3RJbmRleCBdLmNsb25lKCkpO1xuICAgICAgICBlZGdlVmVydGljZXMucHVzaCh2ZXJ0aWNlc1sgbWluRGlzdEluZGV4ICsgMSBdLmNsb25lKCkpO1xuXG4gICAgICAgIGNvbnN0IGxpbmVHZW9tID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgICAgIGxpbmVHZW9tLnZlcnRpY2VzID0gdmVydGljZXM7XG4gICAgICAgIGVkZ2VHZW9tLnZlcnRpY2VzID0gdGhpcy5nZXRDb25uZWN0ZWRMaW5lU2VnbWVudHNPblNhbWVMaW5lKGxpbmVHZW9tLCBlZGdlVmVydGljZXMpO1xuXG4gICAgICAgIF9kaXN0YW5jZVRvRWRnZSA9IG1pbkRpc3Q7XG5cbiAgICAgICAgcmV0dXJuIGVkZ2VHZW9tO1xuICAgIH07XG5cbiAgICB0aGlzLmdldENvbm5lY3RlZExpbmVTZWdtZW50c09uU2FtZUxpbmUgPSBmdW5jdGlvbihsaW5lR2VvbSwgZWRnZVZlcnRpY2VzKSB7XG5cbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBsaW5lR2VvbS52ZXJ0aWNlcy5zbGljZSgpO1xuICAgICAgICB2YXIgdmEgPSBlZGdlVmVydGljZXNbMF07XG4gICAgICAgIHZhciB2YiA9IGVkZ2VWZXJ0aWNlc1sxXTtcblxuICAgICAgICB2YXIgdkNvdW50ID0gW107XG5cbiAgICAgICAgZG8ge1xuXG4gICAgICAgICAgICB2Q291bnQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2ZXJ0aWNlcy5sZW5ndGg7IGogKz0gMikge1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGxpbmUgd2hpY2ggaGFzIG1pbiBkaXN0YW5jZSB0byBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICAgICAgICAgICBpZiAodmVydGljZXNbal0uZXF1YWxzKHZhKSAmJiB2ZXJ0aWNlc1tqICsgMV0uZXF1YWxzKHZiKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZWRnZVZlcnRpY2VzLmxlbmd0aDsgayArPSAyKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGxpbmUgc2VnbWVudHMgd2hpY2ggYXJlIGNvbm5lY3RlZCBvbiB0aGUgc2FtZSBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNlc1tqXS5lcXVhbHMoZWRnZVZlcnRpY2VzW2tdKSB8fCB2ZXJ0aWNlc1tqICsgMV0uZXF1YWxzKGVkZ2VWZXJ0aWNlc1trXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzW2pdLmVxdWFscyhlZGdlVmVydGljZXNbayArIDFdKSB8fCB2ZXJ0aWNlc1tqICsgMV0uZXF1YWxzKGVkZ2VWZXJ0aWNlc1trICsgMV0pKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBWMCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgVjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBWMC5zdWJWZWN0b3JzKGVkZ2VWZXJ0aWNlc1trXSwgIGVkZ2VWZXJ0aWNlc1trICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgVjAubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBWMS5zdWJWZWN0b3JzKHZlcnRpY2VzW2pdLHZlcnRpY2VzW2ogKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBWMS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAoVjAuZXF1YWxzKFYxKSB8fCBWMC5lcXVhbHMoVjEubmVnYXRlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcXVhbFZlY3RvcnNXaXRoUHJlY2lzaW9uKFYwLCBWMSkgfHwgaXNJbnZlcnNlVmVjdG9yc1dpdGhQcmVjaXNpb24oVjAsIFYxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZDb3VudC5wdXNoKGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGNpID0gdkNvdW50Lmxlbmd0aCAtIDE7IGNpID49IDA7IC0tY2kpIHtcblxuICAgICAgICAgICAgICAgIGVkZ2VWZXJ0aWNlcy5wdXNoKHZlcnRpY2VzWyB2Q291bnRbY2ldIF0pO1xuICAgICAgICAgICAgICAgIGVkZ2VWZXJ0aWNlcy5wdXNoKHZlcnRpY2VzWyB2Q291bnRbY2ldICsgMSBdKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5zcGxpY2UodkNvdW50W2NpXSwgMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSB3aGlsZSAodkNvdW50Lmxlbmd0aCA+IDApO1xuXG4gICAgICAgIHJldHVybiBlZGdlVmVydGljZXM7XG5cbiAgICB9O1xuXG4gICAgdGhpcy52ZXJ0ZXhTbmFwcGluZ1dpdGhUb3BvbG9neSA9IGZ1bmN0aW9uKGVkZ2UsIGludGVyc2VjdFBvaW50KSB7XG5cbiAgICAgICAgdmFyIG1pbkRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB2YXIgcG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICBpZiAoIWVkZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlZGdlLnZlcnRpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZWRnZS52ZXJ0aWNlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGVkZ2UudmVydGljZXNbZWRnZS52ZXJ0aWNlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBkaXN0MSA9IGludGVyc2VjdFBvaW50LmRpc3RhbmNlVG8oc3RhcnQpO1xuICAgICAgICAgICAgdmFyIGRpc3QyID0gaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhlbmQpO1xuXG4gICAgICAgICAgICBpZiAoZGlzdDEgPD0gZGlzdDIpIHtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZGlzdDE7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBzdGFydC5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWluRGlzdCA9IGRpc3QyO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gZW5kLmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfZGlzdGFuY2VUb1ZlcnRleCA9IG1pbkRpc3Q7XG5cbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBjbG9zZXN0IHZlcnRleCBuZXh0IHRvIHRoZSBpbnRlcnNlY3QgcG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlZGdlIC1FZGdlIHdoaWNoIGlzIGZvdW5kIGJ5IGVkZ2VTbmFwcGluZy5cbiAgICAgKiBAcGFyYW0gaW50ZXJzZWN0UG9pbnQgLUludGVyc2VjdFBvaW50IGJldHdlZW4gY2FzdCByYXkgYW5kIGZhY2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmVydGV4U25hcHBpbmcgPSBmdW5jdGlvbihlZGdlLCBpbnRlcnNlY3RQb2ludCkge1xuXG4gICAgICAgIHZhciBtaW5EaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIHBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgY29uc3QgdmVydGljZXNMZW5ndGggPSBlZGdlLnZlcnRpY2VzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRpY2VzTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHB0ID0gZWRnZS52ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBpbnRlcnNlY3RQb2ludC5kaXN0YW5jZVRvKHB0KTtcblxuICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0IC0gU05BUF9QUkVDSVNJT04pIHtcblxuICAgICAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcHQuY2xvbmUoKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2Rpc3RhbmNlVG9WZXJ0ZXggPSBtaW5EaXN0O1xuXG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9O1xuXG4gICAgLy8gVGhpcyBpcyBvbmx5IGEgd29ya2Fyb3VuZCB0byBkZXRlY3QgaWYgYW4gZWRnZSBpcyBjaXJjbGVcbiAgICB0aGlzLmVkZ2VJc0NpcmNsZSA9IGZ1bmN0aW9uKGVkZ2UpIHtcblxuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IGVkZ2UudmVydGljZXM7XG5cbiAgICAgICAgLy8gRXhjbHVkZSBzcXVhcmVzIGFuZCByZWd1bGFyIHBvbHlnb25zXG4gICAgICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydCA9IHZlcnRpY2VzWzBdO1xuICAgICAgICBjb25zdCBlbmQgPSB2ZXJ0aWNlc1t2ZXJ0aWNlcy5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoc3RhcnQuZXF1YWxzKGVuZCkpIHtcblxuICAgICAgICAgICAgdmFyIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGNlbnRlci5hZGQodmVydGljZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VudGVyLmRpdmlkZVNjYWxhcih2ZXJ0aWNlcy5sZW5ndGggLyAyLjApO1xuXG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gY2VudGVyLmRpc3RhbmNlVG8oc3RhcnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjZW50ZXIuZGlzdGFuY2VUbyh2ZXJ0aWNlc1tpXSkgLSByYWRpdXMpIDw9IFNOQVBfUFJFQ0lTSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjZW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5lZGdlSXNDdXJ2ZWQgPSBmdW5jdGlvbiAoZWRnZSkge1xuXG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gZWRnZS52ZXJ0aWNlcztcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB2ZXJ0aWNlc1swXTtcbiAgICAgICAgY29uc3QgZW5kID0gdmVydGljZXNbdmVydGljZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA8PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhcnQuZXF1YWxzKGVuZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIFYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgIGxldCBwaTA7XG4gICAgICAgICAgICBsZXQgcGkxID0gdmVydGljZXNbMV07XG5cbiAgICAgICAgICAgIFYxLnN1YlZlY3RvcnMoc3RhcnQsIHBpMSk7XG5cbiAgICAgICAgICAgIHZhciBWMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMjsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgcGkwID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICAgICAgcGkxID0gdmVydGljZXNbaSArIGldO1xuICAgICAgICAgICAgICAgIFYyLnN1YlZlY3RvcnMocGkwLCBwaTEpO1xuICAgICAgICAgICAgICAgIGlmICghaXNFcXVhbFZlY3RvcnNXaXRoUHJlY2lzaW9uKFYxLCBWMikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBnZW9tZXRyeSBpcyBjdXJ2ZWRcbiAgICAgKiBAcGFyYW0ge1RIUkVFLkJ1ZmZlckdlb21ldHJ5fSBmYWNlIFRoZSBnZW9tZXRyeVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBhbnkgb2YgdGhlIGZhY2VzIGNvbXBvc2luZyB0aGUgZ2VvbWV0cnkgaXMgY3VydmVkXG4gICAgICovXG4gICAgdGhpcy5mYWNlSXNDdXJ2ZWQgPSBmdW5jdGlvbiAoZmFjZSkge1xuXG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gZmFjZS52ZXJ0aWNlcztcbiAgICAgICAgY29uc3QgZmFjZXMgPSBmYWNlLmZhY2VzO1xuXG4gICAgICAgIGlmIChmYWNlcy5sZW5ndGggPD0gMSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICB2YXIgZk4xID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgY29uc3QgdkExID0gdmVydGljZXNbZmFjZXNbMF0uYV07XG4gICAgICAgIFRIUkVFLlRyaWFuZ2xlLmdldE5vcm1hbCh2ZXJ0aWNlc1tmYWNlc1swXS5hXSwgdmVydGljZXNbZmFjZXNbMF0uYl0sIHZlcnRpY2VzW2ZhY2VzWzBdLmNdLCBmTjEpO1xuXG4gICAgICAgIHZhciBmTjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGZhY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2QTIgPSB2ZXJ0aWNlc1tmYWNlc1tpXS5hXTtcbiAgICAgICAgICAgIFRIUkVFLlRyaWFuZ2xlLmdldE5vcm1hbCh2ZXJ0aWNlc1tmYWNlc1tpXS5hXSwgdmVydGljZXNbZmFjZXNbaV0uYl0sIHZlcnRpY2VzW2ZhY2VzW2ldLmNdLCBmTjIpO1xuICAgICAgICAgICAgaWYgKCFpc0VxdWFsVmVjdG9yc1dpdGhQcmVjaXNpb24oZk4xLCBmTjIpIHx8ICFpc0VxdWFsV2l0aFByZWNpc2lvbihmTjEuZG90KHZBMSksIGZOMi5kb3QodkEyKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5hbmdsZVZlY3RvcjIgPSBmdW5jdGlvbih2ZWN0b3IpIHtcblxuICAgICAgICBpZiAodmVjdG9yLnggPiAwICYmIHZlY3Rvci55ID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4odmVjdG9yLnkgLyB2ZWN0b3IueCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmVjdG9yLnggPj0gMCAmJiB2ZWN0b3IueSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4odmVjdG9yLnkgLyB2ZWN0b3IueCkgKyBNYXRoLlBJICogMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ZWN0b3IueCA8IDAgJiYgdmVjdG9yLnkgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYXRhbih2ZWN0b3IueSAvIHZlY3Rvci54KSArIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmVjdG9yLnggPD0gMCAmJiB2ZWN0b3IueSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4odmVjdG9yLnkgLyB2ZWN0b3IueCkgKyBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7IC8vIHggPSAwLCB5ID0gMFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ3JlYXRlcyBhIFRIUkVFLkdlb21ldHJ5IHRoYXQgcmVwcmVzZW50cyBhbiBhcHByb3hpbWF0aW9uIG9mIGEgZ2l2ZW4gZWxsaXB0aWNhbCBhcmMgaW4ge3o9MH0gcGxhbmUuXG4gICAgLy8gUG9pbnRzIGFyZSBvYnRhaW5lZCBieSBieSB1bmlmb3JtIHNhbXBsaW5nIG9mIGEgZ2l2ZW4gZWxsaXB0aWNhbCBhcmMuXG4gICAgLy8gIEBwYXJhbSB7bnVtYmVyfSBudW1Qb2ludHMgLSBUaGUgbGVuZ3RoIG51bWJlciBvZiBwb2ludHMgdGhhdCB0aGUgb3V0cHV0IGdlb21ldHJ5IHdpbGwgY29udGFpbi4gc2VnbWVudHMgaW4gd2hpY2ggd2Ugc3ViZGl2aWRlIHRoZSBhcmMuIFJlc3VsdGluZyBwb2ludCBjb3VudCBpcyBudW1TZWdtZW50cysxLlxuICAgIC8vIFNlZSBnZXRFbGxpcHNlQXJjUG9pbnQoKSBmb3IgcGFyYW0gZGV0YWlscy5cbiAgICBjb25zdCBjcmVhdGVFbGxpcHRpY2FsQXJjR2VvbWV0cnkgPSAoY3gsIGN5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBudW1Qb2ludHMpID0+IHtcbiAgICAgICAgbGV0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxudW1Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsMCwwKTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBpLyhudW1Qb2ludHMtMSk7XG4gICAgICAgICAgICBBdXRvZGVzay5FeHRlbnNpb25zLkNvbXBHZW9tLmdldEVsbGlwc2VBcmNQb2ludCh0LCBjeCwgY3ksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIDAuMCwgcCk7XG4gICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtWaWV3ZXIzRH0gdmlld2VyIC0gVmlld2VyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHNuYXBwZXJcbiAgICAgKiBAcGFyYW0gYURldGVjdFJhZGl1c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gR2VvbWV0cnlDYWxsYmFjayh2aWV3ZXIsIHNuYXBwZXIsIGFEZXRlY3RSYWRpdXMpIHtcbiAgICAgICAgdGhpcy52aWV3ZXIgPSB2aWV3ZXI7XG4gICAgICAgIHRoaXMuc25hcHBlciA9IHNuYXBwZXI7XG5cbiAgICAgICAgdGhpcy5saW5lR2VvbSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgICAgICB0aGlzLmNpcmN1bGFyQXJjID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaXJjdWxhckFyY0NlbnRlcjtcbiAgICAgICAgdGhpcy5jaXJjdWxhckFyY1JhZGl1cztcbiAgICAgICAgdGhpcy5lbGxpcHRpY2FsQXJjID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbGxpcHRpY2FsQXJjQ2VudGVyO1xuXG4gICAgICAgIHRoaXMubWluRGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgdGhpcy5tYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgIHRoaXMudnBJZExpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLnZwSWRDaXJjdWxhciA9IG51bGw7XG4gICAgICAgIHRoaXMudnBJZEVsbGlwdGljYWwgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuZGV0ZWN0UmFkaXVzID0gYURldGVjdFJhZGl1cztcblxuICAgICAgICAvLyBDb2xsZWN0cyBjYW5kaWRhdGUgc2VnbWVudHMgdGhhdCB3ZSBjYW4gc25hcCB0by5cbiAgICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIGFsbG93IHNuYXBwaW5nIHRvIHNlZ21lbnQgaW50ZXJzZWN0aW9ucy5cbiAgICAgICAgdGhpcy5zbmFwQ2FuZGlkYXRlcyA9IFtdOyAvLyB7U25hcHBpbmdDYW5kaWRhdGVbXX1cbiAgICB9XG5cbiAgICBHZW9tZXRyeUNhbGxiYWNrLnByb3RvdHlwZS5vbkxpbmVTZWdtZW50ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHZwSWQpIHtcbiAgICAgICAgdmFyIGludGVyc2VjdFBvaW50ID0gdGhpcy5zbmFwcGVyLmdldEludGVyc2VjdFBvaW50KCk7XG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKHgxLCB5MSwgaW50ZXJzZWN0UG9pbnQueik7XG4gICAgICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKHgyLCB5MiwgaW50ZXJzZWN0UG9pbnQueik7XG5cbiAgICAgICAgLy8gTE1WLTU1MTU6IEFwcGx5IHRoZSBzdXBwbGllZCBtYXRyaXggdG8gdGhlIGxpbmUgdmVjdG9yJ3NcbiAgICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgICAgICB2MS5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXgpO1xuICAgICAgICAgICAgdjIuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNraXAgc2VnbWVudHMgb3V0c2lkZSBkZXRlY3RSYWRpdXNcbiAgICAgICAgdmFyIGRpc3QgPSBkaXN0YW5jZVBvaW50VG9MaW5lKGludGVyc2VjdFBvaW50LCB2MSwgdjIpO1xuICAgICAgICBpZiAoZGlzdCA+IHRoaXMuZGV0ZWN0UmFkaXVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb2xsZWN0IHNuYXAgY2FuZGlkYXRlXG4gICAgICAgIHRoaXMuc25hcENhbmRpZGF0ZXMucHVzaChuZXcgU25hcENhbmRpZGF0ZSh2cElkLCBkaXN0KS5mcm9tTGluZSh2MSwgdjIpKTtcblxuICAgICAgICAvLyBUcmFjayBtaW5EaXN0IGFuZCBsaW5lR2VvbWV0cnkgZm9yIGJlc3QgaGl0IHNvIGZhclxuICAgICAgICBpZiAoZGlzdCA8IHRoaXMubWluRGlzdCkge1xuICAgICAgICAgICAgdGhpcy5saW5lR2VvbS52ZXJ0aWNlcy5zcGxpY2UoMCwgMiwgdjEsIHYyKTtcbiAgICAgICAgICAgIHRoaXMubWluRGlzdCA9IGRpc3Q7XG5cbiAgICAgICAgICAgIHRoaXMudnBJZExpbmUgPSB2cElkO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEdlb21ldHJ5Q2FsbGJhY2sucHJvdG90eXBlLm9uQ2lyY3VsYXJBcmMgPSBmdW5jdGlvbihjeCwgY3ksIHN0YXJ0LCBlbmQsIHJhZGl1cywgdnBJZCkge1xuICAgICAgICB2YXIgaW50ZXJzZWN0UG9pbnQgPSB0aGlzLnNuYXBwZXIuZ2V0SW50ZXJzZWN0UG9pbnQoKTtcbiAgICAgICAgdmFyIHBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjIoaW50ZXJzZWN0UG9pbnQueCwgaW50ZXJzZWN0UG9pbnQueSk7XG5cbiAgICAgICAgdmFyIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IyKGN4LCBjeSk7XG4gICAgICAgIHBvaW50LnN1YihjZW50ZXIpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgY2xvc2VzdCBwb2ludCBvbiBhcmNcbiAgICAgICAgY29uc3QgcG9pbnRPbkFyYyA9IG5lYXJlc3RQb2ludE9uQ2lyY3VsYXJBcmMoaW50ZXJzZWN0UG9pbnQsIGNlbnRlciwgcmFkaXVzLCBzdGFydCwgZW5kKTtcbiAgICAgICAgY29uc3QgZGlzdCAgICAgICA9IHBvaW50T25BcmMuZGlzdGFuY2VUbyhpbnRlcnNlY3RQb2ludCk7IC8vIDJEIGRpc3RhbmNlXG5cbiAgICAgICAgLy8gQ29sbGVjdCBzbmFwIGNhbmRpZGF0ZVxuICAgICAgICB0aGlzLnNuYXBDYW5kaWRhdGVzLnB1c2gobmV3IFNuYXBDYW5kaWRhdGUodnBJZCwgZGlzdCkuZnJvbUNpcmN1bGFyQXJjKGNlbnRlciwgcmFkaXVzLCBzdGFydCwgZW5kKSk7XG5cbiAgICAgICAgLy8gU2tpcCBhcmNzIG91dHNpZGUgZGV0ZWN0UmFkaXVzXG4gICAgICAgIGlmIChkaXN0ID4gdGhpcy5kZXRlY3RSYWRpdXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGdldCByaWQgb2YgdGhlIENpcmNsZUdlb21ldHJ5IHN0dWZmIGJlbG93LCBiZWNhdXNlIHdlIGNvbXB1dGVkIHRoZSBzbmFwUG9pbnQgYWJvdmUgYWxyZWFkeS5cbiAgICAgICAgLy8gICAgICAgQnV0IHRoaXMgbmVlZHMgc29tZSByZWZhY3RvcmluZywgYmVjYXVzZSB0aGUgR2VvbWV0cnkgaXMgcGFzc2VkIGFyb3VuZCBvdXRzaWRlIG9mIHNuYXBwZXIuXG5cbiAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5zbmFwcGVyLmFuZ2xlVmVjdG9yMihwb2ludCk7XG5cbiAgICAgICAgbGV0IGFyYztcbiAgICAgICAgaWYgKGVuZCA+IHN0YXJ0ICYmIGFuZ2xlID49IHN0YXJ0ICYmIGFuZ2xlIDw9IGVuZCkge1xuICAgICAgICAgICAgYXJjID0gbmV3IFRIUkVFLkNpcmNsZUdlb21ldHJ5KHJhZGl1cywgMTAwLCBzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVuZCA8IHN0YXJ0ICYmIChhbmdsZSA+PSBzdGFydCB8fCBhbmdsZSA8PSBlbmQpKSB7XG4gICAgICAgICAgICBhcmMgPSBuZXcgVEhSRUUuQ2lyY2xlR2VvbWV0cnkocmFkaXVzLCAxMDAsIHN0YXJ0LCBNYXRoLlBJICogMiAtIHN0YXJ0ICsgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyYy52ZXJ0aWNlcy5zcGxpY2UoMCwgMSk7XG5cbiAgICAgICAgYXJjLmFwcGx5TWF0cml4NChuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VUcmFuc2xhdGlvbihjeCwgY3ksIGludGVyc2VjdFBvaW50LnopKTtcbiAgICAgICAgdGhpcy5jaXJjdWxhckFyYyA9IGFyYztcbiAgICAgICAgdGhpcy5jaXJjdWxhckFyY0NlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKGN4LCBjeSwgaW50ZXJzZWN0UG9pbnQueik7XG4gICAgICAgIHRoaXMuY2lyY3VsYXJBcmNSYWRpdXMgPSByYWRpdXM7XG5cbiAgICAgICAgdGhpcy5zbmFwUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMyhwb2ludE9uQXJjLngsIHBvaW50T25BcmMueSwgaW50ZXJzZWN0UG9pbnQueik7XG5cbiAgICAgICAgdGhpcy52cElkQ2lyY3VsYXIgPSB2cElkO1xuICAgIH07XG5cbiAgICBHZW9tZXRyeUNhbGxiYWNrLnByb3RvdHlwZS5vbkVsbGlwdGljYWxBcmMgPSBmdW5jdGlvbihjeCwgY3ksIHN0YXJ0LCBlbmQsIG1ham9yLCBtaW5vciwgdGlsdCwgdnBJZCkge1xuICAgICAgICB2YXIgaW50ZXJzZWN0UG9pbnQgPSB0aGlzLnNuYXBwZXIuZ2V0SW50ZXJzZWN0UG9pbnQoKTtcbiAgICAgICAgdmFyIHBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjIoaW50ZXJzZWN0UG9pbnQueCwgaW50ZXJzZWN0UG9pbnQueSk7XG5cbiAgICAgICAgdmFyIG1ham9yMSA9IG1ham9yIC0gdGhpcy5kZXRlY3RSYWRpdXM7XG4gICAgICAgIHZhciBtaW5vcjEgPSBtaW5vciAtIHRoaXMuZGV0ZWN0UmFkaXVzO1xuICAgICAgICB2YXIgbWFqb3IyID0gbWFqb3IgKyB0aGlzLmRldGVjdFJhZGl1cztcbiAgICAgICAgdmFyIG1pbm9yMiA9IG1pbm9yICsgdGhpcy5kZXRlY3RSYWRpdXM7XG5cbiAgICAgICAgdmFyIGVxdWF0aW9uMSA9IChwb2ludC54IC0gY3gpICogKHBvaW50LnggLSBjeCkgLyAobWFqb3IxICogbWFqb3IxKSArIChwb2ludC55IC0gY3kpICogKHBvaW50LnkgLSBjeSkgLyAobWlub3IxICogbWlub3IxKTtcbiAgICAgICAgdmFyIGVxdWF0aW9uMiA9IChwb2ludC54IC0gY3gpICogKHBvaW50LnggLSBjeCkgLyAobWFqb3IyICogbWFqb3IyKSArIChwb2ludC55IC0gY3kpICogKHBvaW50LnkgLSBjeSkgLyAobWlub3IyICogbWlub3IyKTtcblxuICAgICAgICB2YXIgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjIoY3gsIGN5KTtcbiAgICAgICAgcG9pbnQuc3ViKGNlbnRlcik7XG4gICAgICAgIHBvaW50LnggKj0gbWlub3I7XG4gICAgICAgIHBvaW50LnkgKj0gbWFqb3I7XG4gICAgICAgIHZhciBhbmdsZSA9IHRoaXMuc25hcHBlci5hbmdsZVZlY3RvcjIocG9pbnQpO1xuXG4gICAgICAgIGlmIChlbmQgPiBNYXRoLlBJICogMikge1xuICAgICAgICAgICAgZW5kID0gTWF0aC5QSSAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXF1YXRpb24xID49IDEgJiYgZXF1YXRpb24yIDw9IDEpIHtcblxuICAgICAgICAgICAgaWYgKChlbmQgPiBzdGFydCAmJiBhbmdsZSA+PSBzdGFydCAmJiBhbmdsZSA8PSBlbmQpIHx8IChlbmQgPCBzdGFydCAmJiAoYW5nbGUgPj0gc3RhcnQgfHwgYW5nbGUgPD0gZW5kKSkpe1xuICAgICAgICAgICAgICAgIHZhciBhcmMgPSBjcmVhdGVFbGxpcHRpY2FsQXJjR2VvbWV0cnkoY3gsIGN5LCBtYWpvciwgbWlub3IsIHN0YXJ0LCBlbmQsIDUwKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxXaXRoUHJlY2lzaW9uKGVuZCAtIHN0YXJ0LCBNYXRoLlBJICogMikpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBhcmMudmVydGljZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFyYy5hcHBseU1hdHJpeDQobmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oMCwgMCwgaW50ZXJzZWN0UG9pbnQueikpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIGdlb21ldHJ5IGFuZCBzbmFwcGVkIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgc2FtZSB3YXkgaGVyZSBhcyBpbiBnZXRTbmFwUmVzdWx0UG9zaXRpb24oKS4gVGhpcyB3aWxsIGJlIHJlcGxhY2VkIGxhdGVyIGJ5IGEgbW9yZSBhY2N1cmF0ZSBzb2x1dGlvbi5cbiAgICAgICAgICAgICAgICBjb25zdCBuZWFyZXN0UG9pbnQgPSBNZWFzdXJlQ29tbW9uLm5lYXJlc3RWZXJ0ZXhJblZlcnRleFRvRWRnZShpbnRlcnNlY3RQb2ludCwgYXJjKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0ID0gVEhSRUUuVmVjdG9yMi5wcm90b3R5cGUuZGlzdGFuY2VUby5jYWxsKG5lYXJlc3RQb2ludCwgaW50ZXJzZWN0UG9pbnQpOyAvLyBvbmx5IGluIHgveVxuXG4gICAgICAgICAgICAgICAgLy8gQ29sbGVjdCBzbmFwIGNhbmRpZGF0ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IyKGN4LCBjeSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zbmFwQ2FuZGlkYXRlcy5wdXNoKG5ldyBTbmFwQ2FuZGlkYXRlKHZwSWQsIGRpc3QpLm1ha2VFbGxpcHRpY2FsQXJjKGNlbnRlciwgbWFqb3IsIG1pbm9yLCBzdGFydCwgZW5kKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUb2RvOiBVbmxpa2UgZm9yIGxpbmUtc2VnbWVudHMsIGFyY3MgYXJlIGN1cnJlbnRseSBjb2xsZWN0ZWQgYnkgXCJsYXN0IG9uZSB3aW5zXCIgcnVsZSBieSB0aGUgY29kZSBmb3Igc2luZ2xlLXNuYXBwaW5nLlxuICAgICAgICAgICAgICAgIC8vICAgICAgIFdlIHNob3VsZCBjb25zaWRlciB0aGUgZGlzdGFuY2UgaGVyZSBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgIHRoaXMuZWxsaXB0aWNhbEFyYyA9IGFyYztcbiAgICAgICAgICAgICAgICB0aGlzLmVsbGlwdGljYWxBcmNDZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMyhjeCwgY3ksIGludGVyc2VjdFBvaW50LnopO1xuXG4gICAgICAgICAgICAgICAgdGhpcy52cElkRWxsaXB0aWNhbCA9IHZwSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2V0cyB0aGUgbWF0cml4IHRvIGlkZW50aXR5IGlmIG1hdHJpeCBpcyBub3Qgc3VwcGxpZWQ7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RIUkVFLk1hdHJpeDR9IG1hdHJpeCAtIE1hdHJpeCB0byBzZXRcbiAgICAgKi9cbiAgICBHZW9tZXRyeUNhbGxiYWNrLnByb3RvdHlwZS5zZXRNYXRyaXggPSBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICAgIHRoaXMubWF0cml4ID0gbWF0cml4IHx8IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNuYXAgdG8gYSAyRCBtb2RlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgIGhpdFJlc3VsdCAtIGEgcmVzdWx0IG9mIGEgcmF5IGludGVyc2VjdGlvbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gICAgICBbb3B0aW9uc10gLSBPcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICBbb3B0aW9ucy5lbnVtU2VnbWVudHNdIC0gRW51bWVyYXRlcyBhbGwgc2VnbWVudHMgd2l0aGluIGEgZ2l2ZW4gYmJveCBpbiBtb2RlbC1zcGFjZS5cbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMuc25hcHBpbmcyRCA9IGZ1bmN0aW9uIChoaXRSZXN1bHQsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghaGl0UmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoaXRSZXN1bHQgaXMgYSByZXN1bHQgb2YgYSByYXkgaW50ZXJzZWN0aW9uLiBpdCBtYXkgY29udGFpbiB0aGUgZm9sbG93aW5nOlxuICAgICAgICBsZXQge1xuICAgICAgICAgICAgZGJJZCxcbiAgICAgICAgICAgIGZyYWdJZCxcbiAgICAgICAgICAgIGludGVyc2VjdFBvaW50LFxuICAgICAgICAgICAgbW9kZWwgPSBfdmlld2VyLm1vZGVsXG4gICAgICAgIH0gPSBoaXRSZXN1bHQ7XG5cbiAgICAgICAgaWYgKG1vZGVsLmlzM2QoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF9zbmFwUmVzdWx0Lm1vZGVsSWQgPSBoaXRSZXN1bHQubW9kZWwgPyBoaXRSZXN1bHQubW9kZWwuaWQgOiBudWxsO1xuICAgICAgICBfc25hcFJlc3VsdC5oYXNUb3BvbG9neSA9IGZhbHNlO1xuICAgICAgICBfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludCA9IGludGVyc2VjdFBvaW50O1xuXG4gICAgICAgIGxldCB0ciwgc2NhbGUgPSAxO1xuXG4gICAgICAgIC8vIFRoZSBtb2RlbCB0aGF0IHdlIGFyZSB0cnlpbmcgdG8gc25hcCBpcyAyRCwgYnV0IHRoZSB2aWV3ZXIgaXMgM0QuIEl0IG1lYW5zIHRoYXQgd2UgYXJlIGluIGh5cGVybW9kZWxpbmcgc2NlbmFyaW8hXG4gICAgICAgIC8vIEZvciB0aGF0LCB3ZSdsbCBuZWVkIHRvIGFwcGx5IHRoZSBpbnZlcnNlZCB0cmFuc2Zvcm0gb2YgdGhlIDJEIG1vZGVsIHRvIHRoZSBpbnRlcnNlY3QgcG9pbnQgZmlyc3QsIGluIG9yZGVyIHRvIGdldCBpdCBpbiBsb2NhbCBtb2RlbCBjb29yZHMuXG4gICAgICAgIGlmICghX3ZpZXdlci5pbXBsLmlzMmQpIHtcbiAgICAgICAgICAgIHRyID0gbW9kZWwuZ2V0TW9kZWxUb1ZpZXdlclRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHRyYW5zZm9ybSwgbW92ZSBwb2ludCB0byBvcmlnaW5hbCBsb2NhdGlvbiBpbiBzaGVldCAod2lsbCBiZSByZXN0b3JlZCBhdCB0aGUgZW5kKVxuICAgICAgICAgICAgaWYgKHRyKSB7XG4gICAgICAgICAgICAgICAgc2NhbGUgPSB0ci5nZXRNYXhTY2FsZU9uQXhpcygpO1xuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0LmludGVyc2VjdFBvaW50ID0gaW50ZXJzZWN0UG9pbnQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludC5hcHBseU1hdHJpeDQobW9kZWwuZ2V0SW52ZXJzZU1vZGVsVG9WaWV3ZXJUcmFuc2Zvcm0oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggb25lIHNob3VsZCBiZSBkcmF3bjogbGluZSwgY2lyY3VsYXIgYXJjIG9yIGVsbGlwdGljYWwgYXJjXG4gICAgICAgIC8vIFVzZSB0aGUgdW4tdHJhbnNmb3JtZWQgcG9pbnQsIGJ1dCBzY2FsZSBkb3duIHRoZSByYWRpdXMgYmVjYXVzZSB3ZSBhcmUgY29tcGFyaW5nIHdpdGggdGhlIHVuc2NhbGVkIGdlb21ldHJ5XG4gICAgICAgIF9zbmFwUmVzdWx0LnJhZGl1cyA9IHRoaXMuc2V0RGV0ZWN0UmFkaXVzKGludGVyc2VjdFBvaW50KSAvIHNjYWxlO1xuXG4gICAgICAgIC8vIEdlb21ldHJ5IHNuYXBwaW5nIGlzIG9ubHkgcG9zc2libGUgaWYgYSBmcmFnbWVudCBsaXN0IGlzIGF2YWlsYWJsZSB0byBvYnRhaW4gZ2VvbWV0cnkgcGVyIGZyYWdtZW50LlxuICAgICAgICB2YXIgc3VwcG9ydHNHZW9tU25hcHBpbmcgPSAobW9kZWwuZ2V0RnJhZ21lbnRMaXN0KCkhPW51bGwpO1xuICAgICAgICBpZiAoIXN1cHBvcnRzR2VvbVNuYXBwaW5nKSB7XG5cbiAgICAgICAgICAgIC8vIElmIG5vIHNuYXBwaW5nIGlzIGF2YWlsYWJsZSwganVzdCBhY2NlcHQgdGhlIGhpdHBvaW50IGFzIGEgdmVydGV4IGhpdC4gVGhpcyBhbGxvd3MgdG8gbWVhc3VyZVxuICAgICAgICAgICAgLy8gZGlzdGFuY2VzIGJldHdlZW4gYXJiaXRyYXJ5IHBvaW50cyBpbiByYXN0ZXJzLlxuICAgICAgICAgICAgX2lzU25hcHBlZCA9IHRydWU7XG4gICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfVkVSVEVYO1xuICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVZlcnRleCA9IGludGVyc2VjdFBvaW50OyAvLyBVc2UgdGhlIHVuLXRyYW5zZm9ybWVkIHBvaW50XG4gICAgICAgICAgICB0ciAmJl9zbmFwUmVzdWx0LmludGVyc2VjdFBvaW50LmFwcGx5TWF0cml4NCh0cik7IC8vIFJlc3RvcmUgdG8gb3JpZ2luYWwgbG9jYXRpb25cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGdjID0gbmV3IEdlb21ldHJ5Q2FsbGJhY2soX3ZpZXdlciwgdGhpcywgX3NuYXBSZXN1bHQucmFkaXVzKTtcblxuICAgICAgICAvLyBQZXJmb3JtcyAyRCBzbmFwcGluZyB0byBzZWdtZW50cyBiYXNlZCBvbiBhbiBlbnVtU2VnbWVudHMoKSBjYWxsYmFjaywgd2hpY2ggZW51bWVyYXRlcyBhbGwgc2VnbWVudHNcbiAgICAgICAgLy8gd2l0aGluIGluIGEgZ2l2ZW4gYmJveCBpbiBtb2RlbC1zcGFjZS5cbiAgICAgICAgaWYgKG9wdGlvbnMuZW51bVNlZ21lbnRzKSB7XG4gICAgICAgICAgICAvLyBlbnVtIGFsbCBzZWdtZW50cyB3aXRoaW4gdGhlIHNuYXBSYWRpdXMgYXJvdW5kIGludGVyc2VjdFBvaW50XG4gICAgICAgICAgICBjb25zdCBtaW54ID0gX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQueCAtIF9zbmFwUmVzdWx0LnJhZGl1cztcbiAgICAgICAgICAgIGNvbnN0IG1pbnkgPSBfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludC55IC0gX3NuYXBSZXN1bHQucmFkaXVzO1xuICAgICAgICAgICAgY29uc3QgbWF4eCA9IF9zbmFwUmVzdWx0LmludGVyc2VjdFBvaW50LnggKyBfc25hcFJlc3VsdC5yYWRpdXM7XG4gICAgICAgICAgICBjb25zdCBtYXh5ID0gX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQueSArIF9zbmFwUmVzdWx0LnJhZGl1cztcblxuICAgICAgICAgICAgb3B0aW9ucy5lbnVtU2VnbWVudHMobWlueCwgbWlueSwgbWF4eCwgbWF4eSwgZ2MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVndWxhciBzbmFwcGluZyAtIHNuYXAgdG8gdGhlIDJEIG1vZGVsJ3MgZ2VvbWV0cnkuXG4gICAgICAgICAgICB2YXIgZnJhZ0lkcyA9IGZyYWdJZDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmcmFnSWRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gTE1WLTYwODIgRG8gbm90IHJldHVybiBvdXQgaWYgdGhlIHNuYXAgdG8gcGl4ZWwgZmxhZyAoZnJlZSBtZWFzdXJlKSBpcyBlbmFibGVkLlxuICAgICAgICAgICAgICAgIGlmICghX3NuYXBUb1BpeGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJhZ0lkcyA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShmcmFnSWRzKSkge1xuICAgICAgICAgICAgICAgIGZyYWdJZHMgPSBbZnJhZ0lkc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBmcmFnSWRzLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc2ggPSBfdmlld2VyLmltcGwuZ2V0UmVuZGVyUHJveHkobW9kZWwsIGZyYWdJZHNbZmldKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzaD8uZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2Muc2V0TWF0cml4KG1lc2gubWF0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmJyID0gbmV3IFZlcnRleEJ1ZmZlclJlYWRlcihtZXNoLmdlb21ldHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgdmJyLmVudW1HZW9tc0Zvck9iamVjdChtb2RlbC5yZXZlcnNlTWFwRGJJZEZvcjJEKGRiSWQpLCBnYyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgbWF0cml4IGJhY2sgdG8gaWRlbnRpdHkgYWZ0ZXIgcHJvY2Vzc2luZyBhIG1lc2hcbiAgICAgICAgICAgICAgICAgICAgZ2Muc2V0TWF0cml4KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQgY29udGFpbnMgdGhlIHBvc3NpYmx5IHRyYW5zZm9ybWVkIHBvaW50XG4gICAgICAgIHRoaXMuZmluaXNoU25hcHBpbmcyRChnYywgX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQpO1xuXG4gICAgICAgIC8vIFNuYXAgdGhlIHVuc25hcHBlZCBwb2ludCBvbmx5IGlmIHRoZSBzbmFwcGluZyBmYWlsc1xuICAgICAgICBpZighX2lzU25hcHBlZCAmJiBfc25hcFRvUGl4ZWwpIHtcbiAgICAgICAgICAgIF9pc1NuYXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5SQVNURVJfUElYRUw7XG4gICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVmVydGV4ID0gX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgYXBwbHkgdGhlIHRyYW5zZm9ybSBtYXRyaXggb24gdGhlIHJlc3VsdHMsIHNvIHdlJ2xsIGdldCB0aGUgcmVzdWx0cyBpbiB0aGVpciBmaW5hbCB0cmFuc2Zvcm1lZCBwb3NpdGlvbi5cbiAgICAgICAgaWYgKHRyKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IF9zbmFwUmVzdWx0Lmdlb21FZGdlPy52ZXJ0aWNlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IF9zbmFwUmVzdWx0Lmdlb21FZGdlPy52ZXJ0aWNlc1sxXTtcblxuICAgICAgICAgICAgbGV0IHJlc3VsdHMgPSBbX3NuYXBSZXN1bHQuc25hcFBvaW50LCBfc25hcFJlc3VsdC5nZW9tVmVydGV4LCBfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludCwgX3NuYXBSZXN1bHQuY2lyY3VsYXJBcmNDZW50ZXIsXG4gICAgICAgICAgICAgICAgc3RhcnQsIGVuZF07XG4gICAgICAgICAgICAvLyBSZW1vdmUgdW5kZWZpbmVkIGFuZCBwb3NzaWJseSBzaGFyZWQgdmVjdG9yc1xuICAgICAgICAgICAgcmVzdWx0cyA9IFsuLi5uZXcgU2V0KHJlc3VsdHMuZmlsdGVyKG4gPT4gbikpXTtcbiAgICAgICAgICAgIHJlc3VsdHMuZm9yRWFjaChyZXMgPT4gcmVzLmFwcGx5TWF0cml4NCh0cikpO1xuICAgICAgICAgICAgaWYgKF9zbmFwUmVzdWx0LmNpcmN1bGFyQXJjUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuY2lyY3VsYXJBcmNSYWRpdXMgKj0gc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfc25hcFJlc3VsdC5yYWRpdXMgKj0gc2NhbGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQnkgZGVmYXVsdCwgc25hcHBlciBvbmx5IGNvbnNpZGVycyBtb2RlbCBnZW9tZXRyeSB0aGF0IGlzIHdyaXR0ZW4gdG8gSUQgYnVmZmVyLlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gcGVyZm9ybXMgdGhlIDJEIHNuYXBwaW5nIG9uIGEgc2V0IG9mIGdpdmVuIDJEIG1lc2hlcyBpbnN0ZWFkLiBJdCB3b3JrcyBzaW1pbGFyIHRvIHNuYXBwaW5nMkQoKSBidXRcbiAgICAvLyBlbnVtZXJhdGVzIHRoZSBnaXZlbiBtZXNoZXMgaW5zdGVhZCBvZiBnZXR0aW5nIHRoZW0gZnJvbSB0aGUgZnJhZ21lbnQgbGlzdC5cbiAgICAvL1xuICAgIC8vICBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9ICAgICAgICAgICAgICAgICBpbnRlcnNlY3RQb2ludCAtIGNsaWNrIHBvc2l0aW9uIGluIHdvcmxkLWNvb3Jkc1xuICAgIC8vICBAcGFyYW0ge2Z1bmN0aW9uKGRiSWQsIGxheWVySWQsIHZwSWQpfSBmaWx0ZXIgLSBEZWZpbmVzIHN1YnNldCBvZiBwcmltaXRpdmVzIHRvIGJlIGNvbnNpZGVyZWQuXG4gICAgLy8gIEBwYXJhbSB7VEhSRUUuTWVzaFtdfSAgICAgICAgICAgICAgICAgIG1lc2hlcyAtIFRoZSB0cmlhbmd1bGF0ZWQgMkQgc2hhcGVzIHRvIGJlIGNoZWNrZWQgZm9yIHNuYXBwaW5nXG4gICAgLy8gIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICAgICAgICAgICAgIFtkZXRlY3RSYWRpdXNdIC0gU2FtZSBjb29yZGluYXRlIHN5c3RlbSBhcyB0aGUgZ2l2ZW4gZ2VvbWV0cnkuIFJlcXVpcmVkIGlmIGdlb21ldHJ5IGlzIG5vdCBpbiB3b3JsZC1jb29yZHMuXG5cbiAgICB0aGlzLnNuYXBwaW5nMkRPdmVybGF5ID0gZnVuY3Rpb24oaW50ZXJzZWN0UG9pbnQsIG1lc2hlcywgZmlsdGVyLCBkZXRlY3RSYWRpdXMpIHtcbiAgICAgICAgX3NuYXBSZXN1bHQuaGFzVG9wb2xvZ3kgPSBmYWxzZTtcbiAgICAgICAgX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQgPSBpbnRlcnNlY3RQb2ludDtcbiAgICAgICAgX3NuYXBSZXN1bHQucmFkaXVzID0gZGV0ZWN0UmFkaXVzIHx8IHRoaXMuc2V0RGV0ZWN0UmFkaXVzKGludGVyc2VjdFBvaW50KTtcblxuICAgICAgICB2YXIgZ2MgPSBuZXcgR2VvbWV0cnlDYWxsYmFjayhfdmlld2VyLCB0aGlzLCBfc25hcFJlc3VsdC5yYWRpdXMpO1xuXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxtZXNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXNoID0gbWVzaGVzW2ldO1xuICAgICAgICAgICAgdmFyIHZiciA9IG5ldyBWZXJ0ZXhCdWZmZXJSZWFkZXIobWVzaC5nZW9tZXRyeSk7XG4gICAgICAgICAgICB2YnIuZW51bUdlb21zKGZpbHRlciwgZ2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maW5pc2hTbmFwcGluZzJEKGdjLCBpbnRlcnNlY3RQb2ludCk7XG4gICAgfTtcblxuICAgIC8vIEZpbmlzaCAyRCBzbmFwcGluZyBvcGVyYXRpb24gLSBhc3N1bWluZyB0aGF0IGFsbCBjYW5kaWRhdGUgZ2VvbWV0cnkgZm9yIHNuYXBwaW5nIGhhcyBiZWVuIHByb2Nlc3NlZCBieSB0aGUgZ2VvbWV0cnlDYWxsYmFjayBnYyBhbHJlYWR5LlxuICAgIHRoaXMuZmluaXNoU25hcHBpbmcyRCA9IGZ1bmN0aW9uKGdjLCBpbnRlcnNlY3RQb2ludCkge1xuXG4gICAgICAgIC8vIFdoZW4gcmVzdHJpY3RpbmcgdG8gYSBzaW5nbGUgdmlld3BvcnQsIGV4Y2x1ZGUgY2FuZGlkYXRlcyBvZiBhbGwgb3RoZXIgdmlld3BvcnRzXG4gICAgICAgIGlmIChfZm9yY2VkVnBJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaXNTYW1lVmlld3BvcnQgPSBjID0+IChjLnZpZXdwb3J0SWQgPT09IF9mb3JjZWRWcElkKTtcbiAgICAgICAgICAgIGdjLnNuYXBDYW5kaWRhdGVzID0gZ2Muc25hcENhbmRpZGF0ZXMuZmlsdGVyKGlzU2FtZVZpZXdwb3J0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGNhbiBzbmFwIHRvIGFuIGludGVyc2VjdGlvbiBvZiB0d28gY2xvc2Ugc2VnbWVudHNcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0U25hcCA9IGZpbmRJbnRlcnNlY3Rpb25TbmFwKGdjLnNuYXBDYW5kaWRhdGVzLCBpbnRlcnNlY3RQb2ludCwgZ2MuZGV0ZWN0UmFkaXVzKTtcbiAgICAgICAgaWYgKGludGVyc2VjdFNuYXApIHtcbiAgICAgICAgICAgIF9zbmFwUmVzdWx0LnZpZXdwb3J0SW5kZXgyZCA9IGludGVyc2VjdFNuYXAudmlld3BvcnRJZDtcbiAgICAgICAgICAgIF9zbmFwUmVzdWx0LnNuYXBQb2ludCA9IGludGVyc2VjdFNuYXAuc25hcFBvaW50O1xuICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5TTkFQX0lOVEVSU0VDVElPTjtcbiAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21WZXJ0ZXggPSBpbnRlcnNlY3RTbmFwLnNuYXBQb2ludDtcbiAgICAgICAgICAgIF9pc1NuYXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdjLmNpcmN1bGFyQXJjKSB7XG5cbiAgICAgICAgICAgIF9zbmFwUmVzdWx0LnZpZXdwb3J0SW5kZXgyZCA9IGdjLnZwSWRDaXJjdWxhcjtcblxuICAgICAgICAgICAgX3NuYXBSZXN1bHQuc25hcFBvaW50ID0gZ2Muc25hcFBvaW50O1xuXG4gICAgICAgICAgICAvLyBPbmx5IHNuYXAgdGhlIGdlb21ldHJpZXMgd2hpY2ggYmVsb25nIHRvIHRoZSBzYW1lIHZpZXdwb3J0IGFzIHRoZSBmaXJzdCBzZWxlY3Rpb25cbiAgICAgICAgICAgIGlmIChfZm9yY2VkVnBJZCAhPT0gbnVsbCAmJiBfZm9yY2VkVnBJZCAhPT0gX3NuYXBSZXN1bHQudmlld3BvcnRJbmRleDJkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnYy5jaXJjdWxhckFyYy52ZXJ0aWNlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGdjLmNpcmN1bGFyQXJjLnZlcnRpY2VzW2djLmNpcmN1bGFyQXJjLnZlcnRpY2VzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhzdGFydCkgPCBfc25hcFJlc3VsdC5yYWRpdXMpIHtcblxuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21WZXJ0ZXggPSBzdGFydDtcbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfVkVSVEVYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhlbmQpIDwgX3NuYXBSZXN1bHQucmFkaXVzKSB7XG5cbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVmVydGV4ID0gZW5kO1xuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9WRVJURVg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMubGluZVN0cmlwVG9QaWVjZXMoZ2MuY2lyY3VsYXJBcmMpO1xuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21FZGdlID0gZ2MuY2lyY3VsYXJBcmM7XG4gICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuY2lyY3VsYXJBcmNDZW50ZXIgPSBnYy5jaXJjdWxhckFyY0NlbnRlcjtcbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5jaXJjdWxhckFyY1JhZGl1cyA9IGdjLmNpcmN1bGFyQXJjUmFkaXVzO1xuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9DSVJDVUxBUkFSQztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2lzU25hcHBlZCA9IHRydWU7XG5cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdjLmVsbGlwdGljYWxBcmMpIHtcblxuICAgICAgICAgICAgX3NuYXBSZXN1bHQudmlld3BvcnRJbmRleDJkID0gZ2MudnBJZEVsbGlwdGljYWw7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgc25hcCB0aGUgZ2VvbWV0cmllcyB3aGljaCBiZWxvbmcgdG8gdGhlIHNhbWUgdmlld3BvcnQgYXMgdGhlIGZpcnN0IHNlbGVjdGlvblxuICAgICAgICAgICAgaWYgKF9mb3JjZWRWcElkICE9PSBudWxsICYmIF9mb3JjZWRWcElkICE9PSBfc25hcFJlc3VsdC52aWV3cG9ydEluZGV4MmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGdjLmVsbGlwdGljYWxBcmMudmVydGljZXNbMF07XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBnYy5lbGxpcHRpY2FsQXJjLnZlcnRpY2VzW2djLmVsbGlwdGljYWxBcmMudmVydGljZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhzdGFydCkgPCBfc25hcFJlc3VsdC5yYWRpdXMpIHtcblxuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21WZXJ0ZXggPSBzdGFydDtcbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfVkVSVEVYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhlbmQpIDwgX3NuYXBSZXN1bHQucmFkaXVzKSB7XG5cbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVmVydGV4ID0gZW5kO1xuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9WRVJURVg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMubGluZVN0cmlwVG9QaWVjZXMoZ2MuZWxsaXB0aWNhbEFyYyk7XG4gICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbUVkZ2UgPSBnYy5lbGxpcHRpY2FsQXJjO1xuICAgICAgICAgICAgICAgIC8vIEJlZm9yZSB3ZSBoYXZlIG1lYXN1cmUgZGVzaWduIGZvciBlbGxpcHRpY2FsIGFyYywgbWVhc3VyZSB0aGUgY2VudGVyIGZvciBub3dcbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5jaXJjdWxhckFyY0NlbnRlciA9IGdjLmVsbGlwdGljYWxBcmNDZW50ZXI7XG4gICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuY2lyY3VsYXJBcmNSYWRpdXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9DSVJDVUxBUkFSQztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2lzU25hcHBlZCA9IHRydWU7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZ2MubGluZUdlb20gaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSAmJiBnYy5saW5lR2VvbS52ZXJ0aWNlcy5sZW5ndGgpIHx8XG4gICAgICAgICAgICAoZ2MubGluZUdlb20uZ2V0QXR0cmlidXRlICYmIGdjLmxpbmVHZW9tLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKS5jb3VudCkpIHtcblxuICAgICAgICAgICAgX3NuYXBSZXN1bHQudmlld3BvcnRJbmRleDJkID0gZ2MudnBJZExpbmU7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgc25hcCB0aGUgZ2VvbWV0cmllcyB3aGljaCBiZWxvbmcgdG8gdGhlIHNhbWUgdmlld3BvcnQgYXMgdGhlIGZpcnN0IHNlbGVjdGlvblxuICAgICAgICAgICAgaWYgKF9mb3JjZWRWcElkICE9PSBudWxsICYmIF9mb3JjZWRWcElkICE9PSBfc25hcFJlc3VsdC52aWV3cG9ydEluZGV4MmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBBbHdheXMgZXhwb3NlIGVkZ2Ugc2VnbWVudCAtIG5vIG1hdHRlciB3aGV0aGVyIHdlIHNuYXAgdG8gdGhlIGVkZ2Ugb3Igb25lIG9mIGl0cyB2ZXJ0aWNlcy5cbiAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIGNvbWJpbmUgaXQgd2l0aCBvdGhlciBzbmFwIGNvbnN0cmFpbnRzIGxhdGVyIC0gYXMgZG9uZSBieSBFZGl0MkQuXG4gICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tRWRnZSA9IGdjLmxpbmVHZW9tO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnYy5saW5lR2VvbS52ZXJ0aWNlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGdjLmxpbmVHZW9tLnZlcnRpY2VzWzFdO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrdXBNb2RlKSB7ICAvLyBNYXJrdXAgbW9kZVxuICAgICAgICAgICAgICAgIHZhciBtaWQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgICAgIG1pZC5hZGRWZWN0b3JzKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIG1pZC5kaXZpZGVTY2FsYXIoMik7XG4gICAgICAgICAgICAgICAgdmFyIG1kID0gaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhtaWQpO1xuICAgICAgICAgICAgICAgIHZhciBzZCA9IGludGVyc2VjdFBvaW50LmRpc3RhbmNlVG8oc3RhcnQpO1xuICAgICAgICAgICAgICAgIHZhciBlZCA9IGludGVyc2VjdFBvaW50LmRpc3RhbmNlVG8oZW5kKTtcblxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGl0IGZvciBzbmFwcGluZyB0byBwYXJhbGxlbC9wZXJwZW5kaWN1bGFyIG9mIHVuZGVybHlpbmcgdmVjdG9yc1xuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21FZGdlID0gZ2MubGluZUdlb207XG5cbiAgICAgICAgICAgICAgICBpZiAobWQgPCBfc25hcFJlc3VsdC5yYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVZlcnRleCA9IG1pZDtcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5TTkFQX1ZFUlRFWDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2QgPCBfc25hcFJlc3VsdC5yYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVZlcnRleCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfVkVSVEVYO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlZCA8IF9zbmFwUmVzdWx0LnJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVmVydGV4ID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfVkVSVEVYO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5TTkFQX0VER0U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2lyY2xlIGNlbnRlclxuICAgICAgICAgICAgICAgIGlmIChzdGFydC5kaXN0YW5jZVRvKGVuZCkgPCBFUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9DSVJDTEVfQ0VOVEVSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAgLy8gTWVhc3VyZSBtb2RlXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdFBvaW50LmRpc3RhbmNlVG8oc3RhcnQpIDwgX3NuYXBSZXN1bHQucmFkaXVzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0LmRpc3RhbmNlVG8oZW5kKSA8IEVQU0lMT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9DSVJDTEVfQ0VOVEVSO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5TTkFQX1ZFUlRFWDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21WZXJ0ZXggPSBzdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKF9vcHRpb25zLmZvcmNlU25hcFZlcnRpY2VzIHx8IChpbnRlcnNlY3RQb2ludC5kaXN0YW5jZVRvKGVuZCkgPCBfc25hcFJlc3VsdC5yYWRpdXMpKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21WZXJ0ZXggPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9WRVJURVg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfRURHRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9pc1NuYXBwZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc25hcHBpbmdSYXN0ZXJQaXhlbCA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGludGVyc2VjdFBvaW50ID0gcmVzdWx0LmludGVyc2VjdFBvaW50O1xuICAgICAgICBfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludCA9IGludGVyc2VjdFBvaW50O1xuICAgICAgICBfc25hcFJlc3VsdC5oYXNUb3BvbG9neSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIERldGVybWluZSB3aGljaCBvbmUgc2hvdWxkIGJlIGRyYXduOiBsaW5lLCBjaXJjdWxhciBhcmMgb3IgZWxsaXB0aWNhbCBhcmNcbiAgICAgICAgX3NuYXBSZXN1bHQucmFkaXVzID0gdGhpcy5zZXREZXRlY3RSYWRpdXMoaW50ZXJzZWN0UG9pbnQpO1xuICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlJBU1RFUl9QSVhFTDtcbiAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVZlcnRleCA9IGludGVyc2VjdFBvaW50O1xuICAgICAgICBfaXNTbmFwcGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdGhpcy5zbmFwTWlkcG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgX3NuYXBSZXN1bHQuaXNNaWRwb2ludCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNuYXAgbWlkcG9pbnQgZm9yIGVkZ2VcbiAgICAgICAgaWYgKF9pc1NuYXBwZWQpIHtcbiAgICAgICAgICAgIGlmIChfc25hcFJlc3VsdC5nZW9tVHlwZSA9PT0gU25hcFR5cGUuU05BUF9FREdFKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWRnZSA9IF9zbmFwUmVzdWx0Lmdlb21FZGdlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHAxID0gZWRnZS52ZXJ0aWNlc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwMiA9IGVkZ2UudmVydGljZXNbMV07XG5cbiAgICAgICAgICAgICAgICB2YXIgbWlkcG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygocDEueCArIHAyLngpIC8gMiwgKHAxLnkgKyBwMi55KSAvIDIsIChwMS56ICsgcDIueikgLyAyKTtcblxuICAgICAgICAgICAgICAgIHZhciBjdXRQbGFuZXMgPSBfdmlld2VyLmltcGwuZ2V0QWxsQ3V0UGxhbmVzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1dFBsYW5lcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpPGN1dFBsYW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IGN1dFBsYW5lc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvdCA9IG1pZHBvaW50LngqcC54ICsgbWlkcG9pbnQueSpwLnkgKyBtaWRwb2ludC56KnAueiArIHAudztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb3Q+MWUtNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc2NhcmQgbWlkcG9pbnQgaWYgY2xpcHBlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludC5kaXN0YW5jZVRvKG1pZHBvaW50KSA8IDIgKiBfc25hcFJlc3VsdC5yYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVZlcnRleCA9IG1pZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfTUlEUE9JTlQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc2V0UGVycGVuZGljdWxhciA9IGZ1bmN0aW9uKGlzUGVycGVuZGljdWxhcikge1xuICAgICAgICBfc25hcFJlc3VsdC5pc1BlcnBlbmRpY3VsYXIgPSBpc1BlcnBlbmRpY3VsYXI7XG4gICAgfTtcblxuICAgIHRoaXMubGluZVN0cmlwVG9QaWVjZXMgPSBmdW5jdGlvbihnZW9tKSB7XG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gZ2VvbS52ZXJ0aWNlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IHZlcnRpY2VzLmxlbmd0aCAtIDI7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZlcnRpY2VzLnNwbGljZShpLCAwLCB2ZXJ0aWNlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5zZXREZXRlY3RSYWRpdXMgPSBmdW5jdGlvbihwb2ludCkge1xuXG4gICAgICAgIHZhciBuYXZhcGkgPSBfdmlld2VyLm5hdmlnYXRpb247XG4gICAgICAgIHZhciBjYW1lcmEgPSBuYXZhcGkuZ2V0Q2FtZXJhKCk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG5hdmFwaS5nZXRQb3NpdGlvbigpO1xuXG4gICAgICAgIHZhciBwID0gcG9pbnQuY2xvbmUoKTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSBjYW1lcmEuaXNQZXJzcGVjdGl2ZSA/IHAuc3ViKHBvc2l0aW9uKS5sZW5ndGgoKVxuICAgICAgICAgICAgOiBuYXZhcGkuZ2V0RXllVmVjdG9yKCkubGVuZ3RoKCk7XG5cbiAgICAgICAgdmFyIGZvdiA9IG5hdmFwaS5nZXRWZXJ0aWNhbEZvdigpO1xuICAgICAgICB2YXIgd29ybGRIZWlnaHQgPSAyLjAgKiBkaXN0YW5jZSAqIE1hdGgudGFuKFRIUkVFLk1hdGguZGVnVG9SYWQoZm92ICogMC41KSk7XG5cbiAgICAgICAgdmFyIHZpZXdwb3J0ID0gbmF2YXBpLmdldFNjcmVlblZpZXdwb3J0KCk7XG4gICAgICAgIHZhciBfd2luZG93ID0gdGhpcy5nZXRXaW5kb3coKTtcbiAgICAgICAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSBfd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMuZGV0ZWN0UmFkaXVzSW5QaXhlbHMgKiB3b3JsZEhlaWdodCAvICh2aWV3cG9ydC5oZWlnaHQgKiBkZXZpY2VQaXhlbFJhdGlvKTtcblxuICAgICAgICByZXR1cm4gcmFkaXVzO1xuICAgIH07XG5cbiAgICB0aGlzLmhhbmRsZUJ1dHRvbkRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmhhbmRsZUJ1dHRvblVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgaWYgKF9pc0RyYWdnaW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUoe1xuICAgICAgICAgICAgeDogZXZlbnQuY2FudmFzWCxcbiAgICAgICAgICAgIHk6IGV2ZW50LmNhbnZhc1lcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmhhbmRsZVNpbmdsZVRhcCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlTW91c2VNb3ZlKGV2ZW50KTtcbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVQcmVzc0hvbGQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICBpZiAoYXYuaXNNb2JpbGVEZXZpY2UoKSkge1xuICAgICAgICAgICAgc3dpdGNoKCBldmVudC50eXBlIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicHJlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgX2lzUHJlc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTW91c2VNb3ZlKHt4OiBldmVudC5jYW52YXNYLCB5OiBldmVudC5jYW52YXNZfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcInByZXNzdXBcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk1vdXNlTW92ZSh7eDogZXZlbnQuY2FudmFzWCwgeTogZXZlbnQuY2FudmFzWX0pO1xuICAgICAgICAgICAgICAgICAgICBfaXNQcmVzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVHZXN0dXJlID0gZnVuY3Rpb24oIGV2ZW50IClcbiAgICB7XG4gICAgICAgIGlmIChhdi5pc01vYmlsZURldmljZSgpKSB7XG4gICAgICAgICAgICBpZiAoX2lzUHJlc3NpbmcpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2goIGV2ZW50LnR5cGUgKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRyYWdzdGFydFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZHJhZ21vdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Nb3VzZU1vdmUoe3g6IGV2ZW50LmNhbnZhc1gsIHk6IGV2ZW50LmNhbnZhc1l9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkcmFnZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTW91c2VNb3ZlKHt4OiBldmVudC5jYW52YXNYLCB5OiBldmVudC5jYW52YXNZfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXNQcmVzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBpbmNoc3RhcnRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBpbmNobW92ZVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicGluY2hlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciB0byBtb3VzZSBtb3ZlIGV2ZW50cywgdXNlZCB0byBzbmFwIGluIG1hcmt1cCBlZGl0IG1vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW91c2VQb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKG1vdXNlUG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25Nb3VzZU1vdmUobW91c2VQb3NpdGlvbik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgdG8gbW91c2UgbW92ZSBldmVudHMsIHVzZWQgdG8gc25hcCBpbiBtYXJrdXAgZWRpdCBtb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vdXNlUG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMub25Nb3VzZU1vdmUgPSBmdW5jdGlvbihtb3VzZVBvc2l0aW9uKSB7XG5cbiAgICAgICAgdGhpcy5jbGVhclNuYXBwZWQoKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gX3ZpZXdlci5pbXBsLnNuYXBwaW5nSGl0VGVzdChtb3VzZVBvc2l0aW9uLngsIG1vdXNlUG9zaXRpb24ueSwgZmFsc2UpO1xuXG4gICAgICAgIGlmICghcmVzdWx0ICYmIF9zbmFwVG9QaXhlbCkge1xuICAgICAgICAgICAgdmFyIHZwVmVjID0gX3ZpZXdlci5pbXBsLmNsaWVudFRvVmlld3BvcnQobW91c2VQb3NpdGlvbi54LCBtb3VzZVBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgbGV0IHBvaW50ID0gX3ZpZXdlci5pbXBsLmludGVyc2VjdEdyb3VuZFZpZXdwb3J0KHZwVmVjKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHsgaW50ZXJzZWN0UG9pbnQgOiBwb2ludCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC5pbnRlcnNlY3RQb2ludClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBjb25zdCBpc0xlYWZsZXQgPSByZXN1bHQubW9kZWw/LmlzTGVhZmxldCgpIHx8IChfdmlld2VyLmltcGwuaXMyZCAmJiBfdmlld2VyLm1vZGVsPy5pc0xlYWZsZXQoKSk7XG4gICAgICAgIC8vIDNEIFNuYXBwaW5nXG4gICAgICAgIGlmIChyZXN1bHQuZmFjZSkge1xuICAgICAgICAgICAgdGhpcy5zbmFwcGluZzNEKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMkQgU25hcHBpbmdcbiAgICAgICAgZWxzZSBpZiAoKHJlc3VsdC5kYklkIHx8IHJlc3VsdC5kYklkID09PSAwKSAmJiAhaXNMZWFmbGV0KSB7XG4gICAgICAgICAgICB0aGlzLnNuYXBwaW5nMkQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQaXhlbCBTbmFwcGluZ1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlzUGl4ZWxTbmFwID0gX3NuYXBUb1BpeGVsIHx8IGlzTGVhZmxldDtcbiAgICAgICAgICAgIGlmIChpc1BpeGVsU25hcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc25hcHBpbmdSYXN0ZXJQaXhlbChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zbmFwTWlkcG9pbnQoKTtcblxuICAgICAgICBpZiAoX3NuYXBGaWx0ZXIgJiYgIV9zbmFwRmlsdGVyKF9zbmFwUmVzdWx0KSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclNuYXBwZWQoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5cbmF2Lkdsb2JhbE1hbmFnZXJNaXhpbi5jYWxsKFNuYXBwZXIucHJvdG90eXBlKTtcbiJdLCJuYW1lcyI6WyJOdWxsU25hcHBlckluZGljYXRvciIsIlNuYXBwZXJJbmRpY2F0b3IiLCJuZWFyZXN0UG9pbnRPbkNpcmN1bGFyQXJjIiwiaW50ZXJzZWN0TGluZXMiLCJNZWFzdXJlQ29tbW9uIiwiQXV0b2Rlc2siLCJWaWV3aW5nIiwiRVBTSUxPTiIsIlNuYXBUeXBlIiwiU25hcFJlc3VsdCIsIlNOQVBfUFJFQ0lTSU9OIiwiYXYiLCJhdnAiLCJQcml2YXRlIiwiVmVydGV4QnVmZmVyUmVhZGVyIiwiaXNFcXVhbFdpdGhQcmVjaXNpb24iLCJhIiwiYiIsIk1hdGgiLCJhYnMiLCJpc0VxdWFsVmVjdG9yc1dpdGhQcmVjaXNpb24iLCJ2MSIsInYyIiwieCIsInkiLCJ6IiwiaXNJbnZlcnNlVmVjdG9yc1dpdGhQcmVjaXNpb24iLCJkaXN0YW5jZVBvaW50VG9MaW5lIiwicG9pbnQiLCJsaW5lU3RhcnQiLCJsaW5lRW5kIiwiZXF1YWxzIiwiZGlzdGFuY2VUbyIsIlgwIiwiVEhSRUUiLCJWZWN0b3IzIiwiWDEiLCJkaXN0YW5jZSIsInBhcmFtIiwic3ViVmVjdG9ycyIsImRvdCIsImNyb3NzIiwic3FydCIsIlNuYXBDYW5kaWRhdGVUeXBlIiwiVW5rbm93biIsIkxpbmUiLCJDaXJjdWxhckFyYyIsIkVsbGlwdGljYWxBcmMiLCJTbmFwQ2FuZGlkYXRlIiwiY29uc3RydWN0b3IiLCJ2aWV3cG9ydElkIiwidHlwZSIsInJhZGl1cyIsInJhZGl1c1giLCJyYWRpdXNZIiwiY2VudGVyIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiZnJvbUxpbmUiLCJwMSIsInAyIiwiY2xvbmUiLCJmcm9tQ2lyY3VsYXJBcmMiLCJzdGFydCIsImVuZCIsImZyb21FbGxpcHRpY2FsQXJjIiwiaXNMaW5lIiwiaXNDaXJjdWxhckFyYyIsIkNpcnVsYXJBcmMiLCJpc0VsbGlwdGljYWxBcmMiLCJnZXRJbnRlcnNlY3Rpb24iLCJvdGhlciIsIm9wdGlvbmFsVGFyZ2V0IiwiZmluZEludGVyc2VjdGlvblNuYXAiLCJjYW5kaWRhdGVzIiwiaW50ZXJzZWN0UG9pbnQiLCJzbmFwUmFkaXVzIiwiYnlEaXN0YW5jZSIsImNhIiwiY2IiLCJzb3J0IiwibGVuZ3RoIiwicmVzdWx0Iiwic25hcFBvaW50IiwiZmlyc3QiLCJpIiwic2Vjb25kIiwiZm91bmQiLCJkaXN0IiwiVmVjdG9yMiIsInByb3RvdHlwZSIsImNhbGwiLCJTbmFwcGVyIiwidmlld2VyIiwib3B0aW9ucyIsIl9zbmFwUmVzdWx0IiwiX3ZpZXdlciIsInNldEdsb2JhbE1hbmFnZXIiLCJnbG9iYWxNYW5hZ2VyIiwiX29wdGlvbnMiLCJfbmFtZXMiLCJtYXJrdXBNb2RlIiwidG9vbE5hbWUiLCJfcHJpb3JpdHkiLCJfYWN0aXZlIiwiX2Rpc3RhbmNlVG9FZGdlIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiX2Rpc3RhbmNlVG9WZXJ0ZXgiLCJfaXNEcmFnZ2luZyIsIl9pc1ByZXNzaW5nIiwiX2lzU25hcHBlZCIsIl9mb3JjZWRWcElkIiwiX3NuYXBUb1BpeGVsIiwiX3NuYXBGaWx0ZXIiLCJpbmRpY2F0b3IiLCJyZW5kZXJTbmFwcGVkR2VvbWV0cnkiLCJyZW5kZXJTbmFwcGVkVG9wb2xvZ3kiLCJkZXRlY3RSYWRpdXNJblBpeGVscyIsImlzTW9iaWxlRGV2aWNlIiwiaXNBY3RpdmUiLCJnZXROYW1lcyIsImdldE5hbWUiLCJnZXRQcmlvcml0eSIsImFjdGl2YXRlIiwiaXNOdWxsIiwiZGVhY3RpdmF0ZSIsImRlc3Ryb3kiLCJjb3B5UmVzdWx0cyIsImRlc3RpbnkiLCJjb3B5VG8iLCJnZXRFZGdlIiwiZ2VvbUVkZ2UiLCJnZXRWZXJ0ZXgiLCJnZW9tVmVydGV4IiwiZ2V0R2VvbWV0cnkiLCJnZXRHZW9tZXRyeVR5cGUiLCJnZW9tVHlwZSIsImdldEludGVyc2VjdFBvaW50IiwiZ2V0U25hcFJlc3VsdCIsImlzU25hcHBlZCIsImNsZWFyU25hcHBlZCIsImNsZWFyIiwic2V0Vmlld3BvcnRJZCIsInZwSWQiLCJzZXRTbmFwVG9QaXhlbCIsImVuYWJsZSIsImdldFNuYXBUb1BpeGVsIiwic2V0U25hcFRvQXJjIiwic25hcFRvQXJjIiwiZ2V0U25hcFRvQXJjIiwic2V0QXJjIiwiaXNBcmMiLCJnZXRBcmMiLCJzZXRTbmFwRmlsdGVyIiwiZmlsdGVyIiwic25hcHBpbmczRCIsInNuYXBOb2RlIiwiZGJJZCIsIm1vZGVsSWQiLCJtb2RlbCIsImlkIiwiZmFjZSIsImZyYWdJZCIsInVuZGVmaW5lZCIsIm9iamVjdCIsIk1lc2giLCJtZXNoU25hcHBpbmciLCJmcmFnSWRzIiwiaGFzVG9wb2xvZ3kiLCJzbmFwcGluZzNEd2l0aFRvcG9sb2d5Iiwic25hcHBpbmczRHRvTWVzaCIsIm1ha2VSZWFkVmVydGV4RnVuYyIsImdlb21ldHJ5IiwiYXR0cmlidXRlcyIsInBvc2l0aW9ucyIsInN0cmlkZSIsInBvZmZzZXQiLCJ2YmxheW91dCIsInBvc2l0aW9uIiwib2Zmc2V0IiwidmIiLCJhcnJheSIsInZic3RyaWRlIiwiaWR4IiwidiIsInAiLCJzZXQiLCJnZXREYXRhIiwiaW5zdGFuY2VUcmVlIiwiZW51bU5vZGVGcmFnbWVudHMiLCJwdXNoIiwiZ2VvbUZhY2UiLCJmaSIsIl9tb2RlbCRnZXRGcmFnbWVudExpcyIsIl9tb2RlbCRnZXRGcmFnbWVudExpczIiLCJtYXRyaXhXb3JsZCIsIk1hdHJpeDQiLCJnZXRGcmFnbWVudExpc3QiLCJnZXRXb3JsZE1hdHJpeCIsInRvcG9JbmRleCIsImdldFRvcG9JbmRleCIsInRvcG9sb2d5IiwiZ2V0VG9wb2xvZ3kiLCJmYWNlc1RvcG9sb2d5IiwiZmFjZXMiLCJlZGdlc1RvcG9sb2d5IiwiZWRnZXMiLCJmYWNlU25hcHBpbmdXaXRoVG9wb2xvZ3kiLCJub3JtYWxNYXRyaXgiLCJNYXRyaXgzIiwiZ2V0Tm9ybWFsTWF0cml4IiwiZmFjZU5vcm1hbCIsIm5vcm1hbCIsImFwcGx5TWF0cml4MyIsIm5vcm1hbGl6ZSIsImVkZ2VTbmFwcGluZ1dpdGhUb3BvbG9neSIsInZlcnRleFNuYXBwaW5nV2l0aFRvcG9sb2d5Iiwic2V0RGV0ZWN0UmFkaXVzIiwiZm9yY2VTbmFwVmVydGljZXMiLCJTTkFQX1ZFUlRFWCIsImZvcmNlU25hcEVkZ2VzIiwiZWRnZUlzQ2lyY2xlIiwiY2lyY3VsYXJBcmNDZW50ZXIiLCJjaXJjdWxhckFyY1JhZGl1cyIsInZlcnRpY2VzIiwiU05BUF9DSVJDVUxBUkFSQyIsImVkZ2VJc0N1cnZlZCIsIlNOQVBfQ1VSVkVERURHRSIsIlNOQVBfRURHRSIsImZhY2VJc0N1cnZlZCIsIlNOQVBfQ1VSVkVERkFDRSIsIlNOQVBfRkFDRSIsIl9yZWYiLCJpc0xpbmVzIiwiaXNXaWRlTGluZXMiLCJleHRyYWN0TGluZUdlb21ldHJ5IiwiYXBwbHlNYXRyaXg0IiwidmVydGV4U25hcHBpbmciLCJGYWNlMyIsImZhY2VTbmFwcGluZyIsImVkZ2VTbmFwcGluZyIsIl9yZWYyIiwidkEiLCJ2QiIsInZDIiwiZ2VvbSIsIkdlb21ldHJ5IiwiaW5kZXgiLCJpbmRleExpc3QiLCJmYWNlSWQiLCJqIiwiYyIsInJlYWRWZXJ0ZXgiLCJ2SW5kZXgiLCJpbmRpY2VzIiwiaWIiLCJvZmZzZXRzIiwiZ3JvdXBzIiwiY291bnQiLCJ2YSIsIm9pIiwiVHJpYW5nbGUiLCJnZXROb3JtYWwiLCJnZXRUcmlhbmdsZXNPblNhbWVGYWNlIiwicmVhZFZlcnRleENCIiwiZmFjZVZlcnRleDEiLCJmYWNlVmVydGV4MiIsImZhY2VWZXJ0ZXgzIiwiaW50ZXJzZWN0RmFjZSIsInByZWNpc2lvblBvaW50cyIsInByZWNpc2lvbiIsInBvdyIsInRyaWFuZ2xlc0FyciIsImVkZ2VzTWFwIiwiZmlyc3RUcmlhbmdsZSIsImtleXMiLCJyb3VuZCIsInRyaWFuZ2xlIiwia2V5MSIsImtleTIiLCJkZWZhdWx0RWRnZSIsImVkZ2UiLCJ0cmlhbmdsZXMiLCJxdWV1ZSIsInZpc2l0ZWQiLCJTZXQiLCJjb25uZWN0ZWRGYWNlcyIsImN1cnJlbnRGYWNlIiwic2hpZnQiLCJoYXMiLCJhZGQiLCJmb3JFYWNoIiwidCIsImZpbmFsVmVydGljZXMiLCJmYWNlSWR4IiwiX3JlZjMiLCJlZGdlR2VvbSIsIm1pbkRpc3RUb3BvSW5kZXgiLCJtaW5EaXN0IiwiayIsInZLMCIsInZLMSIsInZlcnRpY2VzTGVuZ3RoIiwiaXNFZGdlXzEyIiwiaXNFZGdlXzEzIiwiaXNFZGdlXzIzIiwicGkwIiwicGkxIiwicGkyIiwicGowIiwicGoxIiwicGoyIiwiZWRnZVZlcnRpY2VzIiwibWluRGlzdEluZGV4IiwibGluZUdlb20iLCJnZXRDb25uZWN0ZWRMaW5lU2VnbWVudHNPblNhbWVMaW5lIiwic2xpY2UiLCJ2Q291bnQiLCJWMCIsIlYxIiwiY2kiLCJzcGxpY2UiLCJkaXN0MSIsImRpc3QyIiwicHQiLCJkaXZpZGVTY2FsYXIiLCJWMiIsImZOMSIsInZBMSIsImZOMiIsInZBMiIsImFuZ2xlVmVjdG9yMiIsInZlY3RvciIsImF0YW4iLCJQSSIsImNyZWF0ZUVsbGlwdGljYWxBcmNHZW9tZXRyeSIsImN4IiwiY3kiLCJyeCIsInJ5IiwibnVtUG9pbnRzIiwiRXh0ZW5zaW9ucyIsIkNvbXBHZW9tIiwiZ2V0RWxsaXBzZUFyY1BvaW50IiwiR2VvbWV0cnlDYWxsYmFjayIsInNuYXBwZXIiLCJhRGV0ZWN0UmFkaXVzIiwiY2lyY3VsYXJBcmMiLCJlbGxpcHRpY2FsQXJjIiwiZWxsaXB0aWNhbEFyY0NlbnRlciIsIm1hdHJpeCIsInZwSWRMaW5lIiwidnBJZENpcmN1bGFyIiwidnBJZEVsbGlwdGljYWwiLCJkZXRlY3RSYWRpdXMiLCJzbmFwQ2FuZGlkYXRlcyIsIm9uTGluZVNlZ21lbnQiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIm9uQ2lyY3VsYXJBcmMiLCJzdWIiLCJwb2ludE9uQXJjIiwiYW5nbGUiLCJhcmMiLCJDaXJjbGVHZW9tZXRyeSIsIm1ha2VUcmFuc2xhdGlvbiIsIm9uRWxsaXB0aWNhbEFyYyIsIm1ham9yIiwibWlub3IiLCJ0aWx0IiwibWFqb3IxIiwibWlub3IxIiwibWFqb3IyIiwibWlub3IyIiwiZXF1YXRpb24xIiwiZXF1YXRpb24yIiwicG9wIiwibmVhcmVzdFBvaW50IiwibmVhcmVzdFZlcnRleEluVmVydGV4VG9FZGdlIiwibWFrZUVsbGlwdGljYWxBcmMiLCJzZXRNYXRyaXgiLCJzbmFwcGluZzJEIiwiaGl0UmVzdWx0IiwiYXJndW1lbnRzIiwiaXMzZCIsInRyIiwic2NhbGUiLCJpbXBsIiwiaXMyZCIsImdldE1vZGVsVG9WaWV3ZXJUcmFuc2Zvcm0iLCJnZXRNYXhTY2FsZU9uQXhpcyIsImdldEludmVyc2VNb2RlbFRvVmlld2VyVHJhbnNmb3JtIiwic3VwcG9ydHNHZW9tU25hcHBpbmciLCJnYyIsImVudW1TZWdtZW50cyIsIm1pbngiLCJtaW55IiwibWF4eCIsIm1heHkiLCJBcnJheSIsImlzQXJyYXkiLCJtZXNoIiwiZ2V0UmVuZGVyUHJveHkiLCJ2YnIiLCJlbnVtR2VvbXNGb3JPYmplY3QiLCJyZXZlcnNlTWFwRGJJZEZvcjJEIiwiZmluaXNoU25hcHBpbmcyRCIsIlJBU1RFUl9QSVhFTCIsIl9zbmFwUmVzdWx0JGdlb21FZGdlIiwiX3NuYXBSZXN1bHQkZ2VvbUVkZ2UyIiwicmVzdWx0cyIsIm4iLCJyZXMiLCJzbmFwcGluZzJET3ZlcmxheSIsIm1lc2hlcyIsImVudW1HZW9tcyIsImlzU2FtZVZpZXdwb3J0IiwiaW50ZXJzZWN0U25hcCIsInZpZXdwb3J0SW5kZXgyZCIsIlNOQVBfSU5URVJTRUNUSU9OIiwibGluZVN0cmlwVG9QaWVjZXMiLCJnZXRBdHRyaWJ1dGUiLCJtaWQiLCJhZGRWZWN0b3JzIiwibWQiLCJzZCIsImVkIiwiU05BUF9DSVJDTEVfQ0VOVEVSIiwic25hcHBpbmdSYXN0ZXJQaXhlbCIsInNuYXBNaWRwb2ludCIsImlzTWlkcG9pbnQiLCJtaWRwb2ludCIsImN1dFBsYW5lcyIsImdldEFsbEN1dFBsYW5lcyIsInciLCJTTkFQX01JRFBPSU5UIiwic2V0UGVycGVuZGljdWxhciIsImlzUGVycGVuZGljdWxhciIsIm5hdmFwaSIsIm5hdmlnYXRpb24iLCJjYW1lcmEiLCJnZXRDYW1lcmEiLCJnZXRQb3NpdGlvbiIsImlzUGVyc3BlY3RpdmUiLCJnZXRFeWVWZWN0b3IiLCJmb3YiLCJnZXRWZXJ0aWNhbEZvdiIsIndvcmxkSGVpZ2h0IiwidGFuIiwiZGVnVG9SYWQiLCJ2aWV3cG9ydCIsImdldFNjcmVlblZpZXdwb3J0IiwiX3dpbmRvdyIsImdldFdpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJoZWlnaHQiLCJoYW5kbGVCdXR0b25Eb3duIiwiaGFuZGxlQnV0dG9uVXAiLCJoYW5kbGVNb3VzZU1vdmUiLCJldmVudCIsIm9uTW91c2VNb3ZlIiwiY2FudmFzWCIsImNhbnZhc1kiLCJoYW5kbGVTaW5nbGVUYXAiLCJoYW5kbGVQcmVzc0hvbGQiLCJoYW5kbGVHZXN0dXJlIiwib25Nb3VzZURvd24iLCJtb3VzZVBvc2l0aW9uIiwiX3Jlc3VsdCRtb2RlbCIsIl92aWV3ZXIkbW9kZWwiLCJzbmFwcGluZ0hpdFRlc3QiLCJ2cFZlYyIsImNsaWVudFRvVmlld3BvcnQiLCJpbnRlcnNlY3RHcm91bmRWaWV3cG9ydCIsImlzTGVhZmxldCIsImlzUGl4ZWxTbmFwIiwiR2xvYmFsTWFuYWdlck1peGluIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./extensions/Snapping/Snapper.js\n");

                /***/
            }),

        /***/
        "./extensions/Snapping/SnapperIndicator.js":
            /*!*************************************************!*\
              !*** ./extensions/Snapping/SnapperIndicator.js ***!
              \*************************************************/
            /***/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

                "use strict";
                eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullSnapperIndicator: () => (/* binding */ NullSnapperIndicator),\n/* harmony export */   SnapperIndicator: () => (/* binding */ SnapperIndicator),\n/* harmony export */   getXYZFromPos: () => (/* binding */ getXYZFromPos)\n/* harmony export */ });\nconst MeasureCommon = Autodesk.Viewing.MeasureCommon;\nconst isEqualVectors = MeasureCommon.isEqualVectors;\nconst EPSILON = MeasureCommon.EPSILON;\nconst SnapType = MeasureCommon.SnapType;\n\nconst NO_OVERLAY = 0;\nconst FACE_OVERLAY = 1;\nconst EDGE_OVERLAY = 2;\nconst POINT_OVERLAY = 3;\n\nconst GEOMETRIES_OVERLAY = 'MeasureTool-snapper-geometries';\nconst INDICATOR_OVERLAY = 'MeasureTool-snapper-indicator';\n\nconst _geometryLineWidth = 0.3;\nconst _indicatorLineWidth = 0.2;\nconst _indicatorSize = 1.2;\nconst _indicatorColor = 0xff7700;\nconst _geometryColor = 0x00CC00;\n\nlet _point = null;\n\nconst tmpVec3 = new THREE.Vector3();\n/**\n * \n * @param {BufferAttribute} positionAttribute \n * @param {number} idx \n * @returns {THREE.Vector3} Vector3 corresponding to the indicated index. The returned value will be overriden by\n * subsequent calls\n */\nfunction getXYZFromPos(positionAttribute, idx) {\n  tmpVec3.x = positionAttribute.getX(idx);\n  tmpVec3.y = positionAttribute.getY(idx);\n  tmpVec3.z = positionAttribute.getZ(idx);\n  return tmpVec3;\n}\n\nclass NullSnapperIndicator {\n  isNull() {\n    return true;\n  }\n\n  render() {}\n  removeOverlay(overlayName) {}\n  clearOverlay(overlayName) {}\n  clearOverlays() {}\n  addOverlay(overlayName, mesh) {}\n  drawFace(geom, material, overlayName) {}\n  cylinderMesh(pointX, pointY, material, width) {\n    return new THREE.Mesh();\n  }\n  renderGeometry(snapResult) {}\n  renderVertexIndicator(snapResult) {}\n  renderMidpointIndicator(snapResult) {}\n  renderEdgeIndicator(snapResult) {}\n  renderCircleIndicator(snapResult) {}\n  renderPerpendicular(snapResult) {}\n  renderPixelIndicator(snapResult) {}\n  renderIndicator(snapResult) {}\n  drawLine(geom, material, width, overlayName) {}\n  drawPoint(point, material, overlayName) {}\n  drawCircle(point, material, overlayName) {}\n  setScale(point) {\n    return 1;\n  }\n  setPointScale(pointMesh) {}\n  setCircleScale(torusMesh) {}\n  setEdgeScale(cylinderMesh) {}\n  updatePointScale(overlayName) {}\n  updateEdgeScale(overlayName) {}\n  onCameraChange() {}\n  destroy() {}\n}\n\nclass SnapperIndicator extends NullSnapperIndicator {\n  constructor(viewer, snapper) {\n    super();\n\n    this.viewer = viewer;\n    this.snapper = snapper;\n    this.overlayType = NO_OVERLAY;\n    this.previewsIntersectPoint = null;\n\n    this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);\n    this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);\n\n    this.geometryMaterial = new THREE.MeshPhongMaterial({\n      color: _geometryColor,\n      opacity: 0.5,\n      transparent: true,\n      depthTest: false,\n      depthWrite: false,\n      side: THREE.DoubleSide\n    });\n\n    this.indicatorMaterial = new THREE.MeshBasicMaterial({\n      color: _indicatorColor,\n      opacity: 1,\n      transparent: false,\n      depthTest: false,\n      depthWrite: false,\n      side: THREE.DoubleSide\n    });\n  }\n\n  isNull() {\n    return false;\n  }\n\n  render() {\n\n    const snapResult = this.snapper.getSnapResult();\n\n    if (!isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)) {\n      this.clearOverlay(GEOMETRIES_OVERLAY);\n    }\n\n    this.clearOverlay(INDICATOR_OVERLAY);\n\n    if (snapResult.isEmpty())\n    return;\n\n    if (this.snapper.renderSnappedGeometry ||\n    snapResult.hasTopology && this.snapper.renderSnappedTopology) {\n      this.renderGeometry(snapResult);\n    }\n    this.renderIndicator(snapResult);\n\n    this.previewsIntersectPoint = snapResult.intersectPoint.clone();\n  }\n\n  removeOverlay(overlayName) {\n\n    this.viewer.impl.clearOverlay(overlayName, true);\n    this.viewer.impl.removeOverlayScene(overlayName);\n\n  }\n\n  clearOverlay(overlayName) {\n\n    this.removeOverlay(overlayName);\n    this.viewer.impl.createOverlayScene(overlayName);\n\n  }\n\n  clearOverlays() {\n\n    this.removeOverlay(GEOMETRIES_OVERLAY);\n    this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);\n\n    this.removeOverlay(INDICATOR_OVERLAY);\n    this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);\n\n    this.previewsIntersectPoint = null;\n\n  }\n\n  addOverlay(overlayName, mesh) {\n\n    this.viewer.impl.addOverlay(overlayName, mesh);\n\n  }\n\n  /**\n   * Draw the planar face\n   * @param geom - Geometry which needs to be draw.\n   * @param material - Material for the geometry.\n   * @param overlayName - Name of the overlay.\n   */\n  drawFace(geom, material, overlayName) {\n\n    const snapperPlane = new THREE.Mesh(geom, material, true);\n\n    if (overlayName === GEOMETRIES_OVERLAY) {\n      this.overlayType = FACE_OVERLAY;\n    }\n\n    this.addOverlay(overlayName, snapperPlane);\n\n  }\n\n  cylinderMesh(pointX, pointY, material, width) {\n\n    const direction = new THREE.Vector3().subVectors(pointY, pointX);\n    const orientation = new THREE.Matrix4();\n    orientation.lookAt(pointX, pointY, new THREE.Object3D().up);\n    orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,\n    0, 0, 1, 0,\n    0, -direction.length(), 0, 0,\n    0, 0, 0, 1));\n\n    width = width || 0.5;\n    let cylinder = new THREE.CylinderGeometry(width, width, 1.0, 8, 1, true);\n    const edge = new THREE.Mesh(cylinder, material);\n    cylinder = null;\n\n    edge.applyMatrix4(orientation);\n    edge.position.x = (pointY.x + pointX.x) / 2;\n    edge.position.y = (pointY.y + pointX.y) / 2;\n    edge.position.z = (pointY.z + pointX.z) / 2;\n    return edge;\n  }\n\n  renderGeometry(snapResult) {\n\n    if (isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)) {\n      return;\n    }\n\n    switch (snapResult.geomType) {\n      case SnapType.SNAP_VERTEX:\n        SnapType.RASTER_PIXEL;\n        this.drawPoint(snapResult.geomVertex, this.geometryMaterial, GEOMETRIES_OVERLAY);\n        break;\n\n      case SnapType.SNAP_EDGE:\n      case SnapType.SNAP_CURVEDEDGE:\n      case SnapType.SNAP_CIRCULARARC:\n      case SnapType.SNAP_MIDPOINT:\n        this.drawLine(snapResult.geomEdge, this.geometryMaterial, _geometryLineWidth, GEOMETRIES_OVERLAY);\n        break;\n\n      case SnapType.SNAP_FACE:\n      case SnapType.SNAP_CURVEDFACE:\n        this.drawFace(snapResult.geomFace, this.geometryMaterial, GEOMETRIES_OVERLAY);\n        break;\n    }\n  }\n\n  /**\n   * Renders a square around the given snap result.\n   * Is used when you’re snapping on a vertex, intersection, circular\n   * arc on a F2D sheet, and the curved face.\n   * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n   */\n  renderVertexIndicator(snapResult) {\n\n    const pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n    const scale = this.setScale(pos);\n    const length = _indicatorSize * scale;\n\n    const rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n    const upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n    const geom = new THREE.BufferGeometry();\n\n    const vertices = [];\n    const p = new THREE.Vector3();\n\n    // Upper line\n    p.addVectors(pos, rightVec);\n    p.addVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.subVectors(pos, rightVec);\n    p.addVectors(p, upVec);\n    vertices[1] = p.clone();\n\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Bottom line\n    p.addVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.subVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Left line\n    p.subVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.subVectors(pos, rightVec);\n    p.addVectors(p, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Right line\n    p.addVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.addVectors(pos, rightVec);\n    p.addVectors(p, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  }\n\n  /**\n   * Renders a triangle around the given snap result\n   * on a midpoint\n   * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n   */\n  renderMidpointIndicator(snapResult) {\n\n    const pos = snapResult.geomVertex;\n    const scale = this.setScale(pos);\n    const length = _indicatorSize * scale;\n\n    const rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n    const upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n    const geom = new THREE.BufferGeometry();\n    const vertices = [];\n    const p = new THREE.Vector3();\n\n    // Bottom line\n    p.addVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.subVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Left line\n    p.subVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.addVectors(pos, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Right line\n    p.addVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.addVectors(pos, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  }\n\n  /**\n   * Renders an upside-down Y around the given snap result\n   * on an edge or a curved edge..\n   * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n   */\n  renderEdgeIndicator(snapResult) {\n\n    const pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n    const scale = this.setScale(pos);\n    const length = _indicatorSize * scale;\n\n    const rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n    const upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n    const geom = new THREE.BufferGeometry();\n    const vertices = [];\n    const p = new THREE.Vector3();\n\n    // Bottom line\n    p.addVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    vertices[1] = pos.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Left line\n    p.subVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    vertices[1] = pos.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Right line\n    p.addVectors(pos, upVec);\n    vertices[0] = p.clone();\n    vertices[1] = pos.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  }\n\n  /**\n   * Renders an circle on a center of a circle\n   * and circular arc for other than F2D sheets.\n   * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n   */\n  renderCircleIndicator(snapResult) {\n\n    const pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n    this.drawCircle(pos, this.indicatorMaterial, INDICATOR_OVERLAY);\n\n  }\n\n  /**\n   * Renders an right-angle ( |_ ) indicator around the given snap result\n   * when the result is perpendicular.\n   * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n   */\n  renderPerpendicular(snapResult) {\n\n    const pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n    const scale = this.setScale(pos);\n    const length = _indicatorSize * scale;\n\n    const rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n    const upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n    const geom = new THREE.BufferGeometry();\n    const vertices = [];\n    const p = new THREE.Vector3();\n\n    // Upper line\n    vertices[0] = pos.clone();\n    p.subVectors(pos, rightVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Bottom line\n    p.addVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.subVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Left line\n    p.subVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.subVectors(pos, rightVec);\n    p.addVectors(p, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Right line\n    vertices[0] = pos.clone();\n    p.subVectors(pos, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  }\n\n  /**\n   * Renders an X around the given snap result.\n   * Usually shown when using \"Free Measure\" mode is enabled.\n   * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n   */\n  renderPixelIndicator(snapResult) {\n\n    const pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n    const scale = this.setScale(pos);\n    const length = _indicatorSize * scale;\n\n    const rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n    const upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n    const geom = new THREE.BufferGeometry();\n    const vertices = [];\n    const p = new THREE.Vector3();\n\n    // Top-left line\n    p.subVectors(pos, rightVec);\n    p.addVectors(p, upVec);\n    vertices[0] = p.clone();\n    vertices[1] = pos.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Top-right line\n    p.addVectors(pos, rightVec);\n    p.addVectors(p, upVec);\n    vertices[0] = p.clone();\n    vertices[1] = pos.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Bottom-right line\n    p.addVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    vertices[1] = pos.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Bottom-left line\n    p.subVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    vertices[1] = pos.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  }\n\n  renderIndicator(snapResult) {\n\n    if (snapResult.isPerpendicular) {\n      this.renderPerpendicular(snapResult);\n      return;\n    }\n\n    if (snapResult.snapToArc) {\n      if (snapResult.isArc && snapResult.geomType === SnapType.SNAP_CIRCULARARC && this.viewer.model.is2d() && !this.viewer.model.isPdf()) {\n        this.renderVertexIndicator(snapResult);\n      }\n      return;\n    }\n\n\n    switch (snapResult.geomType) {\n      case SnapType.SNAP_VERTEX:\n      case SnapType.SNAP_INTERSECTION:\n        this.renderVertexIndicator(snapResult);\n        break;\n\n      case SnapType.SNAP_MIDPOINT:\n        this.renderMidpointIndicator(snapResult);\n        break;\n\n      case SnapType.SNAP_CIRCLE_CENTER:\n        this.renderCircleIndicator(snapResult);\n        break;\n\n      case SnapType.SNAP_EDGE:\n      case SnapType.SNAP_CURVEDEDGE:\n        this.renderEdgeIndicator(snapResult);\n        break;\n\n      case SnapType.SNAP_CIRCULARARC:\n        if (this.viewer.model.is2d()) {\n          this.renderVertexIndicator(snapResult);\n        } else {\n          this.renderCircleIndicator(snapResult);\n        }\n        break;\n\n      case SnapType.SNAP_FACE:\n      case SnapType.SNAP_CURVEDFACE:\n        this.renderVertexIndicator(snapResult);\n        break;\n\n      case SnapType.RASTER_PIXEL:\n        this.renderPixelIndicator(snapResult);\n        break;\n    }\n  }\n\n  /**\n   * Draws a line in an overlyay\n   * @param {THREE.Geometry|THREE.BufferGeometry} geom \n   * @param {THREE.Material} material \n   * @param {number} width \n   * @param {string} overlayName \n   */\n  drawLine(geom, material, width, overlayName) {\n\n    // Line Pieces\n    if (overlayName === GEOMETRIES_OVERLAY) {\n      this.overlayType = EDGE_OVERLAY;\n    }\n\n    let verticesLength, geomPos;\n    if (geom instanceof THREE.Geometry) {\n      console.warn('SnapperIndicator.drawLine(geom, material, width, overlayName): THREE.Geometry has been depecrated and the geom argument should use a THREE.BufferGeometry instead');\n      verticesLength = geom.vertices.length;\n    } else {\n      geomPos = geom.getAttribute('position');\n      verticesLength = geomPos.count;\n    }\n    for (let i = 0; i < verticesLength; i += 2) {\n      let cylinder;\n      if (geom instanceof THREE.Geometry) {\n        cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material, width);\n      } else {\n        cylinder = this.cylinderMesh(getXYZFromPos(geomPos, i).clone(), getXYZFromPos(geomPos, i + 1).clone(), material, width);\n      }\n      this.setEdgeScale(cylinder);\n      this.addOverlay(overlayName, cylinder);\n    }\n  }\n\n  drawPoint(point, material, overlayName) {\n\n    // Because every point is snappable in PDFs, don't display the green dot for PDFs.\n    if (this.viewer.model.isLeaflet()) {\n      return;\n    }\n\n    if (!_point)\n    _point = new THREE.SphereGeometry(1.0);\n\n    const pointMesh = new THREE.Mesh(_point, material);\n    pointMesh.position.set(point.x, point.y, point.z);\n\n    this.setPointScale(pointMesh);\n\n    if (overlayName === GEOMETRIES_OVERLAY) {\n      this.overlayType = POINT_OVERLAY;\n    }\n\n    this.addOverlay(overlayName, pointMesh);\n\n  }\n\n  drawCircle(point, material, overlayName) {\n\n    let torus = new THREE.TorusGeometry(_indicatorSize, _indicatorLineWidth, 2, 20);\n    const torusMesh = new THREE.Mesh(torus, material);\n    torusMesh.lookAt(this.viewer.navigation.getEyeVector().normalize());\n    torus = null;\n\n    torusMesh.position.set(point.x, point.y, point.z);\n\n    this.setCircleScale(torusMesh);\n\n    this.addOverlay(overlayName, torusMesh);\n\n  }\n\n  setScale(point) {\n\n    const pixelSize = 5;\n\n    const navapi = this.viewer.navigation;\n    const camera = navapi.getCamera();\n    const position = navapi.getPosition();\n\n    const p = point.clone();\n\n    const distance = camera.isPerspective ? p.sub(position).length() :\n    navapi.getEyeVector().length();\n\n    const fov = navapi.getVerticalFov();\n    const worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));\n\n    const viewport = navapi.getScreenViewport();\n    const scale = pixelSize * worldHeight / viewport.height;\n\n    return scale;\n  }\n\n  setPointScale(pointMesh) {\n\n    const scale = this.setScale(pointMesh.position);\n    pointMesh.scale.x = scale;\n    pointMesh.scale.y = scale;\n    pointMesh.scale.z = scale;\n\n  }\n\n  setCircleScale(torusMesh) {\n\n    const scale = this.setScale(torusMesh.position);\n    torusMesh.scale.x = scale;\n    torusMesh.scale.y = scale;\n  }\n\n  setEdgeScale(cylinderMesh) {\n\n    const scale = this.setScale(cylinderMesh.position);\n    cylinderMesh.scale.x = scale;\n    cylinderMesh.scale.z = scale;\n  }\n\n  updatePointScale(overlayName) {\n\n    if (this.overlayType !== POINT_OVERLAY)\n    return;\n\n    const overlay = this.viewer.impl.overlayScenes[overlayName];\n    if (overlay) {\n      const scene = overlay.scene;\n\n      for (let i = 0; i < scene.children.length; i++) {\n        const pointMesh = scene.children[i];\n        if (pointMesh) {\n\n          this.setPointScale(pointMesh);\n        }\n      }\n    }\n  }\n\n  updateEdgeScale(overlayName) {\n\n    if (this.overlayType !== EDGE_OVERLAY)\n    return;\n\n    const overlay = this.viewer.impl.overlayScenes[overlayName];\n    if (overlay) {\n      const scene = overlay.scene;\n\n      for (let i = 0; i < scene.children.length; i++) {\n        const cylinderMesh = scene.children[i];\n        if (cylinderMesh) {\n\n          this.setEdgeScale(cylinderMesh);\n        }\n      }\n    }\n  }\n\n  onCameraChange() {\n\n    this.updatePointScale(GEOMETRIES_OVERLAY);\n    this.updateEdgeScale(GEOMETRIES_OVERLAY);\n\n    // if (!this.snapper.markupMode) {\n    this.render();\n    // }\n  }\n\n  destroy() {\n\n    this.removeOverlay(GEOMETRIES_OVERLAY);\n    this.removeOverlay(INDICATOR_OVERLAY);\n\n    if (_point) {\n      _point.dispose();\n      _point = null;\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leHRlbnNpb25zL1NuYXBwaW5nL1NuYXBwZXJJbmRpY2F0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsTUFBTUEsYUFBYSxHQUFHQyxRQUFRLENBQUNDLE9BQU8sQ0FBQ0YsYUFBYTtBQUNwRCxNQUFNRyxjQUFjLEdBQUdILGFBQWEsQ0FBQ0csY0FBYztBQUNuRCxNQUFNQyxPQUFPLEdBQUdKLGFBQWEsQ0FBQ0ksT0FBTztBQUNyQyxNQUFNQyxRQUFRLEdBQUdMLGFBQWEsQ0FBQ0ssUUFBUTs7QUFFdkMsTUFBTUMsVUFBVSxHQUFHLENBQUM7QUFDcEIsTUFBTUMsWUFBWSxHQUFHLENBQUM7QUFDdEIsTUFBTUMsWUFBWSxHQUFHLENBQUM7QUFDdEIsTUFBTUMsYUFBYSxHQUFHLENBQUM7O0FBRXZCLE1BQU1DLGtCQUFrQixHQUFHLGdDQUFnQztBQUMzRCxNQUFNQyxpQkFBaUIsR0FBRywrQkFBK0I7O0FBRXpELE1BQU1DLGtCQUFrQixHQUFHLEdBQUc7QUFDOUIsTUFBTUMsbUJBQW1CLEdBQUcsR0FBRztBQUMvQixNQUFNQyxjQUFjLEdBQUcsR0FBRztBQUMxQixNQUFNQyxlQUFlLEdBQUcsUUFBUTtBQUNoQyxNQUFNQyxjQUFjLEdBQUcsUUFBUTs7QUFFL0IsSUFBSUMsTUFBTSxHQUFHLElBQUk7O0FBRWpCLE1BQU1DLE9BQU8sR0FBRyxJQUFJQyxLQUFLLENBQUNDLE9BQU8sQ0FBQyxDQUFDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0MsYUFBYUEsQ0FBQ0MsaUJBQWlCLEVBQUVDLEdBQUcsRUFBRTtFQUNsREwsT0FBTyxDQUFDTSxDQUFDLEdBQUdGLGlCQUFpQixDQUFDRyxJQUFJLENBQUNGLEdBQUcsQ0FBQztFQUN2Q0wsT0FBTyxDQUFDUSxDQUFDLEdBQUdKLGlCQUFpQixDQUFDSyxJQUFJLENBQUNKLEdBQUcsQ0FBQztFQUN2Q0wsT0FBTyxDQUFDVSxDQUFDLEdBQUdOLGlCQUFpQixDQUFDTyxJQUFJLENB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QUN1QixZQUFZLENBQUN2QixZQUFZLENBQUM7UUFDbkM7TUFDSjtJQUNKO0VBQ0o7O0VBRUEwQixjQUFjQSxDQUFBLEVBQUc7O0lBRWIsSUFBSSxDQUFDRixnQkFBZ0IsQ0FBQ3hELGtCQUFrQixDQUFDO0lBQ3pDLElBQUksQ0FBQ3lELGVBQWUsQ0FBQ3pELGtCQUFrQixDQUFDOztJQUV4QztJQUNJLElBQUksQ0FBQ3NCLE1BQU0sQ0FBQyxDQUFDO0lBQ2pCO0VBQ0o7O0VBRUFxQyxPQUFPQSxDQUFBLEVBQUc7O0lBRU4sSUFBSSxDQUFDcEMsYUFBYSxDQUFDdkIsa0JBQWtCLENBQUM7SUFDdEMsSUFBSSxDQUFDdUIsYUFBYSxDQUFDdEIsaUJBQWlCLENBQUM7O0lBRXJDLElBQUlNLE1BQU0sRUFBRTtNQUNSQSxNQUFNLENBQUNxSyxPQUFPLENBQUMsQ0FBQztNQUNoQnJLLE1BQU0sR0FBRyxJQUFJO0lBQ2pCO0VBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL0F1dG9kZXNrLkV4dGVuc2lvbnMvLi9leHRlbnNpb25zL1NuYXBwaW5nL1NuYXBwZXJJbmRpY2F0b3IuanM/NTZlNCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBNZWFzdXJlQ29tbW9uID0gQXV0b2Rlc2suVmlld2luZy5NZWFzdXJlQ29tbW9uO1xuY29uc3QgaXNFcXVhbFZlY3RvcnMgPSBNZWFzdXJlQ29tbW9uLmlzRXF1YWxWZWN0b3JzO1xuY29uc3QgRVBTSUxPTiA9IE1lYXN1cmVDb21tb24uRVBTSUxPTjtcbmNvbnN0IFNuYXBUeXBlID0gTWVhc3VyZUNvbW1vbi5TbmFwVHlwZTtcblxuY29uc3QgTk9fT1ZFUkxBWSA9IDA7XG5jb25zdCBGQUNFX09WRVJMQVkgPSAxO1xuY29uc3QgRURHRV9PVkVSTEFZID0gMjtcbmNvbnN0IFBPSU5UX09WRVJMQVkgPSAzO1xuXG5jb25zdCBHRU9NRVRSSUVTX09WRVJMQVkgPSAnTWVhc3VyZVRvb2wtc25hcHBlci1nZW9tZXRyaWVzJztcbmNvbnN0IElORElDQVRPUl9PVkVSTEFZID0gJ01lYXN1cmVUb29sLXNuYXBwZXItaW5kaWNhdG9yJztcblxuY29uc3QgX2dlb21ldHJ5TGluZVdpZHRoID0gMC4zO1xuY29uc3QgX2luZGljYXRvckxpbmVXaWR0aCA9IDAuMjtcbmNvbnN0IF9pbmRpY2F0b3JTaXplID0gMS4yO1xuY29uc3QgX2luZGljYXRvckNvbG9yID0gMHhmZjc3MDA7XG5jb25zdCBfZ2VvbWV0cnlDb2xvciA9IDB4MDBDQzAwO1xuXG5sZXQgX3BvaW50ID0gbnVsbDtcblxuY29uc3QgdG1wVmVjMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4vKipcbiAqIFxuICogQHBhcmFtIHtCdWZmZXJBdHRyaWJ1dGV9IHBvc2l0aW9uQXR0cmlidXRlIFxuICogQHBhcmFtIHtudW1iZXJ9IGlkeCBcbiAqIEByZXR1cm5zIHtUSFJFRS5WZWN0b3IzfSBWZWN0b3IzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGluZGljYXRlZCBpbmRleC4gVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgb3ZlcnJpZGVuIGJ5XG4gKiBzdWJzZXF1ZW50IGNhbGxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRYWVpGcm9tUG9zKHBvc2l0aW9uQXR0cmlidXRlLCBpZHgpIHtcbiAgICB0bXBWZWMzLnggPSBwb3NpdGlvbkF0dHJpYnV0ZS5nZXRYKGlkeCk7XG4gICAgdG1wVmVjMy55ID0gcG9zaXRpb25BdHRyaWJ1dGUuZ2V0WShpZHgpO1xuICAgIHRtcFZlYzMueiA9IHBvc2l0aW9uQXR0cmlidXRlLmdldFooaWR4KTtcbiAgICByZXR1cm4gdG1wVmVjMztcbn1cblxuZXhwb3J0IGNsYXNzIE51bGxTbmFwcGVySW5kaWNhdG9yIHtcbiAgICBpc051bGwoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHt9XG4gICAgcmVtb3ZlT3ZlcmxheShvdmVybGF5TmFtZSkge31cbiAgICBjbGVhck92ZXJsYXkob3ZlcmxheU5hbWUpIHt9XG4gICAgY2xlYXJPdmVybGF5cygpIHt9XG4gICAgYWRkT3ZlcmxheShvdmVybGF5TmFtZSwgbWVzaCkge31cbiAgICBkcmF3RmFjZShnZW9tLCBtYXRlcmlhbCwgb3ZlcmxheU5hbWUpIHt9XG4gICAgY3lsaW5kZXJNZXNoKHBvaW50WCwgcG9pbnRZLCBtYXRlcmlhbCwgd2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5NZXNoKCk7XG4gICAgfVxuICAgIHJlbmRlckdlb21ldHJ5KHNuYXBSZXN1bHQpIHt9XG4gICAgcmVuZGVyVmVydGV4SW5kaWNhdG9yKHNuYXBSZXN1bHQpIHt9XG4gICAgcmVuZGVyTWlkcG9pbnRJbmRpY2F0b3Ioc25hcFJlc3VsdCkge31cbiAgICByZW5kZXJFZGdlSW5kaWNhdG9yKHNuYXBSZXN1bHQpIHt9XG4gICAgcmVuZGVyQ2lyY2xlSW5kaWNhdG9yKHNuYXBSZXN1bHQpIHt9XG4gICAgcmVuZGVyUGVycGVuZGljdWxhcihzbmFwUmVzdWx0KSB7fVxuICAgIHJlbmRlclBpeGVsSW5kaWNhdG9yKHNuYXBSZXN1bHQpIHt9XG4gICAgcmVuZGVySW5kaWNhdG9yKHNuYXBSZXN1bHQpIHt9XG4gICAgZHJhd0xpbmUoZ2VvbSwgbWF0ZXJpYWwsIHdpZHRoLCBvdmVybGF5TmFtZSkge31cbiAgICBkcmF3UG9pbnQocG9pbnQsIG1hdGVyaWFsLCBvdmVybGF5TmFtZSkge31cbiAgICBkcmF3Q2lyY2xlKHBvaW50LCBtYXRlcmlhbCwgb3ZlcmxheU5hbWUpIHt9XG4gICAgc2V0U2NhbGUocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHNldFBvaW50U2NhbGUocG9pbnRNZXNoKSB7fVxuICAgIHNldENpcmNsZVNjYWxlKHRvcnVzTWVzaCkge31cbiAgICBzZXRFZGdlU2NhbGUoY3lsaW5kZXJNZXNoKSB7fVxuICAgIHVwZGF0ZVBvaW50U2NhbGUob3ZlcmxheU5hbWUpIHt9XG4gICAgdXBkYXRlRWRnZVNjYWxlKG92ZXJsYXlOYW1lKSB7fVxuICAgIG9uQ2FtZXJhQ2hhbmdlKCkge31cbiAgICBkZXN0cm95KCkge31cbn1cblxuZXhwb3J0IGNsYXNzIFNuYXBwZXJJbmRpY2F0b3IgZXh0ZW5kcyBOdWxsU25hcHBlckluZGljYXRvciB7XG4gICAgY29uc3RydWN0b3Iodmlld2VyLCBzbmFwcGVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy52aWV3ZXIgPSB2aWV3ZXI7XG4gICAgICAgIHRoaXMuc25hcHBlciA9IHNuYXBwZXI7XG4gICAgICAgIHRoaXMub3ZlcmxheVR5cGUgPSBOT19PVkVSTEFZO1xuICAgICAgICB0aGlzLnByZXZpZXdzSW50ZXJzZWN0UG9pbnQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMudmlld2VyLmltcGwuY3JlYXRlT3ZlcmxheVNjZW5lKEdFT01FVFJJRVNfT1ZFUkxBWSk7XG4gICAgICAgIHRoaXMudmlld2VyLmltcGwuY3JlYXRlT3ZlcmxheVNjZW5lKElORElDQVRPUl9PVkVSTEFZKTtcblxuICAgICAgICB0aGlzLmdlb21ldHJ5TWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoe1xuICAgICAgICAgICAgY29sb3I6IF9nZW9tZXRyeUNvbG9yLFxuICAgICAgICAgICAgb3BhY2l0eTogMC41LFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICAgICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaW5kaWNhdG9yTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICAgICAgY29sb3I6IF9pbmRpY2F0b3JDb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXG4gICAgICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICAgICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlzTnVsbCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcblxuICAgICAgICBjb25zdCBzbmFwUmVzdWx0ID0gdGhpcy5zbmFwcGVyLmdldFNuYXBSZXN1bHQoKTtcblxuICAgICAgICBpZiAoIWlzRXF1YWxWZWN0b3JzKHRoaXMucHJldmlld3NJbnRlcnNlY3RQb2ludCwgc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludCwgRVBTSUxPTikpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJPdmVybGF5KEdFT01FVFJJRVNfT1ZFUkxBWSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsZWFyT3ZlcmxheShJTkRJQ0FUT1JfT1ZFUkxBWSk7XG5cbiAgICAgICAgaWYgKHNuYXBSZXN1bHQuaXNFbXB0eSgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGlmICh0aGlzLnNuYXBwZXIucmVuZGVyU25hcHBlZEdlb21ldHJ5IHx8XG4gICAgICAgICAgICAoc25hcFJlc3VsdC5oYXNUb3BvbG9neSAmJiB0aGlzLnNuYXBwZXIucmVuZGVyU25hcHBlZFRvcG9sb2d5KSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJHZW9tZXRyeShzbmFwUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlckluZGljYXRvcihzbmFwUmVzdWx0KTtcblxuICAgICAgICB0aGlzLnByZXZpZXdzSW50ZXJzZWN0UG9pbnQgPSBzbmFwUmVzdWx0LmludGVyc2VjdFBvaW50LmNsb25lKCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlT3ZlcmxheShvdmVybGF5TmFtZSkge1xuXG4gICAgICAgIHRoaXMudmlld2VyLmltcGwuY2xlYXJPdmVybGF5KG92ZXJsYXlOYW1lLCB0cnVlKTtcbiAgICAgICAgdGhpcy52aWV3ZXIuaW1wbC5yZW1vdmVPdmVybGF5U2NlbmUob3ZlcmxheU5hbWUpO1xuXG4gICAgfVxuXG4gICAgY2xlYXJPdmVybGF5KG92ZXJsYXlOYW1lKSB7XG5cbiAgICAgICAgdGhpcy5yZW1vdmVPdmVybGF5KG92ZXJsYXlOYW1lKTtcbiAgICAgICAgdGhpcy52aWV3ZXIuaW1wbC5jcmVhdGVPdmVybGF5U2NlbmUob3ZlcmxheU5hbWUpO1xuXG4gICAgfVxuXG4gICAgY2xlYXJPdmVybGF5cygpIHtcblxuICAgICAgICB0aGlzLnJlbW92ZU92ZXJsYXkoR0VPTUVUUklFU19PVkVSTEFZKTtcbiAgICAgICAgdGhpcy52aWV3ZXIuaW1wbC5jcmVhdGVPdmVybGF5U2NlbmUoR0VPTUVUUklFU19PVkVSTEFZKTtcblxuICAgICAgICB0aGlzLnJlbW92ZU92ZXJsYXkoSU5ESUNBVE9SX09WRVJMQVkpO1xuICAgICAgICB0aGlzLnZpZXdlci5pbXBsLmNyZWF0ZU92ZXJsYXlTY2VuZShJTkRJQ0FUT1JfT1ZFUkxBWSk7XG5cbiAgICAgICAgdGhpcy5wcmV2aWV3c0ludGVyc2VjdFBvaW50ID0gbnVsbDtcblxuICAgIH1cblxuICAgIGFkZE92ZXJsYXkgKG92ZXJsYXlOYW1lLCBtZXNoKSB7XG5cbiAgICAgICAgdGhpcy52aWV3ZXIuaW1wbC5hZGRPdmVybGF5KG92ZXJsYXlOYW1lLCBtZXNoKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhlIHBsYW5hciBmYWNlXG4gICAgICogQHBhcmFtIGdlb20gLSBHZW9tZXRyeSB3aGljaCBuZWVkcyB0byBiZSBkcmF3LlxuICAgICAqIEBwYXJhbSBtYXRlcmlhbCAtIE1hdGVyaWFsIGZvciB0aGUgZ2VvbWV0cnkuXG4gICAgICogQHBhcmFtIG92ZXJsYXlOYW1lIC0gTmFtZSBvZiB0aGUgb3ZlcmxheS5cbiAgICAgKi9cbiAgICBkcmF3RmFjZShnZW9tLCBtYXRlcmlhbCwgb3ZlcmxheU5hbWUpIHtcblxuICAgICAgICBjb25zdCBzbmFwcGVyUGxhbmUgPSBuZXcgVEhSRUUuTWVzaChnZW9tLCBtYXRlcmlhbCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKG92ZXJsYXlOYW1lID09PSBHRU9NRVRSSUVTX09WRVJMQVkpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVR5cGUgPSBGQUNFX09WRVJMQVk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFkZE92ZXJsYXkob3ZlcmxheU5hbWUsIHNuYXBwZXJQbGFuZSk7XG5cbiAgICB9XG5cbiAgICBjeWxpbmRlck1lc2gocG9pbnRYLCBwb2ludFksIG1hdGVyaWFsLCB3aWR0aCkge1xuXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuc3ViVmVjdG9ycyhwb2ludFksIHBvaW50WCk7XG4gICAgICAgIGNvbnN0IG9yaWVudGF0aW9uID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICAgICAgb3JpZW50YXRpb24ubG9va0F0KHBvaW50WCwgcG9pbnRZLCBuZXcgVEhSRUUuT2JqZWN0M0QoKS51cCk7XG4gICAgICAgIG9yaWVudGF0aW9uLm11bHRpcGx5KG5ldyBUSFJFRS5NYXRyaXg0KCkuc2V0KDEsIDAsIDAsIDAsXG4gICAgICAgICAgICAwLCAwLCAxLCAwLFxuICAgICAgICAgICAgMCwgLWRpcmVjdGlvbi5sZW5ndGgoKSwgMCwgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDEpKTtcblxuICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IDAuNTtcbiAgICAgICAgbGV0IGN5bGluZGVyID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkod2lkdGgsIHdpZHRoLCAxLjAsIDgsIDEsIHRydWUpO1xuICAgICAgICBjb25zdCBlZGdlID0gbmV3IFRIUkVFLk1lc2goY3lsaW5kZXIsIG1hdGVyaWFsKTtcbiAgICAgICAgY3lsaW5kZXIgPSBudWxsO1xuXG4gICAgICAgIGVkZ2UuYXBwbHlNYXRyaXg0KG9yaWVudGF0aW9uKTtcbiAgICAgICAgZWRnZS5wb3NpdGlvbi54ID0gKHBvaW50WS54ICsgcG9pbnRYLngpIC8gMjtcbiAgICAgICAgZWRnZS5wb3NpdGlvbi55ID0gKHBvaW50WS55ICsgcG9pbnRYLnkpIC8gMjtcbiAgICAgICAgZWRnZS5wb3NpdGlvbi56ID0gKHBvaW50WS56ICsgcG9pbnRYLnopIC8gMjtcbiAgICAgICAgcmV0dXJuIGVkZ2U7XG4gICAgfVxuXG4gICAgcmVuZGVyR2VvbWV0cnkoc25hcFJlc3VsdCkge1xuXG4gICAgICAgIGlmIChpc0VxdWFsVmVjdG9ycyh0aGlzLnByZXZpZXdzSW50ZXJzZWN0UG9pbnQsIHNuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQsIEVQU0lMT04pKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoc25hcFJlc3VsdC5nZW9tVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBTbmFwVHlwZS5TTkFQX1ZFUlRFWDpcbiAgICAgICAgICAgICAgICAgU25hcFR5cGUuUkFTVEVSX1BJWEVMO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1BvaW50KHNuYXBSZXN1bHQuZ2VvbVZlcnRleCwgdGhpcy5nZW9tZXRyeU1hdGVyaWFsLCBHRU9NRVRSSUVTX09WRVJMQVkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNuYXBUeXBlLlNOQVBfRURHRTpcbiAgICAgICAgICAgIGNhc2UgU25hcFR5cGUuU05BUF9DVVJWRURFREdFOlxuICAgICAgICAgICAgY2FzZSBTbmFwVHlwZS5TTkFQX0NJUkNVTEFSQVJDOlxuICAgICAgICAgICAgY2FzZSBTbmFwVHlwZS5TTkFQX01JRFBPSU5UOlxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xpbmUoc25hcFJlc3VsdC5nZW9tRWRnZSwgdGhpcy5nZW9tZXRyeU1hdGVyaWFsLCBfZ2VvbWV0cnlMaW5lV2lkdGgsIEdFT01FVFJJRVNfT1ZFUkxBWSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU25hcFR5cGUuU05BUF9GQUNFOlxuICAgICAgICAgICAgY2FzZSBTbmFwVHlwZS5TTkFQX0NVUlZFREZBQ0U6XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3RmFjZShzbmFwUmVzdWx0Lmdlb21GYWNlLCB0aGlzLmdlb21ldHJ5TWF0ZXJpYWwsIEdFT01FVFJJRVNfT1ZFUkxBWSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgc3F1YXJlIGFyb3VuZCB0aGUgZ2l2ZW4gc25hcCByZXN1bHQuXG4gICAgICogSXMgdXNlZCB3aGVuIHlvdeKAmXJlIHNuYXBwaW5nIG9uIGEgdmVydGV4LCBpbnRlcnNlY3Rpb24sIGNpcmN1bGFyXG4gICAgICogYXJjIG9uIGEgRjJEIHNoZWV0LCBhbmQgdGhlIGN1cnZlZCBmYWNlLlxuICAgICAqIEBwYXJhbSB7QXV0b2Rlc2suVmlld2luZy5NZWFzdXJlQ29tbW9uLlNuYXBSZXN1bHR9IHNuYXBSZXN1bHRcbiAgICAgKi9cbiAgICByZW5kZXJWZXJ0ZXhJbmRpY2F0b3Ioc25hcFJlc3VsdCkge1xuXG4gICAgICAgIGNvbnN0IHBvcyA9IE1lYXN1cmVDb21tb24uZ2V0U25hcFJlc3VsdFBvc2l0aW9uKHNuYXBSZXN1bHQsIHRoaXMudmlld2VyKTtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNldFNjYWxlKHBvcyk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IF9pbmRpY2F0b3JTaXplICogc2NhbGU7XG5cbiAgICAgICAgY29uc3QgcmlnaHRWZWMgPSB0aGlzLnZpZXdlci5uYXZpZ2F0aW9uLmdldENhbWVyYVJpZ2h0VmVjdG9yKCkubXVsdGlwbHlTY2FsYXIobGVuZ3RoKTtcbiAgICAgICAgY29uc3QgdXBWZWMgPSB0aGlzLnZpZXdlci5uYXZpZ2F0aW9uLmdldENhbWVyYVVwVmVjdG9yKCkubXVsdGlwbHlTY2FsYXIobGVuZ3RoKTtcblxuICAgICAgICBjb25zdCBnZW9tID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG5cbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgLy8gVXBwZXIgbGluZVxuICAgICAgICBwLmFkZFZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuYWRkVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzBdID0gcC5jbG9uZSgpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuYWRkVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcC5jbG9uZSgpO1xuXG4gICAgICAgIGdlb20uc2V0RnJvbVBvaW50cyh2ZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMuZHJhd0xpbmUoZ2VvbSwgdGhpcy5pbmRpY2F0b3JNYXRlcmlhbCwgX2luZGljYXRvckxpbmVXaWR0aCwgSU5ESUNBVE9SX09WRVJMQVkpO1xuXG4gICAgICAgIC8vIEJvdHRvbSBsaW5lXG4gICAgICAgIHAuYWRkVmVjdG9ycyhwb3MsIHJpZ2h0VmVjKTtcbiAgICAgICAgcC5zdWJWZWN0b3JzKHAsIHVwVmVjKTtcbiAgICAgICAgdmVydGljZXNbMF0gPSBwLmNsb25lKCk7XG4gICAgICAgIHAuc3ViVmVjdG9ycyhwb3MsIHJpZ2h0VmVjKTtcbiAgICAgICAgcC5zdWJWZWN0b3JzKHAsIHVwVmVjKTtcbiAgICAgICAgdmVydGljZXNbMV0gPSBwLmNsb25lKCk7XG4gICAgICAgIGdlb20uc2V0RnJvbVBvaW50cyh2ZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMuZHJhd0xpbmUoZ2VvbSwgdGhpcy5pbmRpY2F0b3JNYXRlcmlhbCwgX2luZGljYXRvckxpbmVXaWR0aCwgSU5ESUNBVE9SX09WRVJMQVkpO1xuXG4gICAgICAgIC8vIExlZnQgbGluZVxuICAgICAgICBwLnN1YlZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuc3ViVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzBdID0gcC5jbG9uZSgpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuYWRkVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcC5jbG9uZSgpO1xuICAgICAgICBnZW9tLnNldEZyb21Qb2ludHModmVydGljZXMpO1xuICAgICAgICB0aGlzLmRyYXdMaW5lKGdlb20sIHRoaXMuaW5kaWNhdG9yTWF0ZXJpYWwsIF9pbmRpY2F0b3JMaW5lV2lkdGgsIElORElDQVRPUl9PVkVSTEFZKTtcblxuICAgICAgICAvLyBSaWdodCBsaW5lXG4gICAgICAgIHAuYWRkVmVjdG9ycyhwb3MsIHJpZ2h0VmVjKTtcbiAgICAgICAgcC5zdWJWZWN0b3JzKHAsIHVwVmVjKTtcbiAgICAgICAgdmVydGljZXNbMF0gPSBwLmNsb25lKCk7XG4gICAgICAgIHAuYWRkVmVjdG9ycyhwb3MsIHJpZ2h0VmVjKTtcbiAgICAgICAgcC5hZGRWZWN0b3JzKHAsIHVwVmVjKTtcbiAgICAgICAgdmVydGljZXNbMV0gPSBwLmNsb25lKCk7XG4gICAgICAgIGdlb20uc2V0RnJvbVBvaW50cyh2ZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMuZHJhd0xpbmUoZ2VvbSwgdGhpcy5pbmRpY2F0b3JNYXRlcmlhbCwgX2luZGljYXRvckxpbmVXaWR0aCwgSU5ESUNBVE9SX09WRVJMQVkpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHRyaWFuZ2xlIGFyb3VuZCB0aGUgZ2l2ZW4gc25hcCByZXN1bHRcbiAgICAgKiBvbiBhIG1pZHBvaW50XG4gICAgICogQHBhcmFtIHtBdXRvZGVzay5WaWV3aW5nLk1lYXN1cmVDb21tb24uU25hcFJlc3VsdH0gc25hcFJlc3VsdFxuICAgICAqL1xuICAgIHJlbmRlck1pZHBvaW50SW5kaWNhdG9yKHNuYXBSZXN1bHQpIHtcblxuICAgICAgICBjb25zdCBwb3MgPSBzbmFwUmVzdWx0Lmdlb21WZXJ0ZXg7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zZXRTY2FsZShwb3MpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBfaW5kaWNhdG9yU2l6ZSAqIHNjYWxlO1xuXG4gICAgICAgIGNvbnN0IHJpZ2h0VmVjID0gdGhpcy52aWV3ZXIubmF2aWdhdGlvbi5nZXRDYW1lcmFSaWdodFZlY3RvcigpLm11bHRpcGx5U2NhbGFyKGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHVwVmVjID0gdGhpcy52aWV3ZXIubmF2aWdhdGlvbi5nZXRDYW1lcmFVcFZlY3RvcigpLm11bHRpcGx5U2NhbGFyKGxlbmd0aCk7XG5cbiAgICAgICAgY29uc3QgZ2VvbSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuICAgICAgICBjb25zdCBwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAvLyBCb3R0b20gbGluZVxuICAgICAgICBwLmFkZFZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuc3ViVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzBdID0gcC5jbG9uZSgpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuc3ViVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcC5jbG9uZSgpO1xuICAgICAgICBnZW9tLnNldEZyb21Qb2ludHModmVydGljZXMpO1xuICAgICAgICB0aGlzLmRyYXdMaW5lKGdlb20sIHRoaXMuaW5kaWNhdG9yTWF0ZXJpYWwsIF9pbmRpY2F0b3JMaW5lV2lkdGgsIElORElDQVRPUl9PVkVSTEFZKTtcblxuICAgICAgICAvLyBMZWZ0IGxpbmVcbiAgICAgICAgcC5zdWJWZWN0b3JzKHBvcywgcmlnaHRWZWMpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocCwgdXBWZWMpO1xuICAgICAgICB2ZXJ0aWNlc1swXSA9IHAuY2xvbmUoKTtcbiAgICAgICAgcC5hZGRWZWN0b3JzKHBvcywgdXBWZWMpO1xuICAgICAgICB2ZXJ0aWNlc1sxXSA9IHAuY2xvbmUoKTtcbiAgICAgICAgZ2VvbS5zZXRGcm9tUG9pbnRzKHZlcnRpY2VzKTtcbiAgICAgICAgdGhpcy5kcmF3TGluZShnZW9tLCB0aGlzLmluZGljYXRvck1hdGVyaWFsLCBfaW5kaWNhdG9yTGluZVdpZHRoLCBJTkRJQ0FUT1JfT1ZFUkxBWSk7XG5cbiAgICAgICAgLy8gUmlnaHQgbGluZVxuICAgICAgICBwLmFkZFZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuc3ViVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzBdID0gcC5jbG9uZSgpO1xuICAgICAgICBwLmFkZFZlY3RvcnMocG9zLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcC5jbG9uZSgpO1xuICAgICAgICBnZW9tLnNldEZyb21Qb2ludHModmVydGljZXMpO1xuICAgICAgICB0aGlzLmRyYXdMaW5lKGdlb20sIHRoaXMuaW5kaWNhdG9yTWF0ZXJpYWwsIF9pbmRpY2F0b3JMaW5lV2lkdGgsIElORElDQVRPUl9PVkVSTEFZKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYW4gdXBzaWRlLWRvd24gWSBhcm91bmQgdGhlIGdpdmVuIHNuYXAgcmVzdWx0XG4gICAgICogb24gYW4gZWRnZSBvciBhIGN1cnZlZCBlZGdlLi5cbiAgICAgKiBAcGFyYW0ge0F1dG9kZXNrLlZpZXdpbmcuTWVhc3VyZUNvbW1vbi5TbmFwUmVzdWx0fSBzbmFwUmVzdWx0XG4gICAgICovXG4gICAgcmVuZGVyRWRnZUluZGljYXRvcihzbmFwUmVzdWx0KSB7XG5cbiAgICAgICAgY29uc3QgcG9zID0gTWVhc3VyZUNvbW1vbi5nZXRTbmFwUmVzdWx0UG9zaXRpb24oc25hcFJlc3VsdCwgdGhpcy52aWV3ZXIpO1xuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2V0U2NhbGUocG9zKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gX2luZGljYXRvclNpemUgKiBzY2FsZTtcblxuICAgICAgICBjb25zdCByaWdodFZlYyA9IHRoaXMudmlld2VyLm5hdmlnYXRpb24uZ2V0Q2FtZXJhUmlnaHRWZWN0b3IoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xuICAgICAgICBjb25zdCB1cFZlYyA9IHRoaXMudmlld2VyLm5hdmlnYXRpb24uZ2V0Q2FtZXJhVXBWZWN0b3IoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xuXG4gICAgICAgIGNvbnN0IGdlb20gPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgLy8gQm90dG9tIGxpbmVcbiAgICAgICAgcC5hZGRWZWN0b3JzKHBvcywgcmlnaHRWZWMpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocCwgdXBWZWMpO1xuICAgICAgICB2ZXJ0aWNlc1swXSA9IHAuY2xvbmUoKTtcbiAgICAgICAgdmVydGljZXNbMV0gPSBwb3MuY2xvbmUoKTtcbiAgICAgICAgZ2VvbS5zZXRGcm9tUG9pbnRzKHZlcnRpY2VzKTtcbiAgICAgICAgdGhpcy5kcmF3TGluZShnZW9tLCB0aGlzLmluZGljYXRvck1hdGVyaWFsLCBfaW5kaWNhdG9yTGluZVdpZHRoLCBJTkRJQ0FUT1JfT1ZFUkxBWSk7XG5cbiAgICAgICAgLy8gTGVmdCBsaW5lXG4gICAgICAgIHAuc3ViVmVjdG9ycyhwb3MsIHJpZ2h0VmVjKTtcbiAgICAgICAgcC5zdWJWZWN0b3JzKHAsIHVwVmVjKTtcbiAgICAgICAgdmVydGljZXNbMF0gPSBwLmNsb25lKCk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcG9zLmNsb25lKCk7XG4gICAgICAgIGdlb20uc2V0RnJvbVBvaW50cyh2ZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMuZHJhd0xpbmUoZ2VvbSwgdGhpcy5pbmRpY2F0b3JNYXRlcmlhbCwgX2luZGljYXRvckxpbmVXaWR0aCwgSU5ESUNBVE9SX09WRVJMQVkpO1xuXG4gICAgICAgIC8vIFJpZ2h0IGxpbmVcbiAgICAgICAgcC5hZGRWZWN0b3JzKHBvcywgdXBWZWMpO1xuICAgICAgICB2ZXJ0aWNlc1swXSA9IHAuY2xvbmUoKTtcbiAgICAgICAgdmVydGljZXNbMV0gPSBwb3MuY2xvbmUoKTtcbiAgICAgICAgZ2VvbS5zZXRGcm9tUG9pbnRzKHZlcnRpY2VzKTtcbiAgICAgICAgdGhpcy5kcmF3TGluZShnZW9tLCB0aGlzLmluZGljYXRvck1hdGVyaWFsLCBfaW5kaWNhdG9yTGluZVdpZHRoLCBJTkRJQ0FUT1JfT1ZFUkxBWSk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGFuIGNpcmNsZSBvbiBhIGNlbnRlciBvZiBhIGNpcmNsZVxuICAgICAqIGFuZCBjaXJjdWxhciBhcmMgZm9yIG90aGVyIHRoYW4gRjJEIHNoZWV0cy5cbiAgICAgKiBAcGFyYW0ge0F1dG9kZXNrLlZpZXdpbmcuTWVhc3VyZUNvbW1vbi5TbmFwUmVzdWx0fSBzbmFwUmVzdWx0XG4gICAgICovXG4gICAgcmVuZGVyQ2lyY2xlSW5kaWNhdG9yKHNuYXBSZXN1bHQpe1xuXG4gICAgICAgIGNvbnN0IHBvcyA9IE1lYXN1cmVDb21tb24uZ2V0U25hcFJlc3VsdFBvc2l0aW9uKHNuYXBSZXN1bHQsIHRoaXMudmlld2VyKTtcbiAgICAgICAgdGhpcy5kcmF3Q2lyY2xlKHBvcywgdGhpcy5pbmRpY2F0b3JNYXRlcmlhbCwgSU5ESUNBVE9SX09WRVJMQVkpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbiByaWdodC1hbmdsZSAoIHxfICkgaW5kaWNhdG9yIGFyb3VuZCB0aGUgZ2l2ZW4gc25hcCByZXN1bHRcbiAgICAgKiB3aGVuIHRoZSByZXN1bHQgaXMgcGVycGVuZGljdWxhci5cbiAgICAgKiBAcGFyYW0ge0F1dG9kZXNrLlZpZXdpbmcuTWVhc3VyZUNvbW1vbi5TbmFwUmVzdWx0fSBzbmFwUmVzdWx0XG4gICAgICovXG4gICAgcmVuZGVyUGVycGVuZGljdWxhcihzbmFwUmVzdWx0KSB7XG5cbiAgICAgICAgY29uc3QgcG9zID0gTWVhc3VyZUNvbW1vbi5nZXRTbmFwUmVzdWx0UG9zaXRpb24oc25hcFJlc3VsdCwgdGhpcy52aWV3ZXIpO1xuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2V0U2NhbGUocG9zKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gX2luZGljYXRvclNpemUgKiBzY2FsZTtcblxuICAgICAgICBjb25zdCByaWdodFZlYyA9IHRoaXMudmlld2VyLm5hdmlnYXRpb24uZ2V0Q2FtZXJhUmlnaHRWZWN0b3IoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xuICAgICAgICBjb25zdCB1cFZlYyA9IHRoaXMudmlld2VyLm5hdmlnYXRpb24uZ2V0Q2FtZXJhVXBWZWN0b3IoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xuXG4gICAgICAgIGNvbnN0IGdlb20gPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgLy8gVXBwZXIgbGluZVxuICAgICAgICB2ZXJ0aWNlc1swXSA9IHBvcy5jbG9uZSgpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcC5jbG9uZSgpO1xuICAgICAgICBnZW9tLnNldEZyb21Qb2ludHModmVydGljZXMpO1xuICAgICAgICB0aGlzLmRyYXdMaW5lKGdlb20sIHRoaXMuaW5kaWNhdG9yTWF0ZXJpYWwsIF9pbmRpY2F0b3JMaW5lV2lkdGgsIElORElDQVRPUl9PVkVSTEFZKTtcblxuICAgICAgICAvLyBCb3R0b20gbGluZVxuICAgICAgICBwLmFkZFZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuc3ViVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzBdID0gcC5jbG9uZSgpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuc3ViVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcC5jbG9uZSgpO1xuICAgICAgICBnZW9tLnNldEZyb21Qb2ludHModmVydGljZXMpO1xuICAgICAgICB0aGlzLmRyYXdMaW5lKGdlb20sIHRoaXMuaW5kaWNhdG9yTWF0ZXJpYWwsIF9pbmRpY2F0b3JMaW5lV2lkdGgsIElORElDQVRPUl9PVkVSTEFZKTtcblxuICAgICAgICAvLyBMZWZ0IGxpbmVcbiAgICAgICAgcC5zdWJWZWN0b3JzKHBvcywgcmlnaHRWZWMpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocCwgdXBWZWMpO1xuICAgICAgICB2ZXJ0aWNlc1swXSA9IHAuY2xvbmUoKTtcbiAgICAgICAgcC5zdWJWZWN0b3JzKHBvcywgcmlnaHRWZWMpO1xuICAgICAgICBwLmFkZFZlY3RvcnMocCwgdXBWZWMpO1xuICAgICAgICB2ZXJ0aWNlc1sxXSA9IHAuY2xvbmUoKTtcbiAgICAgICAgZ2VvbS5zZXRGcm9tUG9pbnRzKHZlcnRpY2VzKTtcbiAgICAgICAgdGhpcy5kcmF3TGluZShnZW9tLCB0aGlzLmluZGljYXRvck1hdGVyaWFsLCBfaW5kaWNhdG9yTGluZVdpZHRoLCBJTkRJQ0FUT1JfT1ZFUkxBWSk7XG5cbiAgICAgICAgLy8gUmlnaHQgbGluZVxuICAgICAgICB2ZXJ0aWNlc1swXSA9IHBvcy5jbG9uZSgpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocG9zLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcC5jbG9uZSgpO1xuICAgICAgICBnZW9tLnNldEZyb21Qb2ludHModmVydGljZXMpO1xuICAgICAgICB0aGlzLmRyYXdMaW5lKGdlb20sIHRoaXMuaW5kaWNhdG9yTWF0ZXJpYWwsIF9pbmRpY2F0b3JMaW5lV2lkdGgsIElORElDQVRPUl9PVkVSTEFZKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYW4gWCBhcm91bmQgdGhlIGdpdmVuIHNuYXAgcmVzdWx0LlxuICAgICAqIFVzdWFsbHkgc2hvd24gd2hlbiB1c2luZyBcIkZyZWUgTWVhc3VyZVwiIG1vZGUgaXMgZW5hYmxlZC5cbiAgICAgKiBAcGFyYW0ge0F1dG9kZXNrLlZpZXdpbmcuTWVhc3VyZUNvbW1vbi5TbmFwUmVzdWx0fSBzbmFwUmVzdWx0XG4gICAgICovXG4gICAgcmVuZGVyUGl4ZWxJbmRpY2F0b3Ioc25hcFJlc3VsdCkge1xuXG4gICAgICAgIGNvbnN0IHBvcyA9IE1lYXN1cmVDb21tb24uZ2V0U25hcFJlc3VsdFBvc2l0aW9uKHNuYXBSZXN1bHQsIHRoaXMudmlld2VyKTtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNldFNjYWxlKHBvcyk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IF9pbmRpY2F0b3JTaXplICogc2NhbGU7XG5cbiAgICAgICAgY29uc3QgcmlnaHRWZWMgPSB0aGlzLnZpZXdlci5uYXZpZ2F0aW9uLmdldENhbWVyYVJpZ2h0VmVjdG9yKCkubXVsdGlwbHlTY2FsYXIobGVuZ3RoKTtcbiAgICAgICAgY29uc3QgdXBWZWMgPSB0aGlzLnZpZXdlci5uYXZpZ2F0aW9uLmdldENhbWVyYVVwVmVjdG9yKCkubXVsdGlwbHlTY2FsYXIobGVuZ3RoKTtcblxuICAgICAgICBjb25zdCBnZW9tID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gW107XG4gICAgICAgIGNvbnN0IHAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIC8vIFRvcC1sZWZ0IGxpbmVcbiAgICAgICAgcC5zdWJWZWN0b3JzKHBvcywgcmlnaHRWZWMpO1xuICAgICAgICBwLmFkZFZlY3RvcnMocCx1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzBdID0gcC5jbG9uZSgpO1xuICAgICAgICB2ZXJ0aWNlc1sxXSA9IHBvcy5jbG9uZSgpO1xuICAgICAgICBnZW9tLnNldEZyb21Qb2ludHModmVydGljZXMpO1xuICAgICAgICB0aGlzLmRyYXdMaW5lKGdlb20sIHRoaXMuaW5kaWNhdG9yTWF0ZXJpYWwsIF9pbmRpY2F0b3JMaW5lV2lkdGgsIElORElDQVRPUl9PVkVSTEFZKTtcblxuICAgICAgICAvLyBUb3AtcmlnaHQgbGluZVxuICAgICAgICBwLmFkZFZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuYWRkVmVjdG9ycyhwLHVwVmVjKTtcbiAgICAgICAgdmVydGljZXNbMF0gPSBwLmNsb25lKCk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcG9zLmNsb25lKCk7XG4gICAgICAgIGdlb20uc2V0RnJvbVBvaW50cyh2ZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMuZHJhd0xpbmUoZ2VvbSwgdGhpcy5pbmRpY2F0b3JNYXRlcmlhbCwgX2luZGljYXRvckxpbmVXaWR0aCwgSU5ESUNBVE9SX09WRVJMQVkpO1xuXG4gICAgICAgIC8vIEJvdHRvbS1yaWdodCBsaW5lXG4gICAgICAgIHAuYWRkVmVjdG9ycyhwb3MsIHJpZ2h0VmVjKTtcbiAgICAgICAgcC5zdWJWZWN0b3JzKHAsIHVwVmVjKTtcbiAgICAgICAgdmVydGljZXNbMF0gPSBwLmNsb25lKCk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcG9zLmNsb25lKCk7XG4gICAgICAgIGdlb20uc2V0RnJvbVBvaW50cyh2ZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMuZHJhd0xpbmUoZ2VvbSwgdGhpcy5pbmRpY2F0b3JNYXRlcmlhbCwgX2luZGljYXRvckxpbmVXaWR0aCwgSU5ESUNBVE9SX09WRVJMQVkpO1xuXG4gICAgICAgIC8vIEJvdHRvbS1sZWZ0IGxpbmVcbiAgICAgICAgcC5zdWJWZWN0b3JzKHBvcywgcmlnaHRWZWMpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocCwgdXBWZWMpO1xuICAgICAgICB2ZXJ0aWNlc1swXSA9IHAuY2xvbmUoKTtcbiAgICAgICAgdmVydGljZXNbMV0gPSBwb3MuY2xvbmUoKTtcbiAgICAgICAgZ2VvbS5zZXRGcm9tUG9pbnRzKHZlcnRpY2VzKTtcbiAgICAgICAgdGhpcy5kcmF3TGluZShnZW9tLCB0aGlzLmluZGljYXRvck1hdGVyaWFsLCBfaW5kaWNhdG9yTGluZVdpZHRoLCBJTkRJQ0FUT1JfT1ZFUkxBWSk7XG5cbiAgICB9XG5cbiAgICByZW5kZXJJbmRpY2F0b3Ioc25hcFJlc3VsdCkge1xuXG4gICAgICAgIGlmIChzbmFwUmVzdWx0LmlzUGVycGVuZGljdWxhcikge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJQZXJwZW5kaWN1bGFyKHNuYXBSZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoc25hcFJlc3VsdC5zbmFwVG9BcmMpIHtcbiAgICAgICAgICAgIGlmKHNuYXBSZXN1bHQuaXNBcmMgJiYgc25hcFJlc3VsdC5nZW9tVHlwZSA9PT0gU25hcFR5cGUuU05BUF9DSVJDVUxBUkFSQyAmJiB0aGlzLnZpZXdlci5tb2RlbC5pczJkKCkgJiYgIXRoaXMudmlld2VyLm1vZGVsLmlzUGRmKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclZlcnRleEluZGljYXRvcihzbmFwUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgc3dpdGNoIChzbmFwUmVzdWx0Lmdlb21UeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFNuYXBUeXBlLlNOQVBfVkVSVEVYOlxuICAgICAgICAgICAgY2FzZSBTbmFwVHlwZS5TTkFQX0lOVEVSU0VDVElPTjpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclZlcnRleEluZGljYXRvcihzbmFwUmVzdWx0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTbmFwVHlwZS5TTkFQX01JRFBPSU5UOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTWlkcG9pbnRJbmRpY2F0b3Ioc25hcFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU25hcFR5cGUuU05BUF9DSVJDTEVfQ0VOVEVSOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQ2lyY2xlSW5kaWNhdG9yKHNuYXBSZXN1bHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNuYXBUeXBlLlNOQVBfRURHRTpcbiAgICAgICAgICAgIGNhc2UgU25hcFR5cGUuU05BUF9DVVJWRURFREdFOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRWRnZUluZGljYXRvcihzbmFwUmVzdWx0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTbmFwVHlwZS5TTkFQX0NJUkNVTEFSQVJDOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdlci5tb2RlbC5pczJkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJWZXJ0ZXhJbmRpY2F0b3Ioc25hcFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDaXJjbGVJbmRpY2F0b3Ioc25hcFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNuYXBUeXBlLlNOQVBfRkFDRTpcbiAgICAgICAgICAgIGNhc2UgU25hcFR5cGUuU05BUF9DVVJWRURGQUNFOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVmVydGV4SW5kaWNhdG9yKHNuYXBSZXN1bHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNuYXBUeXBlLlJBU1RFUl9QSVhFTDpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclBpeGVsSW5kaWNhdG9yKHNuYXBSZXN1bHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBsaW5lIGluIGFuIG92ZXJseWF5XG4gICAgICogQHBhcmFtIHtUSFJFRS5HZW9tZXRyeXxUSFJFRS5CdWZmZXJHZW9tZXRyeX0gZ2VvbSBcbiAgICAgKiBAcGFyYW0ge1RIUkVFLk1hdGVyaWFsfSBtYXRlcmlhbCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG92ZXJsYXlOYW1lIFxuICAgICAqL1xuICAgIGRyYXdMaW5lKGdlb20sIG1hdGVyaWFsLCB3aWR0aCwgb3ZlcmxheU5hbWUpIHtcblxuICAgICAgICAvLyBMaW5lIFBpZWNlc1xuICAgICAgICBpZiAob3ZlcmxheU5hbWUgPT09IEdFT01FVFJJRVNfT1ZFUkxBWSkge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5VHlwZSA9IEVER0VfT1ZFUkxBWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB2ZXJ0aWNlc0xlbmd0aCwgZ2VvbVBvcztcbiAgICAgICAgaWYgKGdlb20gaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCAnU25hcHBlckluZGljYXRvci5kcmF3TGluZShnZW9tLCBtYXRlcmlhbCwgd2lkdGgsIG92ZXJsYXlOYW1lKTogVEhSRUUuR2VvbWV0cnkgaGFzIGJlZW4gZGVwZWNyYXRlZCBhbmQgdGhlIGdlb20gYXJndW1lbnQgc2hvdWxkIHVzZSBhIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQnICk7XG4gICAgICAgICAgICB2ZXJ0aWNlc0xlbmd0aCA9IGdlb20udmVydGljZXMubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2VvbVBvcyA9IGdlb20uZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuICAgICAgICAgICAgdmVydGljZXNMZW5ndGggPSBnZW9tUG9zLmNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGljZXNMZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGN5bGluZGVyO1xuICAgICAgICAgICAgaWYgKGdlb20gaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSkge1xuICAgICAgICAgICAgICAgIGN5bGluZGVyID0gdGhpcy5jeWxpbmRlck1lc2goZ2VvbS52ZXJ0aWNlc1tpXSwgZ2VvbS52ZXJ0aWNlc1tpICsgMV0sIG1hdGVyaWFsLCB3aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN5bGluZGVyID0gdGhpcy5jeWxpbmRlck1lc2goZ2V0WFlaRnJvbVBvcyhnZW9tUG9zLCBpKS5jbG9uZSgpLCBnZXRYWVpGcm9tUG9zKGdlb21Qb3MsIGkgKyAxKS5jbG9uZSgpLCBtYXRlcmlhbCwgd2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRFZGdlU2NhbGUoY3lsaW5kZXIpO1xuICAgICAgICAgICAgdGhpcy5hZGRPdmVybGF5KG92ZXJsYXlOYW1lLCBjeWxpbmRlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkcmF3UG9pbnQocG9pbnQsIG1hdGVyaWFsLCBvdmVybGF5TmFtZSkge1xuXG4gICAgICAgIC8vIEJlY2F1c2UgZXZlcnkgcG9pbnQgaXMgc25hcHBhYmxlIGluIFBERnMsIGRvbid0IGRpc3BsYXkgdGhlIGdyZWVuIGRvdCBmb3IgUERGcy5cbiAgICAgICAgaWYgKHRoaXMudmlld2VyLm1vZGVsLmlzTGVhZmxldCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIV9wb2ludClcbiAgICAgICAgICAgIF9wb2ludCA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgxLjApO1xuXG4gICAgICAgIGNvbnN0IHBvaW50TWVzaCA9IG5ldyBUSFJFRS5NZXNoKF9wb2ludCwgbWF0ZXJpYWwpO1xuICAgICAgICBwb2ludE1lc2gucG9zaXRpb24uc2V0KHBvaW50LngsIHBvaW50LnksIHBvaW50LnopO1xuXG4gICAgICAgIHRoaXMuc2V0UG9pbnRTY2FsZShwb2ludE1lc2gpO1xuXG4gICAgICAgIGlmIChvdmVybGF5TmFtZSA9PT0gR0VPTUVUUklFU19PVkVSTEFZKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlUeXBlID0gUE9JTlRfT1ZFUkxBWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkT3ZlcmxheShvdmVybGF5TmFtZSwgcG9pbnRNZXNoKTtcblxuICAgIH1cblxuICAgIGRyYXdDaXJjbGUocG9pbnQsIG1hdGVyaWFsLCBvdmVybGF5TmFtZSkge1xuXG4gICAgICAgIGxldCB0b3J1cyA9IG5ldyBUSFJFRS5Ub3J1c0dlb21ldHJ5KF9pbmRpY2F0b3JTaXplLCBfaW5kaWNhdG9yTGluZVdpZHRoLCAyLCAyMCk7XG4gICAgICAgIGNvbnN0IHRvcnVzTWVzaCA9IG5ldyBUSFJFRS5NZXNoKHRvcnVzLCBtYXRlcmlhbCk7XG4gICAgICAgIHRvcnVzTWVzaC5sb29rQXQodGhpcy52aWV3ZXIubmF2aWdhdGlvbi5nZXRFeWVWZWN0b3IoKS5ub3JtYWxpemUoKSk7XG4gICAgICAgIHRvcnVzID0gbnVsbDtcblxuICAgICAgICB0b3J1c01lc2gucG9zaXRpb24uc2V0KHBvaW50LngsIHBvaW50LnksIHBvaW50LnopO1xuXG4gICAgICAgIHRoaXMuc2V0Q2lyY2xlU2NhbGUodG9ydXNNZXNoKTtcblxuICAgICAgICB0aGlzLmFkZE92ZXJsYXkob3ZlcmxheU5hbWUsIHRvcnVzTWVzaCk7XG5cbiAgICB9XG5cbiAgICBzZXRTY2FsZShwb2ludCkge1xuXG4gICAgICAgIGNvbnN0IHBpeGVsU2l6ZSA9IDU7XG5cbiAgICAgICAgY29uc3QgbmF2YXBpID0gdGhpcy52aWV3ZXIubmF2aWdhdGlvbjtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gbmF2YXBpLmdldENhbWVyYSgpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IG5hdmFwaS5nZXRQb3NpdGlvbigpO1xuXG4gICAgICAgIGNvbnN0IHAgPSBwb2ludC5jbG9uZSgpO1xuXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gY2FtZXJhLmlzUGVyc3BlY3RpdmUgPyBwLnN1Yihwb3NpdGlvbikubGVuZ3RoKClcbiAgICAgICAgICAgIDogbmF2YXBpLmdldEV5ZVZlY3RvcigpLmxlbmd0aCgpO1xuXG4gICAgICAgIGNvbnN0IGZvdiA9IG5hdmFwaS5nZXRWZXJ0aWNhbEZvdigpO1xuICAgICAgICBjb25zdCB3b3JsZEhlaWdodCA9IDIuMCAqIGRpc3RhbmNlICogTWF0aC50YW4oVEhSRUUuTWF0aC5kZWdUb1JhZChmb3YgKiAwLjUpKTtcblxuICAgICAgICBjb25zdCB2aWV3cG9ydCA9IG5hdmFwaS5nZXRTY3JlZW5WaWV3cG9ydCgpO1xuICAgICAgICBjb25zdCBzY2FsZSA9IHBpeGVsU2l6ZSAqIHdvcmxkSGVpZ2h0IC8gdmlld3BvcnQuaGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9XG5cbiAgICBzZXRQb2ludFNjYWxlKHBvaW50TWVzaCkge1xuXG4gICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zZXRTY2FsZShwb2ludE1lc2gucG9zaXRpb24pO1xuICAgICAgICBwb2ludE1lc2guc2NhbGUueCA9IHNjYWxlO1xuICAgICAgICBwb2ludE1lc2guc2NhbGUueSA9IHNjYWxlO1xuICAgICAgICBwb2ludE1lc2guc2NhbGUueiA9IHNjYWxlO1xuXG4gICAgfVxuXG4gICAgc2V0Q2lyY2xlU2NhbGUodG9ydXNNZXNoKSB7XG5cbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNldFNjYWxlKHRvcnVzTWVzaC5wb3NpdGlvbik7XG4gICAgICAgIHRvcnVzTWVzaC5zY2FsZS54ID0gc2NhbGU7XG4gICAgICAgIHRvcnVzTWVzaC5zY2FsZS55ID0gc2NhbGU7XG4gICAgfVxuXG4gICAgc2V0RWRnZVNjYWxlKGN5bGluZGVyTWVzaCkge1xuXG4gICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zZXRTY2FsZShjeWxpbmRlck1lc2gucG9zaXRpb24pO1xuICAgICAgICBjeWxpbmRlck1lc2guc2NhbGUueCA9IHNjYWxlO1xuICAgICAgICBjeWxpbmRlck1lc2guc2NhbGUueiA9IHNjYWxlO1xuICAgIH1cblxuICAgIHVwZGF0ZVBvaW50U2NhbGUob3ZlcmxheU5hbWUpIHtcblxuICAgICAgICBpZiAodGhpcy5vdmVybGF5VHlwZSAhPT0gUE9JTlRfT1ZFUkxBWSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjb25zdCBvdmVybGF5ID0gdGhpcy52aWV3ZXIuaW1wbC5vdmVybGF5U2NlbmVzW292ZXJsYXlOYW1lXTtcbiAgICAgICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjZW5lID0gb3ZlcmxheS5zY2VuZTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2VuZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50TWVzaCA9IHNjZW5lLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludE1lc2gpIHtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvaW50U2NhbGUocG9pbnRNZXNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVFZGdlU2NhbGUob3ZlcmxheU5hbWUpIHtcblxuICAgICAgICBpZiAodGhpcy5vdmVybGF5VHlwZSAhPT0gRURHRV9PVkVSTEFZKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IG92ZXJsYXkgPSB0aGlzLnZpZXdlci5pbXBsLm92ZXJsYXlTY2VuZXNbb3ZlcmxheU5hbWVdO1xuICAgICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICAgICAgY29uc3Qgc2NlbmUgPSBvdmVybGF5LnNjZW5lO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjZW5lLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3lsaW5kZXJNZXNoID0gc2NlbmUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGN5bGluZGVyTWVzaCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RWRnZVNjYWxlKGN5bGluZGVyTWVzaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25DYW1lcmFDaGFuZ2UoKSB7XG5cbiAgICAgICAgdGhpcy51cGRhdGVQb2ludFNjYWxlKEdFT01FVFJJRVNfT1ZFUkxBWSk7XG4gICAgICAgIHRoaXMudXBkYXRlRWRnZVNjYWxlKEdFT01FVFJJRVNfT1ZFUkxBWSk7XG5cbiAgICAgICAgLy8gaWYgKCF0aGlzLnNuYXBwZXIubWFya3VwTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgLy8gfVxuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG5cbiAgICAgICAgdGhpcy5yZW1vdmVPdmVybGF5KEdFT01FVFJJRVNfT1ZFUkxBWSk7XG4gICAgICAgIHRoaXMucmVtb3ZlT3ZlcmxheShJTkRJQ0FUT1JfT1ZFUkxBWSk7XG5cbiAgICAgICAgaWYgKF9wb2ludCkge1xuICAgICAgICAgICAgX3BvaW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIF9wb2ludCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOlsiTWVhc3VyZUNvbW1vbiIsIkF1dG9kZXNrIiwiVmlld2luZyIsImlzRXF1YWxWZWN0b3JzIiwiRVBTSUxPTiIsIlNuYXBUeXBlIiwiTk9fT1ZFUkxBWSIsIkZBQ0VfT1ZFUkxBWSIsIkVER0VfT1ZFUkxBWSIsIlBPSU5UX09WRVJMQVkiLCJHRU9NRVRSSUVTX09WRVJMQVkiLCJJTkRJQ0FUT1JfT1ZFUkxBWSIsIl9nZW9tZXRyeUxpbmVXaWR0aCIsIl9pbmRpY2F0b3JMaW5lV2lkdGgiLCJfaW5kaWNhdG9yU2l6ZSIsIl9pbmRpY2F0b3JDb2xvciIsIl9nZW9tZXRyeUNvbG9yIiwiX3BvaW50IiwidG1wVmVjMyIsIlRIUkVFIiwiVmVjdG9yMyIsImdldFhZWkZyb21Qb3MiLCJwb3NpdGlvbkF0dHJpYnV0ZSIsImlkeCIsIngiLCJnZXRYIiwieSIsImdldFkiLCJ6IiwiZ2V0WiIsIk51bGxTbmFwcGVySW5kaWNhdG9yIiwiaXNOdWxsIiwicmVuZGVyIiwicmVtb3ZlT3ZlcmxheSIsIm92ZXJsYXlOYW1lIiwiY2xlYXJPdmVybGF5IiwiY2xlYXJPdmVybGF5cyIsImFkZE92ZXJsYXkiLCJtZXNoIiwiZHJhd0ZhY2UiLCJnZW9tIiwibWF0ZXJpYWwiLCJjeWxpbmRlck1lc2giLCJwb2ludFgiLCJwb2ludFkiLCJ3aWR0aCIsIk1lc2giLCJyZW5kZXJHZW9tZXRyeSIsInNuYXBSZXN1bHQiLCJyZW5kZXJWZXJ0ZXhJbmRpY2F0b3IiLCJyZW5kZXJNaWRwb2ludEluZGljYXRvciIsInJlbmRlckVkZ2VJbmRpY2F0b3IiLCJyZW5kZXJDaXJjbGVJbmRpY2F0b3IiLCJyZW5kZXJQZXJwZW5kaWN1bGFyIiwicmVuZGVyUGl4ZWxJbmRpY2F0b3IiLCJyZW5kZXJJbmRpY2F0b3IiLCJkcmF3TGluZSIsImRyYXdQb2ludCIsInBvaW50IiwiZHJhd0NpcmNsZSIsInNldFNjYWxlIiwic2V0UG9pbnRTY2FsZSIsInBvaW50TWVzaCIsInNldENpcmNsZVNjYWxlIiwidG9ydXNNZXNoIiwic2V0RWRnZVNjYWxlIiwidXBkYXRlUG9pbnRTY2FsZSIsInVwZGF0ZUVkZ2VTY2FsZSIsIm9uQ2FtZXJhQ2hhbmdlIiwiZGVzdHJveSIsIlNuYXBwZXJJbmRpY2F0b3IiLCJjb25zdHJ1Y3RvciIsInZpZXdlciIsInNuYXBwZXIiLCJvdmVybGF5VHlwZSIsInByZXZpZXdzSW50ZXJzZWN0UG9pbnQiLCJpbXBsIiwiY3JlYXRlT3ZlcmxheVNjZW5lIiwiZ2VvbWV0cnlNYXRlcmlhbCIsIk1lc2hQaG9uZ01hdGVyaWFsIiwiY29sb3IiLCJvcGFjaXR5IiwidHJhbnNwYXJlbnQiLCJkZXB0aFRlc3QiLCJkZXB0aFdyaXRlIiwic2lkZSIsIkRvdWJsZVNpZGUiLCJpbmRpY2F0b3JNYXRlcmlhbCIsIk1lc2hCYXNpY01hdGVyaWFsIiwiZ2V0U25hcFJlc3VsdCIsImludGVyc2VjdFBvaW50IiwiaXNFbXB0eSIsInJlbmRlclNuYXBwZWRHZW9tZXRyeSIsImhhc1RvcG9sb2d5IiwicmVuZGVyU25hcHBlZFRvcG9sb2d5IiwiY2xvbmUiLCJyZW1vdmVPdmVybGF5U2NlbmUiLCJzbmFwcGVyUGxhbmUiLCJkaXJlY3Rpb24iLCJzdWJWZWN0b3JzIiwib3JpZW50YXRpb24iLCJNYXRyaXg0IiwibG9va0F0IiwiT2JqZWN0M0QiLCJ1cCIsIm11bHRpcGx5Iiwic2V0IiwibGVuZ3RoIiwiY3lsaW5kZXIiLCJDeWxpbmRlckdlb21ldHJ5IiwiZWRnZSIsImFwcGx5TWF0cml4NCIsInBvc2l0aW9uIiwiZ2VvbVR5cGUiLCJTTkFQX1ZFUlRFWCIsIlJBU1RFUl9QSVhFTCIsImdlb21WZXJ0ZXgiLCJTTkFQX0VER0UiLCJTTkFQX0NVUlZFREVER0UiLCJTTkFQX0NJUkNVTEFSQVJDIiwiU05BUF9NSURQT0lOVCIsImdlb21FZGdlIiwiU05BUF9GQUNFIiwiU05BUF9DVVJWRURGQUNFIiwiZ2VvbUZhY2UiLCJwb3MiLCJnZXRTbmFwUmVzdWx0UG9zaXRpb24iLCJzY2FsZSIsInJpZ2h0VmVjIiwibmF2aWdhdGlvbiIsImdldENhbWVyYVJpZ2h0VmVjdG9yIiwibXVsdGlwbHlTY2FsYXIiLCJ1cFZlYyIsImdldENhbWVyYVVwVmVjdG9yIiwiQnVmZmVyR2VvbWV0cnkiLCJ2ZXJ0aWNlcyIsInAiLCJhZGRWZWN0b3JzIiwic2V0RnJvbVBvaW50cyIsImlzUGVycGVuZGljdWxhciIsInNuYXBUb0FyYyIsImlzQXJjIiwibW9kZWwiLCJpczJkIiwiaXNQZGYiLCJTTkFQX0lOVEVSU0VDVElPTiIsIlNOQVBfQ0lSQ0xFX0NFTlRFUiIsInZlcnRpY2VzTGVuZ3RoIiwiZ2VvbVBvcyIsIkdlb21ldHJ5IiwiY29uc29sZSIsIndhcm4iLCJnZXRBdHRyaWJ1dGUiLCJjb3VudCIsImkiLCJpc0xlYWZsZXQiLCJTcGhlcmVHZW9tZXRyeSIsInRvcnVzIiwiVG9ydXNHZW9tZXRyeSIsImdldEV5ZVZlY3RvciIsIm5vcm1hbGl6ZSIsInBpeGVsU2l6ZSIsIm5hdmFwaSIsImNhbWVyYSIsImdldENhbWVyYSIsImdldFBvc2l0aW9uIiwiZGlzdGFuY2UiLCJpc1BlcnNwZWN0aXZlIiwic3ViIiwiZm92IiwiZ2V0VmVydGljYWxGb3YiLCJ3b3JsZEhlaWdodCIsIk1hdGgiLCJ0YW4iLCJkZWdUb1JhZCIsInZpZXdwb3J0IiwiZ2V0U2NyZWVuVmlld3BvcnQiLCJoZWlnaHQiLCJvdmVybGF5Iiwib3ZlcmxheVNjZW5lcyIsInNjZW5lIiwiY2hpbGRyZW4iLCJkaXNwb3NlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./extensions/Snapping/SnapperIndicator.js\n");

                /***/
            }),

        /***/
        "./extensions/Snapping/index.js":
            /*!**************************************!*\
              !*** ./extensions/Snapping/index.js ***!
              \**************************************/
            /***/
            ((module, __unused_webpack_exports, __webpack_require__) => {

                eval("\nvar av = Autodesk.Viewing;\n\n/**\n * @namespace Autodesk.Viewing.Extensions.Snapping\n */\nvar namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.Snapping');\n\n/**\n * @param m\n * @param ns\n * @private\n */\nfunction _export(m, ns) {\n  for (var prop in m) {\n    if (Object.prototype.hasOwnProperty.call(m, prop)) {\n      //Export directly into the module (e.g. for node.js use, where LMV is used via require instead from global namespace)\n      module.exports[prop] = m[prop];\n\n      //Export into the desired viewer namespace\n      ns[prop] = m[prop];\n    }\n  }\n}\n\n_export(__webpack_require__(/*! ./SnapMath.js */ \"./extensions/Snapping/SnapMath.js\"), namespace);\n_export(__webpack_require__(/*! ./Snapper.js */ \"./extensions/Snapping/Snapper.js\"), namespace);\n_export(__webpack_require__(/*! ./SnapperIndicator.js */ \"./extensions/Snapping/SnapperIndicator.js\"), namespace);\n\n\n/**\n * Utility extension that provides access to the {@link Autodesk.Viewing.Extensions.Snapping.Snapper} tool.\n * \n * The extension id is: `Autodesk.Snapping`\n * \n * @example\n *   viewer.loadExtension('Autodesk.Snapping')\n *  \n * @memberof Autodesk.Viewing.Extensions\n * @alias Autodesk.Viewing.Extensions.SnappingExtension\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n * @class\n */\nclass SnappingExtension extends av.Extension {\n\n  /**\n   * @param {Viewer3D} viewer - Viewer instance\n   * @param {object} options - Configurations for the extension\n   * @alias Autodesk.Viewing.Extensions.SnappingExtension\n   * @class\n   */\n  constructor(viewer, options) {\n    super(viewer, options);\n  }\n\n  /**\n   * Load the extension.\n   *\n   * @returns {Promise} that resolves when dependent extension finishes loading.\n   * \n   * @alias Autodesk.Viewing.Extensions.SnappingExtension#load\n   */\n  load() {\n    // Load the required dependency (and return the pending load as the load completion Promise)\n    return this.viewer.loadExtension('Autodesk.CompGeom');\n  }\n\n  /**\n   * Unloads the extension.\n   * It does not unload dependent extensions.\n   *\n   * @returns {boolean} Always returns true\n   * \n   * @alias Autodesk.Viewing.Extensions.SnappingExtension#unload\n   */\n  unload() {return true;}\n\n\n  /**\n   * Unused method.\n   *\n   * @returns {boolean} Always returns true\n   * \n   * @alias Autodesk.Viewing.Extensions.SnappingExtension#activate\n   */\n  activate() {return true;}\n\n  /**\n   * Unused method.\n   *\n   * @returns {boolean} Always returns false\n   * \n   * @alias Autodesk.Viewing.Extensions.SnappingExtension#deactivate\n   */\n  deactivate() {return false;}\n}\n\n// The ExtensionManager requires an extension to be registered.\nav.theExtensionManager.registerExtension('Autodesk.Snapping', SnappingExtension);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leHRlbnNpb25zL1NuYXBwaW5nL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFDQSxJQUFJQSxFQUFFLEdBQUdDLFFBQVEsQ0FBQ0MsT0FBTzs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsSUFBSUMsU0FBUyxHQUFHQyxpQkFBaUIsQ0FBQyxzQ0FBc0MsQ0FBQzs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNDLE9BQU9BLENBQUNDLENBQUMsRUFBRUMsRUFBRSxFQUFFO0VBQ3BCLEtBQUssSUFBSUMsSUFBSSxJQUFJRixDQUFDLEVBQUU7SUFDaEIsSUFBSUcsTUFBTSxDQUFDQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDTixDQUFDLEVBQUVFLElBQUksQ0FBQyxFQUFFO01BQy9DO01BQ0FLLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDTixJQUFJLENBQUMsR0FBR0YsQ0FBQyxDQUFDRSxJQUFJLENBQUM7O01BRTlCO01BQ0FELEVBQUUsQ0FBQ0MsSUFBSSxDQUFDLEdBQUdGLENBQUMsQ0FBQ0UsSUFBSSxDQUFDO0lBQ3RCO0VBQ0o7QUFDSjs7QUFFQUgsT0FBTyxDQUFDVSxtQkFBTyxDQUFDLHdEQUFlLENBQUMsRUFBRVosU0FBUyxDQUFDO0FBQzVDRSxPQUFPLENBQUNVLG1CQUFPLENBQUMsc0RBQWMsQ0FBQyxFQUFFWixTQUFTLENBQUM7QUFDM0NFLE9BQU8sQ0FBQ1UsbUJBQU8sQ0FBQyx3RUFBdUIsQ0FBQyxFQUFFWixTQUFTLENBQUM7OztBQUdwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1hLGlCQUFpQixTQUFTaEIsRUFBRSxDQUFDaUIsU0FBUyxDQUFDOztFQUV6QztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsV0FBV0EsQ0FBQ0MsTUFBTSxFQUFFQyxPQUFPLEVBQUU7SUFDekIsS0FBSyxDQUFDRCxNQUFNLEVBQUVDLE9BQU8sQ0FBQztFQUMxQjs7RUFFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxJQUFJQSxDQUFBLEVBQUc7SUFDSDtJQUNBLE9BQU8sSUFBSSxDQUFDRixNQUFNLENBQUNHLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQztFQUN6RDs7RUFFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLE1BQU1BLENBQUEsRUFBRyxDQUFFLE9BQU8sSUFBSSxDQUFFOzs7RUFHeEI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsUUFBUUEsQ0FBQSxFQUFHLENBQUUsT0FBTyxJQUFJLENBQUU7O0VBRTFCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLFVBQVVBLENBQUEsRUFBRyxDQUFFLE9BQU8sS0FBSyxDQUFFO0FBQ2pDOztBQUVBO0FBQ0F6QixFQUFFLENBQUMwQixtQkFBbUIsQ0FBQ0MsaUJBQWlCLENBQUMsbUJBQW1CLEVBQUVYLGlCQUFpQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQXV0b2Rlc2suRXh0ZW5zaW9ucy8uL2V4dGVuc2lvbnMvU25hcHBpbmcvaW5kZXguanM/Y2JhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBhdiA9IEF1dG9kZXNrLlZpZXdpbmc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuU25hcHBpbmdcbiAqL1xudmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrTmFtZXNwYWNlKCdBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuU25hcHBpbmcnKTtcblxuLyoqXG4gKiBAcGFyYW0gbVxuICogQHBhcmFtIG5zXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZXhwb3J0KG0sIG5zKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBtKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobSwgcHJvcCkpIHtcbiAgICAgICAgICAgIC8vRXhwb3J0IGRpcmVjdGx5IGludG8gdGhlIG1vZHVsZSAoZS5nLiBmb3Igbm9kZS5qcyB1c2UsIHdoZXJlIExNViBpcyB1c2VkIHZpYSByZXF1aXJlIGluc3RlYWQgZnJvbSBnbG9iYWwgbmFtZXNwYWNlKVxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHNbcHJvcF0gPSBtW3Byb3BdO1xuXG4gICAgICAgICAgICAvL0V4cG9ydCBpbnRvIHRoZSBkZXNpcmVkIHZpZXdlciBuYW1lc3BhY2VcbiAgICAgICAgICAgIG5zW3Byb3BdID0gbVtwcm9wXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuX2V4cG9ydChyZXF1aXJlKFwiLi9TbmFwTWF0aC5qc1wiKSwgbmFtZXNwYWNlKTtcbl9leHBvcnQocmVxdWlyZShcIi4vU25hcHBlci5qc1wiKSwgbmFtZXNwYWNlKTtcbl9leHBvcnQocmVxdWlyZShcIi4vU25hcHBlckluZGljYXRvci5qc1wiKSwgbmFtZXNwYWNlKTtcblxuXG4vKipcbiAqIFV0aWxpdHkgZXh0ZW5zaW9uIHRoYXQgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSB7QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLlNuYXBwaW5nLlNuYXBwZXJ9IHRvb2wuXG4gKiBcbiAqIFRoZSBleHRlbnNpb24gaWQgaXM6IGBBdXRvZGVzay5TbmFwcGluZ2BcbiAqIFxuICogQGV4YW1wbGVcbiAqICAgdmlld2VyLmxvYWRFeHRlbnNpb24oJ0F1dG9kZXNrLlNuYXBwaW5nJylcbiAqICBcbiAqIEBtZW1iZXJvZiBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnNcbiAqIEBhbGlhcyBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuU25hcHBpbmdFeHRlbnNpb25cbiAqIEBzZWUge0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ufSBmb3IgY29tbW9uIGluaGVyaXRlZCBtZXRob2RzLlxuICogQGNsYXNzXG4gKi9cbmNsYXNzIFNuYXBwaW5nRXh0ZW5zaW9uIGV4dGVuZHMgYXYuRXh0ZW5zaW9uIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Vmlld2VyM0R9IHZpZXdlciAtIFZpZXdlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbnMgZm9yIHRoZSBleHRlbnNpb25cbiAgICAgKiBAYWxpYXMgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLlNuYXBwaW5nRXh0ZW5zaW9uXG4gICAgICogQGNsYXNzXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iodmlld2VyLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHZpZXdlciwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgZXh0ZW5zaW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgd2hlbiBkZXBlbmRlbnQgZXh0ZW5zaW9uIGZpbmlzaGVzIGxvYWRpbmcuXG4gICAgICogXG4gICAgICogQGFsaWFzIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5TbmFwcGluZ0V4dGVuc2lvbiNsb2FkXG4gICAgICovXG4gICAgbG9hZCgpIHsgXG4gICAgICAgIC8vIExvYWQgdGhlIHJlcXVpcmVkIGRlcGVuZGVuY3kgKGFuZCByZXR1cm4gdGhlIHBlbmRpbmcgbG9hZCBhcyB0aGUgbG9hZCBjb21wbGV0aW9uIFByb21pc2UpXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdlci5sb2FkRXh0ZW5zaW9uKCdBdXRvZGVzay5Db21wR2VvbScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVubG9hZHMgdGhlIGV4dGVuc2lvbi5cbiAgICAgKiBJdCBkb2VzIG5vdCB1bmxvYWQgZGVwZW5kZW50IGV4dGVuc2lvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQWx3YXlzIHJldHVybnMgdHJ1ZVxuICAgICAqIFxuICAgICAqIEBhbGlhcyBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuU25hcHBpbmdFeHRlbnNpb24jdW5sb2FkXG4gICAgICovXG4gICAgdW5sb2FkKCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cbiAgICAvKipcbiAgICAgKiBVbnVzZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IEFsd2F5cyByZXR1cm5zIHRydWVcbiAgICAgKiBcbiAgICAgKiBAYWxpYXMgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLlNuYXBwaW5nRXh0ZW5zaW9uI2FjdGl2YXRlXG4gICAgICovXG4gICAgYWN0aXZhdGUoKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgICAvKipcbiAgICAgKiBVbnVzZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IEFsd2F5cyByZXR1cm5zIGZhbHNlXG4gICAgICogXG4gICAgICogQGFsaWFzIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5TbmFwcGluZ0V4dGVuc2lvbiNkZWFjdGl2YXRlXG4gICAgICovXG4gICAgZGVhY3RpdmF0ZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbi8vIFRoZSBFeHRlbnNpb25NYW5hZ2VyIHJlcXVpcmVzIGFuIGV4dGVuc2lvbiB0byBiZSByZWdpc3RlcmVkLlxuYXYudGhlRXh0ZW5zaW9uTWFuYWdlci5yZWdpc3RlckV4dGVuc2lvbignQXV0b2Rlc2suU25hcHBpbmcnLCBTbmFwcGluZ0V4dGVuc2lvbik7XG5cbiJdLCJuYW1lcyI6WyJhdiIsIkF1dG9kZXNrIiwiVmlld2luZyIsIm5hbWVzcGFjZSIsIkF1dG9kZXNrTmFtZXNwYWNlIiwiX2V4cG9ydCIsIm0iLCJucyIsInByb3AiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIlNuYXBwaW5nRXh0ZW5zaW9uIiwiRXh0ZW5zaW9uIiwiY29uc3RydWN0b3IiLCJ2aWV3ZXIiLCJvcHRpb25zIiwibG9hZCIsImxvYWRFeHRlbnNpb24iLCJ1bmxvYWQiLCJhY3RpdmF0ZSIsImRlYWN0aXZhdGUiLCJ0aGVFeHRlbnNpb25NYW5hZ2VyIiwicmVnaXN0ZXJFeHRlbnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./extensions/Snapping/index.js\n");

                /***/
            })

        /******/
    });
    /************************************************************************/
    /******/ // The module cache
    /******/
    var __webpack_module_cache__ = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/
        var cachedModule = __webpack_module_cache__[moduleId];
        /******/
        if (cachedModule !== undefined) {
            /******/
            return cachedModule.exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = __webpack_module_cache__[moduleId] = {
            /******/ // no module.id needed
            /******/ // no module.loaded needed
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /************************************************************************/
    /******/
    /* webpack/runtime/define property getters */
    /******/
    (() => {
        /******/ // define getter functions for harmony exports
        /******/
        __webpack_require__.d = (exports, definition) => {
            /******/
            for (var key in definition) {
                /******/
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                    /******/
                    Object.defineProperty(exports, key, {
                        enumerable: true,
                        get: definition[key]
                    });
                    /******/
                }
                /******/
            }
            /******/
        };
        /******/
    })();
    /******/
    /******/
    /* webpack/runtime/hasOwnProperty shorthand */
    /******/
    (() => {
        /******/
        __webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
        /******/
    })();
    /******/
    /******/
    /* webpack/runtime/make namespace object */
    /******/
    (() => {
        /******/ // define __esModule on exports
        /******/
        __webpack_require__.r = (exports) => {
            /******/
            if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                /******/
                Object.defineProperty(exports, Symbol.toStringTag, {
                    value: 'Module'
                });
                /******/
            }
            /******/
            Object.defineProperty(exports, '__esModule', {
                value: true
            });
            /******/
        };
        /******/
    })();
    /******/
    /************************************************************************/
    /******/
    /******/ // startup
    /******/ // Load entry module and return exports
    /******/ // This entry module is referenced by other modules so it can't be inlined
    /******/
    var __webpack_exports__ = __webpack_require__("./extensions/Snapping/index.js");
    /******/
    Autodesk.Extensions.Snapping = __webpack_exports__;
    /******/
    /******/
})();