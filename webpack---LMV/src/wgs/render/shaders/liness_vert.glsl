module.exports = "\n#include <line_decl_common>\n#include <logdepthbuf_decl_vert>\nattribute vec2 fields1;\nattribute vec4 fields2;\nattribute vec4 flags4b;\nattribute vec4 layerVp4b;\n#ifdef HAS_MITER_LINES\nattribute vec3 extraParams;\nuniform float miterLimit;\nuniform float miterScaleFactor;\nuniform float miterCP;\n#endif\n#ifdef USE_INSTANCING\nattribute vec4 instFlags4b;\n#endif\n#ifdef VIEWPORT_CLIPPING\nvarying vec2 vPosition;\n#endif\nuniform mat4 mvpMatrix;\nuniform float pixelsPerUnit;\nuniform float aaRange;\nuniform vec2 size;\nuniform float viewportId;\nuniform float swap;\nuniform vec3 cameraPos;\nuniform float tanHalfFov;\n#ifdef HAS_LINESTYLES\nvarying float vPixelsPerUnit;\n#endif\n#ifdef HAS_LAYERS\nuniform sampler2D tLayerMask;\n#endif\n#ifdef SELECTION_RENDERER\nuniform sampler2D tSelectionTexture;\nuniform vec2 vSelTexSize;\n#endif\n#ifdef SELECTION_RENDERER\nuniform vec4 selectionColor;\n#endif\n#ifdef LOADING_ANIMATION\nuniform float meshAnimTime;\n#endif\n#if NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\nvarying vec4 dbId;\n#ifdef UNPACK_POSITIONS\nuniform sampler2D tIdColor;\nuniform vec2 vIdColorTexSize;\nuniform vec4 unpackXform;\nattribute vec2 uvIdColor;\nfloat unpackLineWeight(float w) {\n    if (w > 0.5) {\n        return - (w - 0.5) * 1024.0;\n    } else {\n        return w * max(unpackXform.x, unpackXform.y) * 2.0;\n    }\n}\nvec4 getVertexColor() {\n    float u = (uvIdColor.x + 0.5) / vIdColorTexSize.x;\n    return texture2D(tIdColor, vec2(u, 0.5));\n}\nvec4 getDbId() {\n    float u = (uvIdColor.y + 0.5) / vIdColorTexSize.x;\n    vec4 normDbId = texture2D(tIdColor, vec2(u, 0.5));\n    return normDbId * 255.0;\n}\n#else\nattribute vec4 color4b;\nattribute vec4 dbId4b;\nvec4 unpackXform;\nfloat unpackLineWeight(float w) {\n    return w;\n}\nvec4 getVertexColor() {\n    return color4b;\n}\nvec4 getDbId() {\n    return dbId4b;\n}\n#endif\nvec2 centralVertex;\nvec2 offsetPosition;\nvec2 offsetPosDepth;\nvec2 cos_sin(const float angle) { return vec2(cos(angle), sin(angle)); }\nvoid min_max(inout vec2 minPt, inout vec2 maxPt, const vec2 p) {\n    minPt = min(minPt, p);\n    maxPt = max(maxPt, p);\n}\n#if defined(USE_INSTANCING)\nfloat getVertexId() { return instFlags4b.x; }\n#else\nfloat getVertexId() { return flags4b.x; }\n#endif\nbool isStartVertex() { return (getVertexId() < VBB_SEG_END_RIGHT); }\nbool isLeftVertex()  { float id = getVertexId(); return ((id == VBB_SEG_END_LEFT || id == VBB_SEG_START_LEFT)); }\nstruct SegmentData { float angle, distAlong, distTotal, lineWidthHalf, lineType; };\nvoid decodeSegmentData(out SegmentData seg) {\n    seg.angle         = fields2.x * TAU - PI;\n    seg.distAlong     = fields2.y * max(unpackXform.x, unpackXform.y);\n    seg.distTotal     = fields2.w;\n    seg.lineWidthHalf = unpackLineWeight(fields2.z);\n    seg.lineType      = flags4b.z;\n}\nvoid strokeLineSegment(float geomType) {\n    SegmentData seg; decodeSegmentData(seg);\n    float isStartCapVertex = isStartVertex() ? -1.0 :  1.0;\n    float isLeftSide       = isLeftVertex( ) ?  1.0 : -1.0;\n    vec4 startPosition = (mvpMatrix * modelMatrix * vec4(centralVertex.xy, 0.0, 1.0));\n    float distanceAlong = seg.distAlong;\n    vec2 along = distanceAlong * cos_sin(seg.angle);\n    vec4 endPosition = (mvpMatrix * modelMatrix * vec4(centralVertex.xy + along, 0.0, 1.0));\n    vec2 screenStart = startPosition.xy * 0.5 * size / startPosition.w;\n    vec2 screenEnd = endPosition.xy * 0.5 * size / endPosition.w;\n    float roundedEnd = 0.0;\n    if (isStartCapVertex < 0.0) {\n        offsetPosition = centralVertex = screenStart;\n        offsetPosDepth = startPosition.zw;\n        roundedEnd = (geomType == VBB_GT_LINE_SEGMENT || geomType == VBB_GT_LINE_SEGMENT_CAPPED_END) ? 0.5 : 0.0;\n    } else {\n        offsetPosition = centralVertex = screenEnd;\n        offsetPosDepth = endPosition.zw;\n        roundedEnd = (geomType == VBB_GT_LINE_SEGMENT || geomType == VBB_GT_LINE_SEGMENT_CAPPED_START) ? 0.5 : 0.0;\n    }\n#ifdef HAS_LINESTYLES\n    roundedEnd += seg.lineType;\n#endif\n    vec2 screenDelta = screenEnd - screenStart;\n    float screenAngle = (distanceAlong == 0.0) ? 0.0 : atan(screenDelta.y, screenDelta.x);\n    float angleTransverse = screenAngle - isLeftSide * HALF_PI;\n    float lwAdjustment = fsHalfWidth + aaRange;\n    vec2 transverseDir = cos_sin(angleTransverse);\n    offsetPosition += transverseDir * lwAdjustment;\n    fsOffsetDirection = offsetPosition - centralVertex;\n    float distanceFromStart = max(0.0, isStartCapVertex) * length(screenDelta);\n    float segmentExtension = (roundedEnd > 0.0) ? lwAdjustment : aaRange;\n    vec2 moveOffset = isStartCapVertex * isLeftSide * vec2(-transverseDir.y, transverseDir.x) * segmentExtension;\n    offsetPosition += moveOffset;\n    fsMultipurpose.x = (isStartCapVertex * segmentExtension) + distanceFromStart;\n    fsMultipurpose.y = length(screenDelta);\n    fsMultipurpose.z = seg.distTotal;\n    fsMultipurpose.w = roundedEnd;\n    if (seg.lineWidthHalf < 0.0)\n        fsHalfWidth = -fsHalfWidth;\n    gl_Position = vec4(2.0 * offsetPosition / size * offsetPosDepth.y, offsetPosDepth.xy);\n#include <logdepthbuf_vert>\n}\n#ifdef HAS_MITER_LINES\nstruct MiterSegmentData { float angle, distAlong, distAlongPN, anglePrev, angleNext, lineWidthHalf, lineType; };\nvoid decodeMiterSegment(out MiterSegmentData seg) {\n    seg.angle         = fields2.x * TAU - PI;\n    seg.distAlong     = fields2.y * max(unpackXform.x, unpackXform.y);\n    seg.anglePrev     = fields2.w * TAU - PI;\n    seg.lineWidthHalf = unpackLineWeight(fields2.z);\n    seg.lineType      = flags4b.z;\n    seg.angleNext     = extraParams.x * TAU - PI;\n    seg.distAlongPN   = extraParams.y * max(unpackXform.x, unpackXform.y);\n}\nvoid strokeMiterLineSegment() {\n    MiterSegmentData seg; decodeMiterSegment(seg);\n    float isStartCapVertex = isStartVertex() ? -1.0 :  1.0;\n    float isLeftSide       = isLeftVertex( ) ?  1.0 : -1.0;\n    float next = floor(seg.distAlongPN / miterCP);\n    float prev = seg.distAlongPN - (next * miterCP);\n    float distanceAlongNext = floor(next) / miterScaleFactor;\n    float distanceAlongPrev = floor(prev) / miterScaleFactor;\n    float distanceAlong = seg.distAlong;\n    vec2 along  = cos_sin(seg.anglePrev) * distanceAlongPrev;\n    vec2 along2 = cos_sin(seg.angle) * distanceAlong;\n    vec2 along3 = along2 + cos_sin(seg.angleNext) * distanceAlongNext;\n    vec4 prevPosition  = (mvpMatrix * modelMatrix * vec4(centralVertex.xy - along , 0.0, 1.0));\n    vec4 startPosition = (mvpMatrix * modelMatrix * vec4(centralVertex.xy         , 0.0, 1.0));\n    vec4 endPosition   = (mvpMatrix * modelMatrix * vec4(centralVertex.xy + along2, 0.0, 1.0));\n    vec4 nextPosition  = (mvpMatrix * modelMatrix * vec4(centralVertex.xy + along3, 0.0, 1.0));\n    vec2 screenPrev  = prevPosition.xy  * 0.5 * size / prevPosition.w;\n    vec2 screenStart = startPosition.xy * 0.5 * size / startPosition.w;\n    vec2 screenEnd   = endPosition.xy   * 0.5 * size / endPosition.w;\n    vec2 screenNext  = nextPosition.xy  * 0.5 * size / nextPosition.w;\n    if (isStartCapVertex < 0.0) {\n        offsetPosition = centralVertex = screenStart;\n        offsetPosDepth = startPosition.zw;\n    } else {\n        offsetPosition = centralVertex = screenEnd;\n        offsetPosDepth = endPosition.zw;\n    }\n    vec2 screenDelta = screenEnd - screenStart;\n    vec2 AB = normalize(screenStart.xy - screenPrev.xy);\n    vec2 BC = normalize(screenDelta);\n    vec2 CD = normalize(screenNext.xy - screenEnd.xy);\n    vec2 a = screenPrev;\n    vec2 b = screenStart;\n    vec2 c = screenEnd;\n    vec2 d = screenNext;\n    vec2 p = (isStartCapVertex < 0.0) ? a : d;\n    vec2 a2 = (isStartCapVertex < 0.0) ? a : c;\n    vec2 b2 = (isStartCapVertex < 0.0) ? b : d;\n    vec2 p2 = (isStartCapVertex < 0.0) ? c : b;\n    vec2 PP = (isStartCapVertex < 0.0) ? AB : CD;\n    vec2 normalBC = vec2(-BC.y, BC.x);\n    vec2 normalPP = vec2(-PP.y, PP.x);\n    float pIsLeftOfBC = ((c.x - b.x)*(p.y - b.y) - (c.y - b.y)*(p.x - b.x)) > 0.0 ? 1.0 : -1.0;\n    vec2 bN = b + normalBC * fsHalfWidth * pIsLeftOfBC;\n    vec2 cN = c + normalBC * fsHalfWidth * pIsLeftOfBC;\n    vec2 pN = p + normalPP * fsHalfWidth * pIsLeftOfBC;\n    float isPIntersecting = ((cN.x - bN.x)*(pN.y - bN.y) - (cN.y - bN.y)*(pN.x - bN.x)) * pIsLeftOfBC;\n    float p2IsLeftOfPP = ((b2.x - a2.x)*(p2.y - a2.y) - (b2.y - a2.y)*(p2.x - a2.x)) > 0.0 ? 1.0 : -1.0;\n    vec2 a2N = a2 + normalPP * fsHalfWidth * p2IsLeftOfPP;\n    vec2 b2N = b2 + normalPP * fsHalfWidth * p2IsLeftOfPP;\n    vec2 p2N = p2 + normalBC * fsHalfWidth * p2IsLeftOfPP;\n    float isP2Intersecting = ((b2N.x - a2N.x)*(p2N.y - a2N.y) - (b2N.y - a2N.y)*(p2N.x - a2N.x)) * p2IsLeftOfPP;\n    float tangentLength = (isStartCapVertex < 0.0) ? length(AB + BC) : length(BC + CD);\n    vec2 tangent = (isStartCapVertex < 0.0) ? normalize(AB + BC) : normalize(BC + CD);\n    vec2 miter = vec2(-tangent.y, tangent.x);\n    vec2 normal = (isStartCapVertex < 0.0) ? vec2(-AB.y, AB.x) : vec2(-BC.y, BC.x);\n    float miterLength = abs(1.0 / dot(miter, normal));\n    vec2 moveOffset;\n    float lwAdjustment = fsHalfWidth + aaRange;\n    if (miterLength > miterLimit || min(isPIntersecting, isP2Intersecting) < 0.0) {\n        moveOffset = isLeftSide * lwAdjustment * normalBC;\n    } else {\n        moveOffset = isLeftSide * miter * lwAdjustment * miterLength;\n    }\n    offsetPosition += moveOffset;\n    float distanceFromStart = max(0.0, isStartCapVertex) * (length(screenDelta) + dot(moveOffset, BC));\n    fsMultipurpose.x = distanceFromStart;\n    fsMultipurpose.y = length(screenDelta) + dot(moveOffset, BC);\n    fsMultipurpose.z = 0.0;\n#ifdef HAS_LINESTYLES\n    fsMultipurpose.w = seg.lineType + 0.5;\n#else\n    fsMultipurpose.w = 0.5;\n#endif\n    if (seg.lineWidthHalf < 0.0)\n        fsHalfWidth = -fsHalfWidth;\n    fsOffsetDirection = offsetPosition - BC * dot(moveOffset, BC) - centralVertex;\n    gl_Position = vec4(2.0 * offsetPosition / size * offsetPosDepth.y, offsetPosDepth.xy);\n#include <logdepthbuf_vert>    \n}\n#endif\nstruct CommonAttribs { vec2 pos; vec4 color; vec2 layerTC, vpTC; float lineWidthHalf, geomType, ghosting; };\nvoid decodeCommonAttribs(out CommonAttribs attribs) {\n    attribs.pos           = fields1.xy * unpackXform.xy + unpackXform.zw;\n    attribs.color         = getVertexColor();\n    attribs.geomType      = flags4b.y;\n    attribs.layerTC       = layerVp4b.xy / 255.0;\n    attribs.vpTC          = layerVp4b.zw / 255.0;\n    attribs.lineWidthHalf = unpackLineWeight(fields2.z);\n    attribs.ghosting      = flags4b.w;\n}\nvoid strokeIndexedTriangle() {\n    fsHalfWidth = 0.0;\n    fsMultipurpose.z = 0.0;\n    gl_Position = (mvpMatrix * modelMatrix * vec4(centralVertex.xy, 0.0, 1.0));\n#include <logdepthbuf_vert>    \n}\n#ifdef SELECTION_RENDERER\nbool isSelected(const CommonAttribs attribs) {\n    vec3 oid = getDbId().rgb;\n    float id01 = oid.r + oid.g * 256.0;\n    float t = (id01 + 0.5) * (1.0 / 4096.0);\n    float flrt = floor(t);\n    float texU = t - flrt;\n    float id23 = oid.b * (65536.0 / 4096.0) + flrt;\n    t = (id23 + 0.5) / vSelTexSize.y;\n    float texV = fract(t);\n    vec4 selBit = texture2D(tSelectionTexture, vec2(texU, texV));\n    return selBit.r == 1.0;\n}\n#endif\nbool isLayerOff(const CommonAttribs attribs) {\n#ifdef HAS_LAYERS\n    vec4 layerBit = texture2D(tLayerMask, attribs.layerTC);\n    return (layerBit.r == 0.0);\n#else\n    return false;\n#endif\n}\nvec4 getColor(const CommonAttribs attribs) {\n    if (isLayerOff(attribs)) { return vec4(0.0); }\n#ifdef SELECTION_RENDERER\n    if (isSelected(attribs)) { return selectionColor; }\n    return vec4(0.0);\n#else\n    return attribs.color;\n#endif\n}\n#ifdef GAMMA_INPUT\nvec4 inputToLinear(vec4 c) {\n    return vec4(vec3(c*c), c.a);\n}\n#endif\nvoid main() {\n#ifndef UNPACK_POSITIONS\n    unpackXform = vec4(1.0, 1.0, 0.0, 0.0);\n#endif\n    CommonAttribs attribs; decodeCommonAttribs(attribs);\n    fsColor = getColor(attribs);\n    #ifdef GAMMA_INPUT\n    fsColor = inputToLinear(fsColor);\n    #endif\n    if (swap != 0.0 ) {\n        if ( fsColor.r == 0.0 && fsColor.g == 0.0 && fsColor.b == 0.0 )\n            fsColor.rgb = vec3(1.0,1.0,1.0);\n        else if ( fsColor.r == 1.0 && fsColor.g == 1.0 && fsColor.b == 1.0 )\n            fsColor.rgb = vec3(0.0,0.0,0.0);\n    }\n    centralVertex = offsetPosition = attribs.pos;\n    float lineWeight = attribs.lineWidthHalf;\n    float ppu = pixelsPerUnit;\n    if (tanHalfFov > 0.0) {\n        vec4 worldPos = modelMatrix * vec4(offsetPosition.xy, 0.0, 1.0);\n        float distanceToCamera = length(cameraPos - worldPos.xyz);\n        ppu = size.y / (2.0 * distanceToCamera * tanHalfFov);\n    }\n#ifdef HAS_LINESTYLES\n    vPixelsPerUnit = ppu;\n#endif\n    if (lineWeight > 0.0) {\n        lineWeight = max(0.5, lineWeight * ppu);\n    }\n    else {\n        lineWeight = max(0.5, abs(lineWeight));\n    }\n    fsHalfWidth = lineWeight;\n    dbId = dbId4b / 255.0;\n    fsVpTC     = attribs.vpTC;\n    fsGhosting = attribs.ghosting;\n#ifdef LOADING_ANIMATION\n    if (dbId.rgb == vec3(1.0)) {\n        loadingProgress = 1.0;\n    } else {\n        loadingProgress = smoothstep(0.0, 1.0, meshAnimTime);\n    }\n#endif\n    if      (attribs.geomType == VBB_GT_LINE_SEGMENT || attribs.geomType == VBB_GT_LINE_SEGMENT_CAPPED || attribs.geomType == VBB_GT_LINE_SEGMENT_CAPPED_START || attribs.geomType == VBB_GT_LINE_SEGMENT_CAPPED_END)     strokeLineSegment(attribs.geomType);\n#ifdef HAS_MITER_LINES\n    else if (attribs.geomType == VBB_GT_LINE_SEGMENT_MITER) strokeMiterLineSegment();\n#endif\n    else strokeIndexedTriangle();\n#if NUM_CUTPLANES > 0\n    vec4 worldPosition = modelMatrix * vec4( offsetPosition.xy, 0.0, 1.0 );\n    vWorldPosition = worldPosition.xyz;\n#endif\n#ifdef VIEWPORT_CLIPPING\n    vPosition = gl_Position.xy;\n#endif\n}\n";